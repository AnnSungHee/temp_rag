"glob" --- Unix style pathname pattern expansion
************************************************

**소스 코드:** Lib/glob.py

======================================================================

"glob" 모듈은 유닉스 셸이 사용하는 규칙에 따라 지정된 패턴과 일치하는
모든 경로명을 찾습니다. 하지만 결과는 임의의 순서로 반환됩니다. 물결표
(tilde) 확장은 수행되지 않지만, "*", "?" 및 "[]"로 표시되는 문자 범위
는 올바르게 일치합니다. 이는 서브 셸을 실제로 호출하지 않고
"os.scandir()" 과 "fnmatch.fnmatch()" 함수를 사용하여 수행됩니다.

"fnmatch.fnmatch()"나 "pathlib.Path.glob()"과 달리, 점(".")으로 시작하
는 파일은 점으로 시작하는 패턴으로만 일치시킬 수 있습니다. (물결표와
셸 변수 확장은 "os.path.expanduser()" 와 "os.path.expandvars()"를 사용
하십시오.)

리터럴 일치를 위해서는, 대괄호 안에 메타 문자를 넣습니다. 예를 들어,
"'[?]'"는 "'?'" 문자와 일치합니다.

더 보기: "pathlib" 모듈은 고수준의 경로 객체를 제공합니다.

glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False)

   Return a possibly empty list of path names that match *pathname*,
   which must be a string containing a path specification. *pathname*
   can be either absolute (like "/usr/src/Python-1.5/Makefile") or
   relative (like "../../Tools/*/*.gif"), and can contain shell-style
   wildcards. Broken symlinks are included in the results (as in the
   shell). Whether or not the results are sorted depends on the file
   system.  If a file that satisfies conditions is removed or added
   during the call of this function, whether a path name for that file
   be included is unspecified.

   If *root_dir* is not "None", it should be a *path-like object*
   specifying the root directory for searching.  It has the same
   effect on "glob()" as changing the current directory before calling
   it.  If *pathname* is relative, the result will contain paths
   relative to *root_dir*.

   This function can support paths relative to directory descriptors
   with the *dir_fd* parameter.

   *recursive*가 참이면, ""**"" 패턴은 모든 파일과 0개 이상의 디렉터리
   , 서브 디렉터리 및 디렉터리로의 심볼릭 링크와 일치합니다. 패턴 다음
   에 "os.sep"이나 "os.altsep"이 오면, 파일은 일치하지 않습니다.

   "pathname", "recursive"를 인자로 감사 이벤트(auditing event)
   "glob.glob"을 발생시킵니다.

   "pathname", "recursive", "root_dir", "dir_fd"를 인자로 감사 이벤트
   (auditing event) "glob.glob/2"을 발생시킵니다.

   참고:

     커다란 디렉터리 트리에서 ""**"" 패턴을 사용하면 과도한 시간이 걸
     릴 수 있습니다.

   버전 3.5에서 변경: ""**"" 를 사용하는 재귀적 glob 지원.

   버전 3.10에서 변경: *root_dir* 과 *dir_fd* 매개 변수를 추가했습니다
   .

glob.iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False)

   실제로 동시에 저장하지 않고 "glob()"과 같은 값을 산출하는 *이터레이
   터*를 반환합니다.

   "pathname", "recursive"를 인자로 감사 이벤트(auditing event)
   "glob.glob"을 발생시킵니다.

   "pathname", "recursive", "root_dir", "dir_fd"를 인자로 감사 이벤트
   (auditing event) "glob.glob/2"을 발생시킵니다.

   버전 3.5에서 변경: ""**"" 를 사용하는 재귀적 glob 지원.

   버전 3.10에서 변경: *root_dir* 과 *dir_fd* 매개 변수를 추가했습니다
   .

glob.escape(pathname)

   모든 특수 문자("'?'", "'*'" 및 "'['")를 이스케이프 처리합니다. 이것
   은 특수 문자가 들어있을 수 있는 임의의 리터럴 문자열을 일치시키려는
   경우에 유용합니다. 드라이브/UNC 셰어 포인트의 특수 문자는 이스케이
   프 되지 않습니다, 예를 들어, 윈도우에서 "escape('//?/c:/Quo
   vadis?.txt')"는 "'//?/c:/Quo vadis[?].txt'"를 반환합니다.

   버전 3.4에 추가.

For example, consider a directory containing the following files:
"1.gif", "2.txt", "card.gif" and a subdirectory "sub" which contains
only the file "3.txt".  "glob()" will produce the following results.
Notice how any leading components of the path are preserved.

   >>> import glob
   >>> glob.glob('./[0-9].*')
   ['./1.gif', './2.txt']
   >>> glob.glob('*.gif')
   ['1.gif', 'card.gif']
   >>> glob.glob('?.gif')
   ['1.gif']
   >>> glob.glob('**/*.txt', recursive=True)
   ['2.txt', 'sub/3.txt']
   >>> glob.glob('./**/', recursive=True)
   ['./', './sub/']

디렉터리에 "."으로 시작하는 파일이 있으면, 기본적으로 일치하지 않습니
다. 예를 들어, "card.gif" 와 ".card.gif"를 포함하는 디렉터리를 고려하
십시오:

   >>> import glob
   >>> glob.glob('*.gif')
   ['card.gif']
   >>> glob.glob('.c*')
   ['.card.gif']

더 보기:

  Module "fnmatch"
     Shell-style filename (not path) expansion
