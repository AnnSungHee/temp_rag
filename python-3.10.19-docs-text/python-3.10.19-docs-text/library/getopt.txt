"getopt" --- C-style parser for command line options
****************************************************

**소스 코드:** Lib/getopt.py

참고:

  The "getopt" module is a parser for command line options whose API
  is designed to be familiar to users of the C "getopt()" function.
  Users who are unfamiliar with the C "getopt()" function or who would
  like to write less code and get better help and error messages
  should consider using the "argparse" module instead.

======================================================================

This module helps scripts to parse the command line arguments in
"sys.argv". It supports the same conventions as the Unix "getopt()"
function (including the special meanings of arguments of the form
'"-"' and '"--"').  Long options similar to those supported by GNU
software may be used as well via an optional third argument.

이 모듈은 두 가지 함수와 예외를 제공합니다:

getopt.getopt(args, shortopts, longopts=[])

   Parses command line options and parameter list.  *args* is the
   argument list to be parsed, without the leading reference to the
   running program. Typically, this means "sys.argv[1:]". *shortopts*
   is the string of option letters that the script wants to recognize,
   with options that require an argument followed by a colon ("':'";
   i.e., the same format that Unix "getopt()" uses).

   참고:

     Unlike GNU "getopt()", after a non-option argument, all further
     arguments are considered also non-options. This is similar to the
     way non-GNU Unix systems work.

   지정되면, *longopts*는 지원되어야 하는 긴 옵션의 이름을 가진 문자열
   리스트여야 합니다. 선행 "'--'" 문자는 옵션 이름에 포함되지 않아야
   합니다. 인자가 필요한 긴 옵션 뒤에는 등호("'='")가 와야 합니다. 선
   택적 인자는 지원되지 않습니다. 긴 옵션만 허용하려면, *shortopts*는
   빈 문자열이어야 합니다. 명령 줄에서 긴 옵션은 허용된 옵션 중 하나와
   정확히 일치하는 옵션 이름의 접두사를 제공하는 한 인식 할 수 있습니
   다. 예를 들어, *longopts*가 "['foo', 'frob']" 면 "--fo" 옵션은 "--
   foo"로 일치하지만, "--f"는 유일하게 일치하지 않으므로 "GetoptError"
   가 발생합니다.

   반환 값은 두 요소로 구성됩니다: 첫 번째는 "(option, value)" 쌍의 리
   스트입니다; 두 번째는 옵션 리스트가 제거된 후 남겨진 프로그램 인자
   리스트입니다 (이것은 *args*의 후행 슬라이스입니다). 반환된 각 옵션-
   값 쌍은 첫 번째 요소로 옵션을 가지며, 짧은 옵션(예를 들어, "'-x'")
   은 하이픈이, 긴 옵션(예를 들어, "'--long-option'")은 두 개의 하이픈
   이 접두사로 붙고, 두 번째 요소는 옵션 인자나 옵션에 인자가 없으면
   빈 문자열입니다. 옵션은 발견된 순서와 같은 순서로 리스트에 나타나므
   로, 여러 번 나오는 것을 허용합니다. 긴 옵션과 짧은 옵션은 혼합될 수
   있습니다.

getopt.gnu_getopt(args, shortopts, longopts=[])

   이 함수는 기본적으로 GNU 스타일 스캔 모드가 사용된다는 점을 제외하
   고는 "getopt()"처럼 작동합니다. 이것은 옵션과 옵션이 아닌 인자가 섞
   일 수 있음을 뜻합니다. "getopt()" 함수는 옵션이 아닌 인자가 발견되
   자마자 옵션 처리를 중지합니다.

   If the first character of the option string is "'+'", or if the
   environment variable "POSIXLY_CORRECT" is set, then option
   processing stops as soon as a non-option argument is encountered.

exception getopt.GetoptError

   This is raised when an unrecognized option is found in the argument
   list or when an option requiring an argument is given none. The
   argument to the exception is a string indicating the cause of the
   error.  For long options, an argument given to an option which does
   not require one will also cause this exception to be raised.  The
   attributes "msg" and "opt" give the error message and related
   option; if there is no specific option to which the exception
   relates, "opt" is an empty string.

exception getopt.error

   "GetoptError"의 별칭; 과거 호환성을 위한 것입니다.

유닉스 스타일 옵션만 사용하는 예제:

>>> import getopt
>>> args = '-a -b -cfoo -d bar a1 a2'.split()
>>> args
['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
>>> optlist, args = getopt.getopt(args, 'abc:d:')
>>> optlist
[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
>>> args
['a1', 'a2']

긴 옵션 이름을 사용하는 것도 똑같이 간단합니다:

>>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'
>>> args = s.split()
>>> args
['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
>>> optlist, args = getopt.getopt(args, 'x', [
...     'condition=', 'output-file=', 'testing'])
>>> optlist
[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]
>>> args
['a1', 'a2']

In a script, typical usage is something like this:

   import getopt, sys

   def main():
       try:
           opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
       except getopt.GetoptError as err:
           # print help information and exit:
           print(err)  # will print something like "option -a not recognized"
           usage()
           sys.exit(2)
       output = None
       verbose = False
       for o, a in opts:
           if o == "-v":
               verbose = True
           elif o in ("-h", "--help"):
               usage()
               sys.exit()
           elif o in ("-o", "--output"):
               output = a
           else:
               assert False, "unhandled option"
       # ...

   if __name__ == "__main__":
       main()

Note that an equivalent command line interface could be produced with
less code and more informative help and error messages by using the
"argparse" module:

   import argparse

   if __name__ == '__main__':
       parser = argparse.ArgumentParser()
       parser.add_argument('-o', '--output')
       parser.add_argument('-v', dest='verbose', action='store_true')
       args = parser.parse_args()
       # ... do something with args.output ...
       # ... do something with args.verbose ..

더 보기:

  모듈 "argparse"
     Alternative command line option and argument parsing library.
