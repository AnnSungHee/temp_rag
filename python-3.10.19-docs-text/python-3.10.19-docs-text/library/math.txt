"math" --- Mathematical functions
*********************************

======================================================================

이 모듈은 C 표준에서 정의된 수학 함수에 대한 액세스를 제공합니다.

이 함수는 복소수와 함께 사용할 수 없습니다; 복소수를 지원해야 하면
"cmath" 모듈에 있는 같은 이름의 함수를 사용하십시오. 대부분 사용자는
복소수를 이해하는 데 필요한 수준의 수학을 배우고 싶어 하지 않기 때문에
복소수를 지원하는 함수와 그렇지 않은 함수를 구별했습니다. 복소수 결과
대신 예외를 수신하면 매개 변수로 사용된 예상치 못한 복소수를 조기에 감
지할 수 있기 때문에, 프로그래머는 처음 위치에서 생성된 경로와 원인을
파악할 수 있습니다.

이 모듈에서 제공하는 함수는 다음과 같습니다. 달리 명시되지 않는 한 모
든 반환 값은 float입니다.


Number-theoretic and representation functions
=============================================

math.ceil(x)

   *x*보다 크거나 같은 가장 작은 정수인 *x*의 천장값(ceiling)을 반환합
   니다. *x*가 float가 아니면, "x.__ceil__"에 위임하고, 이것은
   "Integral" 값을 반환해야 합니다.

math.comb(n, k)

   반복과 순서 없이 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법의
   수를 반환합니다.

   "k <= n"이면 "n! / (k! * (n - k)!)"로 평가되고, "k > n"이면 0으로
   평가됩니다.

   Also called the binomial coefficient because it is equivalent to
   the coefficient of k-th term in polynomial expansion of the
   expression "(1 + x) ** n".

   인자 중 어느 하나라도 정수가 아니면 "TypeError"를 발생시킵니다. 인
   자 중 어느 하나라도 음수이면 "ValueError"를 발생시킵니다.

   버전 3.8에 추가.

math.copysign(x, y)

   *x*의 크기(절댓값)와 *y*의 부호를 갖는 float를 반환합니다. 부호 있
   는 0을 지원하는 플랫폼에서, "copysign(1.0, -0.0)"은 *-1.0*을 반환합
   니다.

math.fabs(x)

   *x*의 절댓값을 반환합니다.

math.factorial(x)

   Return *x* factorial as an integer.  Raises "ValueError" if *x* is
   not integral or is negative.

   버전 3.9부터 폐지: Accepting floats with integral values (like
   "5.0") is deprecated.

math.floor(x)

   *x*보다 작거나 같은 가장 큰 정수인 *x*의 바닥값(floor)을 반환합니다
   . *x*가 float가 아니면, "x.__floor__"에 위임하고, 이것은 "Integral"
   값을 반환해야 합니다.

math.fmod(x, y)

   Return "fmod(x, y)", as defined by the platform C library. Note
   that the Python expression "x % y" may not return the same result.
   The intent of the C standard is that "fmod(x, y)" be exactly
   (mathematically; to infinite precision) equal to "x - n*y" for some
   integer *n* such that the result has the same sign as *x* and
   magnitude less than "abs(y)".  Python's "x % y" returns a result
   with the sign of *y* instead, and may not be exactly computable for
   float arguments. For example, "fmod(-1e-100, 1e100)" is "-1e-100",
   but the result of Python's "-1e-100 % 1e100" is "1e100-1e-100",
   which cannot be represented exactly as a float, and rounds to the
   surprising "1e100".  For this reason, function "fmod()" is
   generally preferred when working with floats, while Python's "x %
   y" is preferred when working with integers.

math.frexp(x)

   *x*의 가수(mantissa)와 지수(exponent)를 "(m, e)" 쌍으로 반환합니다.
   *m*은 float이고, *e*는 정수이며, 정확히 "x == m * 2**e"가 성립합니
   다. *x*가 0이면, "(0.0, 0)"을 반환하고, 그렇지 않으면 "0.5 <=
   abs(m) < 1"입니다. 이것은 float의 내부 표현을 이식성 있는 방식으로
   "분리"하는 데 사용됩니다.

math.fsum(iterable)

   Return an accurate floating point sum of values in the iterable.
   Avoids loss of precision by tracking multiple intermediate partial
   sums:

      >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
      0.9999999999999999
      >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
      1.0

   알고리즘의 정확도는 IEEE-754 산술의 보증과 자리 올림 모드가 짝수로
   반올림(half-even)인 일반적인 경우에 의존합니다. 윈도우 이외의 일부
   빌드에서, 하부 C 라이브러리는 확장 정밀도 덧셈을 사용하고, 때때로
   중간 합을 이중 자리 올림(double-round) 하여 최하위 비트(least
   significant bit)에서 분리할 수 있습니다.

   For further discussion and two alternative approaches, see the ASPN
   cookbook recipes for accurate floating point summation.

math.gcd(*integers)

   지정된 정수 인자의 최대 공약수를 반환합니다. 인자 중 하나가 0이 아
   니면, 반환된 값은 모든 인자를 나누는 가장 큰 양의 정수입니다. 모든
   인자가 0이면, 반환 값은 "0"입니다. 인자가 없는 "gcd()"는 "0"을 반환
   합니다.

   버전 3.5에 추가.

   버전 3.9에서 변경: 임의의 개수 인자에 대한 지원이 추가되었습니다.
   이전에는, 단지 두 개의 인자만 지원되었습니다.

math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)

   값 *a*와 *b*가 서로 가까이 있으면 "True"를, 그렇지 않으면 "False"를
   반환합니다.

   Whether or not two values are considered close is determined
   according to given absolute and relative tolerances.

   *rel_tol* is the relative tolerance -- it is the maximum allowed
   difference between *a* and *b*, relative to the larger absolute
   value of *a* or *b*. For example, to set a tolerance of 5%, pass
   "rel_tol=0.05".  The default tolerance is "1e-09", which assures
   that the two values are the same within about 9 decimal digits.
   *rel_tol* must be greater than zero.

   *abs_tol* is the minimum absolute tolerance -- useful for
   comparisons near zero. *abs_tol* must be at least zero.

   If no errors occur, the result will be: "abs(a-b) <= max(rel_tol *
   max(abs(a), abs(b)), abs_tol)".

   IEEE 754 특수 값 "NaN", "inf" 및 "-inf"는 IEEE 규칙에 따라 처리됩니
   다. 특히, "NaN"은 "NaN"을 포함하여 다른 어떤 값과도 근접한 것으로
   간주하지 않습니다. "inf"와 "-inf"는 오직 자신과만 가까운 것으로 간
   주합니다.

   버전 3.5에 추가.

   더 보기: **PEP 485** -- 근사적 동등성을 검사하는 함수

math.isfinite(x)

   *x*가 무한대나 NaN이 아니면 "True"를, 그렇지 않으면 "False"를 반환
   합니다. ("0.0"은 *유한*한 것으로 간주합니다.)

   버전 3.2에 추가.

math.isinf(x)

   *x*가 양 또는 음의 무한대이면 "True"를, 그렇지 않으면 "False"를 반
   환합니다.

math.isnan(x)

   *x*가 NaN(not a number)이면 "True"를, 그렇지 않으면 "False"를 반환
   합니다.

math.isqrt(n)

   음이 아닌 정수 *n*의 정수 제곱근을 반환합니다. 이것은 *n*의 정확한
   제곱근의 바닥(floor)입니다, 또는, 동등하게, *a*² ≤ *n*을 만족하는
   가장 큰 정수 *a*입니다.

   일부 응용 프로그램에서는, *n* ≤ *a*² 을 만족하는 가장 작은 정수
   *a*, 즉 *n*의 정확한 제곱근의 천장(ceiling)을 구하는 것이 더 편리합
   니다. 양의 *n*에 대해, 이것은 "a = 1 + isqrt(n - 1)"을 사용하여 계
   산할 수 있습니다.

   버전 3.8에 추가.

math.lcm(*integers)

   지정된 정수 인자의 최소 공배수를 반환합니다. 모든 인자가 0이 아니면
   , 반환 값은 모든 인자의 배수인 가장 작은 양의 정수입니다. 인자 중
   어느 하나가 0이면, 반환 값은 "0"입니다. 인자가 없는 "lcm()"은 "1"을
   반환합니다.

   버전 3.9에 추가.

math.ldexp(x, i)

   "x * (2**i)"를 반환합니다. 이것은 본질적으로 함수 "frexp()"의 역입
   니다.

math.modf(x)

   *x*의 소수와 정수 부분을 반환합니다. 두 결과 모두 *x*의 부호를 가지
   며 float입니다.

math.nextafter(x, y)

   Return the next floating-point value after *x* towards *y*.

   If *x* is equal to *y*, return *y*.

   예:

   * "math.nextafter(x, math.inf)"는 올라갑니다: 양의 무한대를 향해.

   * "math.nextafter(x, -math.inf)"는 내려갑니다: 음의 무한대를 향해.

   * "math.nextafter(x, 0.0)"는 0을 향합니다.

   * "math.nextafter(x, math.copysign(math.inf, x))"는 0에서 멀어집니
     다.

   "math.ulp()"도 참조하십시오.

   버전 3.9에 추가.

math.perm(n, k=None)

   반복 없고 순서 있게 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법
   의 수를 반환합니다.

   "k <= n"이면 "n! / (n - k)!" 로 평가되고, "k > n"이면 0으로 평가됩
   니다.

   If *k* is not specified or is None, then *k* defaults to *n* and
   the function returns "n!".

   인자 중 어느 하나라도 정수가 아니면 "TypeError"를 발생시킵니다. 인
   자 중 어느 하나라도 음수이면 "ValueError"를 발생시킵니다.

   버전 3.8에 추가.

math.prod(iterable, *, start=1)

   입력 *이터러블(iterable)*에 있는 모든 요소의 곱을 계산합니다. 곱의
   기본 *start* 값은 "1"입니다.

   iterable이 비어 있으면, start 값을 반환합니다. 이 함수는 숫자 값과
   함께 사용하기 위한 것으로, 숫자가 아닌 형을 거부 할 수 있습니다.

   버전 3.8에 추가.

math.remainder(x, y)

   *y*에 대한 *x*의 IEEE 754 스타일 나머지를 반환합니다. 유한한 *x* 와
   0이 아닌 유한한 *y*에 대해, 이것은 차이 "x - n*y"입니다. 여기서 "n"
   은 몫 "x / y"의 정확한 값에 가장 가까운 정수입니다. "x / y"가 두 개
   의 인접한 정수 사이의 정확히 중간이면, 가장 가까운 *짝수* 정수가
   "n"으로 사용됩니다. 따라서 나머지 "r = remainder(x, y)"는 항상
   "abs(r) <= 0.5 * abs(y)"를 만족합니다.

   IEEE 754에 따른 특별한 경우: 특히, "remainder(x, math.inf)"는 모든
   유한한 *x*에 대해서는 *x*이고, "remainder(x, 0)"과
   "remainder(math.inf, x)"는 모든 NaN이 아닌 *x*에 대해 "ValueError"
   를 발생시킵니다. 나머지 연산의 결과가 0이면, 해당 0은 *x* 와 같은
   부호를 갖습니다.

   On platforms using IEEE 754 binary floating-point, the result of
   this operation is always exactly representable: no rounding error
   is introduced.

   버전 3.7에 추가.

math.trunc(x)

   Return *x* with the fractional part removed, leaving the integer
   part.  This rounds toward 0: "trunc()" is equivalent to "floor()"
   for positive *x*, and equivalent to "ceil()" for negative *x*. If
   *x* is not a float, delegates to "x.__trunc__", which should return
   an "Integral" value.

math.ulp(x)

   float *x*의 최하위 비트 값을 반환합니다:

   * *x*가 NaN(not a number)이면, *x*를 반환합니다.

   * *x*가 음수이면, "ulp(-x)"를 반환합니다.

   * *x*가 양의 무한대이면, *x*를 반환합니다.

   * *x*가 0과 같으면, 가장 작은 양의 *정규화되지 않은(denormalized)*
     표현 가능한 float를 반환합니다 (가장 작은 양의 *정규화된* float,
     "sys.float_info.min"보다 작습니다).

   * *x*가 가장 큰 양의 표현 가능한 float와 같으면, *x*보다 작은 첫 번
     째 float가 "x - ulp(x)"가 되도록, *x*의 최하위 비트 값을 반환합니
     다.

   * 그렇지 않으면 (*x*가 양의 유한 수이면), *x*보다 큰 첫 번째 float
     가 "x + ulp(x)"가 되도록, *x*의 최하위 비트 값을 반환합니다.

   ULP는 "Unit in the Last Place(마지막 자리의 단위)"를 나타냅니다.

   "math.nextafter()"와 "sys.float_info.epsilon"도 참조하십시오.

   버전 3.9에 추가.

Note that "frexp()" and "modf()" have a different call/return pattern
than their C equivalents: they take a single argument and return a
pair of values, rather than returning their second return value
through an 'output parameter' (there is no such thing in Python).

"ceil()", "floor()" 및 "modf()" 함수의 경우, 충분히 큰 절댓값을 갖는 *
모든* 부동 소수점 숫자는 정확한 정수입니다. 파이썬 float는 일반적으로
53비트 이하의 정밀도를 가지는데 (플랫폼 C double 형과 같습니다), 이때
"abs(x) >= 2**52"를 만족하는 모든 float *x*는 소수 비트를 갖지 않습니
다.


Power and logarithmic functions
===============================

math.exp(x)

   *e*의 *x* 거듭제곱을 반환합니다. 여기서 *e* = 2.718281... 는 자연로
   그의 밑(base)입니다. 일반적으로 "math.e ** x"나 "pow(math.e, x)"보
   다 정확합니다.

math.expm1(x)

   Return *e* raised to the power *x*, minus 1.  Here *e* is the base
   of natural logarithms.  For small floats *x*, the subtraction in
   "exp(x) - 1" can result in a significant loss of precision; the
   "expm1()" function provides a way to compute this quantity to full
   precision:

      >>> from math import exp, expm1
      >>> exp(1e-5) - 1  # gives result accurate to 11 places
      1.0000050000069649e-05
      >>> expm1(1e-5)    # result accurate to full precision
      1.0000050000166668e-05

   버전 3.2에 추가.

math.log(x[, base])

   하나의 인자를 제공하면, *x*의 자연로그를 반환합니다 (밑 *e*).

   두 개의 인자를 제공하면, 주어진 *밑(base)*으로 *x*의 로그를 반환합
   니다, "log(x)/log(base)"로 계산합니다.

math.log1p(x)

   *1+x*의 자연로그를 반환합니다 (밑 *e*). 결과는 0에 가까운 *x*에 대
   해 정확한 방식으로 계산됩니다.

math.log2(x)

   *x*의 밑이 2인 로그를 반환합니다. 이것은 일반적으로 "log(x, 2)"보다
   정확합니다.

   버전 3.3에 추가.

   더 보기:

     "int.bit_length()"는 부호와 선행 0을 제외하고 정수를 이진수로 나
     타내는 데 필요한 비트 수를 반환합니다.

math.log10(x)

   *x*의 밑이 10인 로그를 반환합니다. 이것은 일반적으로 "log(x, 10)"보
   다 정확합니다.

math.pow(x, y)

   Return "x" raised to the power "y".  Exceptional cases follow Annex
   'F' of the C99 standard as far as possible.  In particular,
   "pow(1.0, x)" and "pow(x, 0.0)" always return "1.0", even when "x"
   is a zero or a NaN.  If both "x" and "y" are finite, "x" is
   negative, and "y" is not an integer then "pow(x, y)" is undefined,
   and raises "ValueError".

   내장 "**" 연산자와 달리, "math.pow()"는 두 인자를 모두 "float" 형으
   로 변환합니다. 정확한 정수 거듭제곱을 계산하려면 "**"나 내장
   "pow()" 함수를 사용하십시오.

math.sqrt(x)

   *x*의 제곱근을 반환합니다.


삼각 함수
=========

math.acos(x)

   *x*의 아크 코사인(arc cosine)을 라디안으로 반환합니다. 결과는 "0"과
   "pi" 사이입니다.

math.asin(x)

   *x*의 아크 사인(arc sine)을 라디안으로 반환합니다. 결과는 "-pi/2"와
   "pi/2" 사이입니다.

math.atan(x)

   *x*의 아크 탄젠트(arc tangent)를 라디안으로 반환합니다. 결과는
   "-pi/2"와 "pi/2" 사이입니다.

math.atan2(y, x)

   "atan(y / x)"를 라디안으로 반환합니다. 결과는 "-pi"와 "pi" 사이입니
   다. 평면에 있는 원점에서 점 "(x, y)"까지의 벡터는 양의 X 축과 이 각
   도를 이룹니다. "atan2()"의 요점은 두 입력의 부호가 모두 알려져 있기
   때문에 각도에 대한 정확한 사분면을 계산할 수 있다는 것입니다. 예를
   들어, "atan(1)"과 "atan2(1, 1)"은 모두 "pi/4"이지만, "atan2(-1,
   -1)"은 "-3*pi/4"입니다.

math.cos(x)

   *x* 라디안의 코사인(cosine)을 반환합니다.

math.dist(p, q)

   각각 좌표 시퀀스(또는 이터러블)로 제공되는, 두 점 *p*와 *q* 사이의
   유클리드 거리를 반환합니다. 두 점의 차원(dimension)은 같아야 합니다
   .

   대략 다음과 동등합니다:

      sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))

   버전 3.8에 추가.

math.hypot(*coordinates)

   유클리드 크기(norm) "sqrt(sum(x**2 for x in coordinates))"를 반환합
   니다. 원점에서 coordinates로 지정된 점까지의 벡터의 길이입니다.

   2차원 점 "(x, y)"의 경우, 피타고라스 정리를 사용하여 직각 삼각형의
   빗변(hypotenuse)을 계산하는 것과 동등합니다, "sqrt(x*x + y*y)".

   버전 3.8에서 변경: n 차원 점에 대한 지원이 추가되었습니다. 이전에는
   , 2차원인 경우만 지원되었습니다.

   버전 3.10에서 변경: Improved the algorithm's accuracy so that the
   maximum error is under 1 ulp (unit in the last place).  More
   typically, the result is almost always correctly rounded to within
   1/2 ulp.

math.sin(x)

   *x* 라디안의 사인(sine)을 반환합니다.

math.tan(x)

   *x* 라디안의 탄젠트(tangent)를 반환합니다.


각도 변환
=========

math.degrees(x)

   각도 *x*를 라디안에서 도(degree)로 변환합니다.

math.radians(x)

   각도 *x*를 도(degree)에서 라디안으로 변환합니다.


쌍곡선 함수
===========

Hyperbolic functions are analogs of trigonometric functions that are
based on hyperbolas instead of circles.

math.acosh(x)

   *x*의 역 쌍곡 코사인(inverse hyperbolic cosine)을 반환합니다.

math.asinh(x)

   *x*의 역 쌍곡 사인(inverse hyperbolic sine)을 반환합니다.

math.atanh(x)

   *x*의 역 쌍곡 탄젠트(inverse hyperbolic tangent)를 반환합니다.

math.cosh(x)

   *x*의 쌍곡 코사인(hyperbolic cosine)을 반환합니다.

math.sinh(x)

   *x*의 쌍곡 사인(hyperbolic sine)을 반환합니다.

math.tanh(x)

   *x*의 쌍곡 탄젠트(hyperbolic tangent)를 반환합니다.


특수 함수
=========

math.erf(x)

   *x*의 오차 함수(error function)를 반환합니다.

   The "erf()" function can be used to compute traditional statistical
   functions such as the cumulative standard normal distribution:

      def phi(x):
          'Cumulative distribution function for the standard normal distribution'
          return (1.0 + erf(x / sqrt(2.0))) / 2.0

   버전 3.2에 추가.

math.erfc(x)

   *x*의 여오차 함수를 반환합니다. 여오차 함수(complementary error
   function)는 "1.0 - erf(x)"로 정의됩니다. 뺄셈으로 인해 유효 숫자의
   소실이 발생하는 *x*의 큰 값에 사용됩니다.

   버전 3.2에 추가.

math.gamma(x)

   *x*의 감마 함수(Gamma function)를 반환합니다.

   버전 3.2에 추가.

math.lgamma(x)

   *x*의 감마 함수의 절댓값의 자연로그를 반환합니다.

   버전 3.2에 추가.


상수
====

math.pi

   사용 가능한 정밀도로, 수학 상수 *π* = 3.141592...

math.e

   사용 가능한 정밀도로, 수학 상수 *e* = 2.718281...

math.tau

   사용 가능한 정밀도로, 수학 상수 *τ* = 6.283185... 타우(tau)는 원주
   와 반지름의 비율인 2*π*에 해당하는 원 상수입니다. 타우에 대한 자세
   한 내용은, Vi Hart의 비디오 Pi is (still) Wrongdmf 확인하고, 두 배
   의 파이를 먹는 것으로 타우 데이(Tau day)를 축하하십시오!

   버전 3.6에 추가.

math.inf

   부동 소수점 양의 무한대. (음의 무한대는 "-math.inf"를 사용하십시오
   .) "float('inf')"의 출력과 동등합니다.

   버전 3.5에 추가.

math.nan

   A floating-point "not a number" (NaN) value. Equivalent to the
   output of "float('nan')". Due to the requirements of the IEEE-754
   standard, "math.nan" and "float('nan')" are not considered to equal
   to any other numeric value, including themselves. To check whether
   a number is a NaN, use the "isnan()" function to test for NaNs
   instead of "is" or "==". Example:

      >>> import math
      >>> math.nan == math.nan
      False
      >>> float('nan') == float('nan')
      False
      >>> math.isnan(math.nan)
      True
      >>> math.isnan(float('nan'))
      True

   버전 3.5에 추가.

**CPython 구현 상세:** "math" 모듈은 대부분 플랫폼 C 수학 라이브러리
함수 주위의 얇은 래퍼로 구성됩니다. 예외적인 경우의 행동은 적절한 경우
C99 표준의 부록 F를 따릅니다. 현재 구현은 "sqrt(-1.0)"이나 "log(0.0)"
과 같은 잘못된 연산의 경우 "ValueError"를 발생시키고 (C99 부록 F에서
잘못된 연산이나 0으로 나누기를 신호를 주도록 권장하는 경우), 오버플로
하는 결과(예를 들어, "exp(1000.0)")의 경우 "OverflowError"를 발생시킵
니다. 하나 이상의 입력 인자가 NaN이 아니면, NaN은 위의 함수에서 반환되
지 않습니다; 입력 인자가 NaN이면 대부분 함수는 NaN을 반환하지만, (다시
한번 C99 부록 F를 따라) 이 규칙에는 예를 들어 "pow(float('nan'), 0.0)"
이나 "hypot(float('nan'), float('inf'))"와 같은 몇 가지 예외가 있습니
다.

파이썬은 신호를 주는 NaN(signaling NaN)을 조용한 NaN(quiet NaN)과 구별
하기 위해 노력하지 않으며, 신호를 주는 NaN의 동작은 지정되지 않은 상태
로 남아 있습니다. 일반적인 동작은 모든 NaN을 조용한 것으로 취급하는 것
입니다.

더 보기:

  모듈 "cmath"
     이 함수 중 많은 것들의 복소수 버전.
