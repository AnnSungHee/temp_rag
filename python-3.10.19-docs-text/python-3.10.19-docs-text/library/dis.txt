"dis" --- Disassembler for Python bytecode
******************************************

**소스 코드:** Lib/dis.py

======================================================================

"dis" 모듈은 CPython *바이트 코드*를 역 어셈블 하여 분석을 지원합니다.
이 모듈이 입력으로 취하는 CPython 바이트 코드는 파일
"Include/opcode.h"에 정의되어 있으며 컴파일러와 인터프리터에서 사용됩
니다.

**CPython 구현 상세:** 바이트 코드는 CPython 인터프리터의 구현 세부 사
항입니다. 파이썬 버전 간에 바이트 코드가 추가, 제거 또는 변경되지 않을
것이라는 보장은 없습니다. 이 모듈을 사용하는 것이 파이썬 VM이나 파이썬
릴리스에 걸쳐 작동할 것으로 생각하지 말아야 합니다.

버전 3.6에서 변경: 명령어마다 2바이트를 사용합니다. 이전에는 바이트 수
가 명령어에 따라 달랐습니다.

버전 3.10에서 변경: The argument of jump, exception handling and loop
instructions is now the instruction offset rather than the byte
offset.

Example: Given the function "myfunc()":

   def myfunc(alist):
       return len(alist)

the following command can be used to display the disassembly of
"myfunc()":

   >>> dis.dis(myfunc)
     2           0 LOAD_GLOBAL              0 (len)
                 2 LOAD_FAST                0 (alist)
                 4 CALL_FUNCTION            1
                 6 RETURN_VALUE

("2"는 줄 번호입니다).


바이트 코드 분석
================

버전 3.4에 추가.

바이트 코드 분석 API는 컴파일된 코드의 세부 사항에 쉽게 액세스 할 수
있도록 하는 "Bytecode" 객체로 파이썬 코드 조각을 감쌀 수 있도록 합니다
.

class dis.Bytecode(x, *, first_line=None, current_offset=None)

   함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자
   열 또는 ("compile()"에서 반환된) 코드 객체에 해당하는 바이트 코드를
   분석합니다.

   이것은 아래에 나열된 많은 함수, 특히 "get_instructions()"를 둘러싼
   편리한 래퍼입니다, "Bytecode" 인스턴스를 이터레이트 하면 바이트 코
   드 연산이 "Instruction" 인스턴스로 산출되기 때문입니다.

   *first_line*이 "None"이 아니면, 역 어셈블 된 코드에서 첫 번째 소스
   줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스
   줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.

   *current_offset*이 "None"이 아니면, 역 어셈블 된 코드의 명령어 오프
   셋을 나타냅니다. 이를 설정하면, "dis()"가 지정된 옵코드(opcode)에
   대해 "현재 명령어" 마커를 표시합니다.

   classmethod from_traceback(tb)

      주어진 트레이스백에서 "Bytecode" 인스턴스를 구성하고,
      *current_offset*을 예외를 일으킨 명령어로 설정합니다.

   codeobj

      컴파일된 코드 객체.

   first_line

      코드 객체의 첫 번째 소스 줄 (사용 가능하다면)

   dis()

      바이트 코드 연산의 포맷된 보기를 반환합니다 ("dis.dis()"가 인쇄
      하는 것과 같지만, 여러 줄 문자열로 반환됩니다).

   info()

      "code_info()"처럼, 코드 객체에 대한 자세한 정보가 포함된 포맷된
      여러 줄 문자열을 반환합니다.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

Example:

   >>> bytecode = dis.Bytecode(myfunc)
   >>> for instr in bytecode:
   ...     print(instr.opname)
   ...
   LOAD_GLOBAL
   LOAD_FAST
   CALL_FUNCTION
   RETURN_VALUE


분석 함수
=========

"dis" 모듈은 또한 입력을 원하는 출력으로 직접 변환하는 다음 분석 함수
를 정의합니다. 단일 작업만 수행해서, 중간 분석 객체가 유용하지 않을 때
유용할 수 있습니다:

dis.code_info(x)

   제공된 함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코
   드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보가 포함된 포맷
   된 여러 줄 문자열을 반환합니다.

   코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 파이썬 VM이나
   파이썬 릴리스에 걸쳐 임의로 변경될 수 있습니다.

   버전 3.2에 추가.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

dis.show_code(x, *, file=None)

   제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한
   코드 객체 정보를 *file*(또는 *file*이 지정되지 않으면 "sys.stdout")
   로 인쇄합니다.

   이것은 "print(code_info(x), file=file)"의 편리한 축약 형으로, 인터
   프리터 프롬프트에서의 대화식 탐색을 위한 것입니다.

   버전 3.2에 추가.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

dis.dis(x=None, *, file=None, depth=None)

   Disassemble the *x* object.  *x* can denote either a module, a
   class, a method, a function, a generator, an asynchronous
   generator, a coroutine, a code object, a string of source code or a
   byte sequence of raw bytecode. For a module, it disassembles all
   functions. For a class, it disassembles all methods (including
   class and static methods). For a code object or sequence of raw
   bytecode, it prints one line per bytecode instruction. It also
   recursively disassembles nested code objects (the code of
   comprehensions, generator expressions and nested functions, and the
   code used for building nested classes). Strings are first compiled
   to code objects with the "compile()" built-in function before being
   disassembled.  If no object is provided, this function disassembles
   the last traceback.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   재귀의 최대 깊이는 "None"이 아닌 한 *depth*에 의해 제한됩니다.
   "depth=0"은 재귀가 없음을 의미합니다.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

   버전 3.7에서 변경: 재귀 역 어셈블을 구현하고 *depth* 매개 변수를 추
   가했습니다.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

dis.distb(tb=None, *, file=None)

   트레이스백의 최상단 함수를 역 어셈블 합니다. 전달되지 않으면 마지막
   트레이스백을 사용합니다. 예외를 일으키는 명령어가 표시됩니다.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

dis.disassemble(code, lasti=- 1, *, file=None)
dis.disco(code, lasti=- 1, *, file=None)

   코드 객체를 역 어셈블 하고, *lasti*가 제공되면 마지막 명령어를 표시
   합니다. 출력은 다음 열로 나뉩니다:

   1. 줄 번호, 각 줄의 첫 번째 명령어에 표시됩니다

   2. 현재 명령어, "-->"로 표시됩니다,

   3. 레이블이 있는 명령어, ">>"로 표시됩니다,

   4. 명령어의 주소,

   5. 연산 코드 이름,

   6. 연산 매개 변수, 그리고

   7. 괄호 안에 있는 매개 변수의 해석.

   매개 변수 해석은 지역과 전역 변수 이름, 상숫값, 분기 대상 및 비교
   연산자를 인식합니다.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

dis.get_instructions(x, *, first_line=None)

   제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체의 명령어들에
   대한 이터레이터를 반환합니다.

   이터레이터는 제공된 코드의 각 연산에 대한 세부 정보를 제공하는
   "Instruction" 네임드 튜플의 연속을 생성합니다.

   *first_line*이 "None"이 아니면, 역 어셈블 된 코드에서 첫 번째 소스
   줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스
   줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.

   버전 3.4에 추가.

dis.findlinestarts(code)

   This generator function uses the "co_lines" method of the code
   object *code* to find the offsets which are starts of lines in the
   source code.  They are generated as "(offset, lineno)" pairs.

   버전 3.6에서 변경: 줄 번호가 줄어들 수 있습니다. 전에는, 언제나 증
   가했습니다.

   버전 3.10에서 변경: The **PEP 626** "co_lines" method is used
   instead of the "co_firstlineno" and "co_lnotab" attributes of the
   code object.

dis.findlabels(code)

   원시 컴파일된 바이트 코드 문자열 *code*에서 점프 대상인 모든 오프셋
   을 감지하고, 이러한 오프셋의 리스트를 반환합니다.

dis.stack_effect(opcode, oparg=None, *, jump=None)

   인자 *oparg*를 갖는 *opcode*의 스택 효과를 계산합니다.

   코드에 점프 대상이 있고 *jump*가 "True"이면, "stack_effect()"는 점
   프의 스택 효과를 반환합니다. *jump*가 "False"이면, 점프하지 않는 스
   택 효과를 반환합니다. *jump*가 "None"(기본값)이면, 두 경우의 최대
   스택 효과를 반환합니다.

   버전 3.4에 추가.

   버전 3.8에서 변경: *jump* 매개 변수를 추가했습니다.


파이썬 바이트 코드 명령어
=========================

"get_instructions()" 함수와 "Bytecode" 클래스는 바이트 코드 명령어의
세부 사항을 "Instruction" 인스턴스로 제공합니다:

class dis.Instruction

   바이트 코드 연산에 대한 세부 사항

   opcode

      연산의 숫자 코드, 아래 나열된 옵코드 값과 옵코드 모음에 있는 바
      이트 코드 값에 해당합니다.

   opname

      연산의 사람이 읽을 수 있는 이름

   arg

      연산에 대한 숫자 인자 (있다면), 그렇지 않으면 "None"

   argval

      resolved arg value (if known), otherwise same as arg

   argrepr

      human readable description of operation argument

   offset

      바이트 코드 시퀀스 내에서 연산의 시작 인덱스

   starts_line

      line started by this opcode (if any), otherwise "None"

   is_jump_target

      다른 코드가 여기로 점프하면 "True", 그렇지 않으면 "False"

   버전 3.4에 추가.

파이썬 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다.

**일반 명령어**

NOP

   Do nothing code.  Used as a placeholder by the bytecode optimizer.

POP_TOP

   Removes the top-of-stack (TOS) item.

ROT_TWO

   Swaps the two top-most stack items.

ROT_THREE

   Lifts second and third stack item one position up, moves top down
   to position three.

ROT_FOUR

   Lifts second, third and fourth stack items one position up, moves
   top down to position four.

   버전 3.8에 추가.

DUP_TOP

   Duplicates the reference on top of the stack.

   버전 3.2에 추가.

DUP_TOP_TWO

   Duplicates the two references on top of the stack, leaving them in
   the same order.

   버전 3.2에 추가.

**단항 연산**

단항 연산은 스택의 최상단을 취하고, 연산을 적용한 다음, 결과를 스택에
다시 푸시합니다.

UNARY_POSITIVE

   Implements "TOS = +TOS".

UNARY_NEGATIVE

   Implements "TOS = -TOS".

UNARY_NOT

   Implements "TOS = not TOS".

UNARY_INVERT

   Implements "TOS = ~TOS".

GET_ITER

   Implements "TOS = iter(TOS)".

GET_YIELD_FROM_ITER

   If "TOS" is a *generator iterator* or *coroutine* object it is left
   as is.  Otherwise, implements "TOS = iter(TOS)".

   버전 3.5에 추가.

**Binary operations**

Binary operations remove the top of the stack (TOS) and the second
top-most stack item (TOS1) from the stack.  They perform the
operation, and put the result back on the stack.

BINARY_POWER

   Implements "TOS = TOS1 ** TOS".

BINARY_MULTIPLY

   Implements "TOS = TOS1 * TOS".

BINARY_MATRIX_MULTIPLY

   Implements "TOS = TOS1 @ TOS".

   버전 3.5에 추가.

BINARY_FLOOR_DIVIDE

   Implements "TOS = TOS1 // TOS".

BINARY_TRUE_DIVIDE

   Implements "TOS = TOS1 / TOS".

BINARY_MODULO

   Implements "TOS = TOS1 % TOS".

BINARY_ADD

   Implements "TOS = TOS1 + TOS".

BINARY_SUBTRACT

   Implements "TOS = TOS1 - TOS".

BINARY_SUBSCR

   Implements "TOS = TOS1[TOS]".

BINARY_LSHIFT

   Implements "TOS = TOS1 << TOS".

BINARY_RSHIFT

   Implements "TOS = TOS1 >> TOS".

BINARY_AND

   Implements "TOS = TOS1 & TOS".

BINARY_XOR

   Implements "TOS = TOS1 ^ TOS".

BINARY_OR

   Implements "TOS = TOS1 | TOS".

**In-place operations**

In-place operations are like binary operations, in that they remove
TOS and TOS1, and push the result back on the stack, but the operation
is done in-place when TOS1 supports it, and the resulting TOS may be
(but does not have to be) the original TOS1.

INPLACE_POWER

   Implements in-place "TOS = TOS1 ** TOS".

INPLACE_MULTIPLY

   Implements in-place "TOS = TOS1 * TOS".

INPLACE_MATRIX_MULTIPLY

   Implements in-place "TOS = TOS1 @ TOS".

   버전 3.5에 추가.

INPLACE_FLOOR_DIVIDE

   Implements in-place "TOS = TOS1 // TOS".

INPLACE_TRUE_DIVIDE

   Implements in-place "TOS = TOS1 / TOS".

INPLACE_MODULO

   Implements in-place "TOS = TOS1 % TOS".

INPLACE_ADD

   Implements in-place "TOS = TOS1 + TOS".

INPLACE_SUBTRACT

   Implements in-place "TOS = TOS1 - TOS".

INPLACE_LSHIFT

   Implements in-place "TOS = TOS1 << TOS".

INPLACE_RSHIFT

   Implements in-place "TOS = TOS1 >> TOS".

INPLACE_AND

   Implements in-place "TOS = TOS1 & TOS".

INPLACE_XOR

   Implements in-place "TOS = TOS1 ^ TOS".

INPLACE_OR

   Implements in-place "TOS = TOS1 | TOS".

STORE_SUBSCR

   Implements "TOS1[TOS] = TOS2".

DELETE_SUBSCR

   Implements "del TOS1[TOS]".

**코루틴 옵코드**

GET_AWAITABLE

   Implements "TOS = get_awaitable(TOS)", where "get_awaitable(o)"
   returns "o" if "o" is a coroutine object or a generator object with
   the CO_ITERABLE_COROUTINE flag, or resolves "o.__await__".

   버전 3.5에 추가.

GET_AITER

   Implements "TOS = TOS.__aiter__()".

   버전 3.5에 추가.

   버전 3.7에서 변경: "__aiter__"로부터 어웨이터블 객체를 반환하는 것
   은 더는 지원되지 않습니다.

GET_ANEXT

   Pushes "get_awaitable(TOS.__anext__())" to the stack.  See
   "GET_AWAITABLE" for details about "get_awaitable".

   버전 3.5에 추가.

END_ASYNC_FOR

   Terminates an "async for" loop.  Handles an exception raised when
   awaiting a next item.  If TOS is "StopAsyncIteration" pop 7 values
   from the stack and restore the exception state using the second
   three of them.  Otherwise re-raise the exception using the three
   values from the stack.  An exception handler block is removed from
   the block stack.

   버전 3.8에 추가.

BEFORE_ASYNC_WITH

   Resolves "__aenter__" and "__aexit__" from the object on top of the
   stack.  Pushes "__aexit__" and result of "__aenter__()" to the
   stack.

   버전 3.5에 추가.

SETUP_ASYNC_WITH

   Creates a new frame object.

   버전 3.5에 추가.

**기타 옵코드**

PRINT_EXPR

   Implements the expression statement for the interactive mode.  TOS
   is removed from the stack and printed.  In non-interactive mode, an
   expression statement is terminated with "POP_TOP".

SET_ADD(i)

   Calls "set.add(TOS1[-i], TOS)".  Used to implement set
   comprehensions.

LIST_APPEND(i)

   Calls "list.append(TOS1[-i], TOS)".  Used to implement list
   comprehensions.

MAP_ADD(i)

   Calls "dict.__setitem__(TOS1[-i], TOS1, TOS)".  Used to implement
   dict comprehensions.

   버전 3.1에 추가.

   버전 3.8에서 변경: Map value is TOS and map key is TOS1. Before,
   those were reversed.

모든 "SET_ADD", "LIST_APPEND" 및 "MAP_ADD" 명령어에 대해, 추가된 값이
나 키/값 쌍이 팝 되지만, 컨테이너 객체는 스택에 남아 있어서 루프의 추
가 이터레이션에 사용할 수 있습니다.

RETURN_VALUE

   Returns with TOS to the caller of the function.

YIELD_VALUE

   Pops TOS and yields it from a *generator*.

YIELD_FROM

   Pops TOS and delegates to it as a subiterator from a *generator*.

   버전 3.3에 추가.

SETUP_ANNOTATIONS

   "locals()"에 "__annotations__"가 정의되어 있는지 확인합니다, 그렇지
   않으면 비어있는 "dict"로 설정됩니다. 이 옵코드는 클래스나 모듈 본문
   에 *변수 어노테이션*이 정적으로 포함될 때만 생성됩니다.

   버전 3.6에 추가.

IMPORT_STAR

   Loads all symbols not starting with "'_'" directly from the module
   TOS to the local namespace. The module is popped after loading all
   names. This opcode implements "from module import *".

POP_BLOCK

   Removes one block from the block stack.  Per frame, there is a
   stack of blocks, denoting "try" statements, and such.

POP_EXCEPT

   Removes one block from the block stack. The popped block must be an
   exception handler block, as implicitly created when entering an
   except handler.  In addition to popping extraneous values from the
   frame stack, the last three popped values are used to restore the
   exception state.

RERAISE

   Re-raises the exception currently on top of the stack. If oparg is
   non-zero, restores "f_lasti" of the current frame to its value when
   the exception was raised.

   버전 3.9에 추가.

WITH_EXCEPT_START

   Calls the function in position 7 on the stack with the top three
   items on the stack as arguments. Used to implement the call
   "context_manager.__exit__(*exc_info())" when an exception has
   occurred in a "with" statement.

   버전 3.9에 추가.

LOAD_ASSERTION_ERROR

   "AssertionError"를 스택으로 푸시합니다. "assert" 문에서 사용됩니다.

   버전 3.9에 추가.

LOAD_BUILD_CLASS

   Pushes "builtins.__build_class__()" onto the stack.  It is later
   called by "CALL_FUNCTION" to construct a class.

SETUP_WITH(delta)

   This opcode performs several operations before a with block starts.
   First, it loads "__exit__()" from the context manager and pushes it
   onto the stack for later use by "WITH_EXCEPT_START".  Then,
   "__enter__()" is called, and a finally block pointing to *delta* is
   pushed.  Finally, the result of calling the "__enter__()" method is
   pushed onto the stack.  The next opcode will either ignore it
   ("POP_TOP"), or store it in (a) variable(s) ("STORE_FAST",
   "STORE_NAME", or "UNPACK_SEQUENCE").

   버전 3.2에 추가.

COPY_DICT_WITHOUT_KEYS

   TOS is a tuple of mapping keys, and TOS1 is the match subject.
   Replace TOS with a "dict" formed from the items of TOS1, but
   without any of the keys in TOS.

   버전 3.10에 추가.

GET_LEN

   Push "len(TOS)" onto the stack.

   버전 3.10에 추가.

MATCH_MAPPING

   If TOS is an instance of "collections.abc.Mapping" (or, more
   technically: if it has the "Py_TPFLAGS_MAPPING" flag set in its
   "tp_flags"), push "True" onto the stack.  Otherwise, push "False".

   버전 3.10에 추가.

MATCH_SEQUENCE

   If TOS is an instance of "collections.abc.Sequence" and is *not* an
   instance of "str"/"bytes"/"bytearray" (or, more technically: if it
   has the "Py_TPFLAGS_SEQUENCE" flag set in its "tp_flags"), push
   "True" onto the stack.  Otherwise, push "False".

   버전 3.10에 추가.

MATCH_KEYS

   TOS is a tuple of mapping keys, and TOS1 is the match subject.  If
   TOS1 contains all of the keys in TOS, push a "tuple" containing the
   corresponding values, followed by "True". Otherwise, push "None",
   followed by "False".

   버전 3.10에 추가.

All of the following opcodes use their arguments.

STORE_NAME(namei)

   Implements "name = TOS". *namei* is the index of *name* in the
   attribute "co_names" of the code object. The compiler tries to use
   "STORE_FAST" or "STORE_GLOBAL" if possible.

DELETE_NAME(namei)

   Implements "del name", where *namei* is the index into "co_names"
   attribute of the code object.

UNPACK_SEQUENCE(count)

   Unpacks TOS into *count* individual values, which are put onto the
   stack right-to-left.

UNPACK_EX(counts)

   Implements assignment with a starred target: Unpacks an iterable in
   TOS into individual values, where the total number of values can be
   smaller than the number of items in the iterable: one of the new
   values will be a list of all leftover items.

   The low byte of *counts* is the number of values before the list
   value, the high byte of *counts* the number of values after it.
   The resulting values are put onto the stack right-to-left.

STORE_ATTR(namei)

   Implements "TOS.name = TOS1", where *namei* is the index of name in
   "co_names".

DELETE_ATTR(namei)

   Implements "del TOS.name", using *namei* as index into "co_names".

STORE_GLOBAL(namei)

   "STORE_NAME"처럼 작동하지만, 이름을 전역으로 저장합니다.

DELETE_GLOBAL(namei)

   "DELETE_NAME"처럼 작동하지만, 전역 이름을 삭제합니다.

LOAD_CONST(consti)

   "co_consts[consti]"를 스택으로 푸시합니다.

LOAD_NAME(namei)

   Pushes the value associated with "co_names[namei]" onto the stack.

BUILD_TUPLE(count)

   Creates a tuple consuming *count* items from the stack, and pushes
   the resulting tuple onto the stack.

BUILD_LIST(count)

   "BUILD_TUPLE"처럼 작동하지만, 리스트를 만듭니다.

BUILD_SET(count)

   "BUILD_TUPLE"처럼 작동하지만, 집합을 만듭니다.

BUILD_MAP(count)

   Pushes a new dictionary object onto the stack.  Pops "2 * count"
   items so that the dictionary holds *count* entries: "{..., TOS3:
   TOS2, TOS1: TOS}".

   버전 3.5에서 변경: 딕셔너리는 *count* 항목을 갖도록 미리 크기가 조
   정된 빈 딕셔너리를 만드는 대신 스택 항목에서 만들어집니다.

BUILD_CONST_KEY_MAP(count)

   The version of "BUILD_MAP" specialized for constant keys. Pops the
   top element on the stack which contains a tuple of keys, then
   starting from "TOS1", pops *count* values to form values in the
   built dictionary.

   버전 3.6에 추가.

BUILD_STRING(count)

   스택에서 *count* 문자열을 이어붙이고 결과 문자열을 스택으로 푸시합
   니다.

   버전 3.6에 추가.

LIST_TO_TUPLE

   Pops a list from the stack and pushes a tuple containing the same
   values.

   버전 3.9에 추가.

LIST_EXTEND(i)

   Calls "list.extend(TOS1[-i], TOS)".  Used to build lists.

   버전 3.9에 추가.

SET_UPDATE(i)

   Calls "set.update(TOS1[-i], TOS)".  Used to build sets.

   버전 3.9에 추가.

DICT_UPDATE(i)

   Calls "dict.update(TOS1[-i], TOS)".  Used to build dicts.

   버전 3.9에 추가.

DICT_MERGE

   "DICT_UPDATE"와 유사하지만, 중복 키에 대해 예외를 발생시킵니다.

   버전 3.9에 추가.

LOAD_ATTR(namei)

   Replaces TOS with "getattr(TOS, co_names[namei])".

COMPARE_OP(opname)

   Performs a Boolean operation.  The operation name can be found in
   "cmp_op[opname]".

IS_OP(invert)

   "is" 비교를 수행하거나, "invert"가 1이면 "is not"을 수행합니다.

   버전 3.9에 추가.

CONTAINS_OP(invert)

   "in" 비교를 수행하거나, "invert"가 1이면 "not in"을 수행합니다.

   버전 3.9에 추가.

IMPORT_NAME(namei)

   Imports the module "co_names[namei]".  TOS and TOS1 are popped and
   provide the *fromlist* and *level* arguments of "__import__()".
   The module object is pushed onto the stack.  The current namespace
   is not affected: for a proper import statement, a subsequent
   "STORE_FAST" instruction modifies the namespace.

IMPORT_FROM(namei)

   Loads the attribute "co_names[namei]" from the module found in TOS.
   The resulting object is pushed onto the stack, to be subsequently
   stored by a "STORE_FAST" instruction.

JUMP_FORWARD(delta)

   바이트 코드 카운터를 *delta*만큼 증가시킵니다.

POP_JUMP_IF_TRUE(target)

   If TOS is true, sets the bytecode counter to *target*.  TOS is
   popped.

   버전 3.1에 추가.

POP_JUMP_IF_FALSE(target)

   If TOS is false, sets the bytecode counter to *target*.  TOS is
   popped.

   버전 3.1에 추가.

JUMP_IF_NOT_EXC_MATCH(target)

   Tests whether the second value on the stack is an exception
   matching TOS, and jumps if it is not. Pops two values from the
   stack.

   버전 3.9에 추가.

JUMP_IF_TRUE_OR_POP(target)

   If TOS is true, sets the bytecode counter to *target* and leaves
   TOS on the stack.  Otherwise (TOS is false), TOS is popped.

   버전 3.1에 추가.

JUMP_IF_FALSE_OR_POP(target)

   If TOS is false, sets the bytecode counter to *target* and leaves
   TOS on the stack.  Otherwise (TOS is true), TOS is popped.

   버전 3.1에 추가.

JUMP_ABSOLUTE(target)

   Set bytecode counter to *target*.

FOR_ITER(delta)

   TOS is an *iterator*.  Call its "__next__()" method.  If this
   yields a new value, push it on the stack (leaving the iterator
   below it).  If the iterator indicates it is exhausted, TOS is
   popped, and the byte code counter is incremented by *delta*.

LOAD_GLOBAL(namei)

   Loads the global named "co_names[namei]" onto the stack.

SETUP_FINALLY(delta)

   Pushes a try block from a try-finally or try-except clause onto the
   block stack.  *delta* points to the finally block or the first
   except block.

LOAD_FAST(var_num)

   지역 "co_varnames[var_num]"에 대한 참조를 스택으로 푸시합니다.

STORE_FAST(var_num)

   Stores TOS into the local "co_varnames[var_num]".

DELETE_FAST(var_num)

   지역 "co_varnames[var_num]"을 삭제합니다.

LOAD_CLOSURE(i)

   Pushes a reference to the cell contained in slot *i* of the cell
   and free variable storage.  The name of the variable is
   "co_cellvars[i]" if *i* is less than the length of *co_cellvars*.
   Otherwise it is "co_freevars[i - len(co_cellvars)]".

LOAD_DEREF(i)

   Loads the cell contained in slot *i* of the cell and free variable
   storage. Pushes a reference to the object the cell contains on the
   stack.

LOAD_CLASSDEREF(i)

   Much like "LOAD_DEREF" but first checks the locals dictionary
   before consulting the cell.  This is used for loading free
   variables in class bodies.

   버전 3.4에 추가.

STORE_DEREF(i)

   Stores TOS into the cell contained in slot *i* of the cell and free
   variable storage.

DELETE_DEREF(i)

   Empties the cell contained in slot *i* of the cell and free
   variable storage. Used by the "del" statement.

   버전 3.2에 추가.

RAISE_VARARGS(argc)

   *argc*의 값에 따라, "raise" 문의 3가지 형식 중 하나를 사용하여 예외
   를 발생시킵니다:

   * 0: "raise" (이전 예외를 다시 발생시킵니다)

   * 1: "raise TOS" (raise exception instance or type at "TOS")

   * 2: "raise TOS1 from TOS" (raise exception instance or type at
     "TOS1" with "__cause__" set to "TOS")

CALL_FUNCTION(argc)

   Calls a callable object with positional arguments. *argc* indicates
   the number of positional arguments. The top of the stack contains
   positional arguments, with the right-most argument on top.  Below
   the arguments is a callable object to call. "CALL_FUNCTION" pops
   all arguments and the callable object off the stack, calls the
   callable object with those arguments, and pushes the return value
   returned by the callable object.

   버전 3.6에서 변경: This opcode is used only for calls with
   positional arguments.

CALL_FUNCTION_KW(argc)

   Calls a callable object with positional (if any) and keyword
   arguments. *argc* indicates the total number of positional and
   keyword arguments. The top element on the stack contains a tuple
   with the names of the keyword arguments, which must be strings.
   Below that are the values for the keyword arguments, in the order
   corresponding to the tuple. Below that are positional arguments,
   with the right-most parameter on top.  Below the arguments is a
   callable object to call. "CALL_FUNCTION_KW" pops all arguments and
   the callable object off the stack, calls the callable object with
   those arguments, and pushes the return value returned by the
   callable object.

   버전 3.6에서 변경: Keyword arguments are packed in a tuple instead
   of a dictionary, *argc* indicates the total number of arguments.

CALL_FUNCTION_EX(flags)

   위치와 키워드 인자의 변수 집합으로 콜러블 객체를 호출합니다.
   *flags*의 최하위 비트가 설정되면, 스택의 맨 위에 추가 키워드 인자가
   포함된 매핑 객체가 포함됩니다. 콜러블이 호출되기 전에, 매핑 객체와
   이터러블 객체는 각각 "언팩" 되고 그 내용이 각각 키워드와 위치 인자
   로 전달됩니다. "CALL_FUNCTION_EX"는 모든 인자와 콜러블 객체를 스택
   에서 팝하고, 해당 인자로 콜러블 객체를 호출한 다음, 콜러블 객체가
   반환한 반환 값을 푸시합니다.

   버전 3.6에 추가.

LOAD_METHOD(namei)

   Loads a method named "co_names[namei]" from the TOS object. TOS is
   popped. This bytecode distinguishes two cases: if TOS has a method
   with the correct name, the bytecode pushes the unbound method and
   TOS. TOS will be used as the first argument ("self") by
   "CALL_METHOD" when calling the unbound method. Otherwise, "NULL"
   and the object return by the attribute lookup are pushed.

   버전 3.7에 추가.

CALL_METHOD(argc)

   Calls a method.  *argc* is the number of positional arguments.
   Keyword arguments are not supported.  This opcode is designed to be
   used with "LOAD_METHOD".  Positional arguments are on top of the
   stack. Below them, the two items described in "LOAD_METHOD" are on
   the stack (either "self" and an unbound method object or "NULL" and
   an arbitrary callable). All of them are popped and the return value
   is pushed.

   버전 3.7에 추가.

MAKE_FUNCTION(flags)

   Pushes a new function object on the stack.  From bottom to top, the
   consumed stack must consist of values if the argument carries a
   specified flag value

   * "0x01" 위치 전용과 위치-키워드 매개 변수를 위한 기본값의 위치 순
     서 튜플

   * "0x02" 키워드 전용 매개 변수의 기본값 딕셔너리

   * "0x04" a tuple of strings containing parameters' annotations

   * "0x08" 자유 변수를 위한 셀을 포함하는 튜플, 클로저를 만듭니다

   * the code associated with the function (at TOS1)

   * the *qualified name* of the function (at TOS)

   버전 3.10에서 변경: Flag value "0x04" is a tuple of strings instead
   of dictionary

BUILD_SLICE(argc)

   Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it
   is 2, "slice(TOS1, TOS)" is pushed; if it is 3, "slice(TOS2, TOS1,
   TOS)" is pushed. See the "slice()" built-in function for more
   information.

EXTENDED_ARG(ext)

   너무 커서 기본 1바이트에 맞지 않는 인자를 가진 옵코드에 접두어로 붙
   입니다. *ext*는 인자에서 더 높은 비트로 작동하는 추가 바이트를 보유
   합니다. 각 옵코드마다, 최대 3개의 접두사 "EXTENDED_ARG"가 허용되며,
   2바이트에서 4바이트 사이의 인자를 형성합니다.

FORMAT_VALUE(flags)

   Used for implementing formatted literal strings (f-strings).  Pops
   an optional *fmt_spec* from the stack, then a required *value*.
   *flags* is interpreted as follows:

   * "(flags & 0x03) == 0x00": *value* is formatted as-is.

   * "(flags & 0x03) == 0x01": call "str()" on *value* before
     formatting it.

   * "(flags & 0x03) == 0x02": call "repr()" on *value* before
     formatting it.

   * "(flags & 0x03) == 0x03": call "ascii()" on *value* before
     formatting it.

   * "(flags & 0x04) == 0x04": pop *fmt_spec* from the stack and use
     it, else use an empty *fmt_spec*.

   Formatting is performed using "PyObject_Format()".  The result is
   pushed on the stack.

   버전 3.6에 추가.

MATCH_CLASS(count)

   TOS is a tuple of keyword attribute names, TOS1 is the class being
   matched against, and TOS2 is the match subject.  *count* is the
   number of positional sub-patterns.

   Pop TOS.  If TOS2 is an instance of TOS1 and has the positional and
   keyword attributes required by *count* and TOS, set TOS to "True"
   and TOS1 to a tuple of extracted attributes.  Otherwise, set TOS to
   "False".

   버전 3.10에 추가.

GEN_START(kind)

      Pops TOS. The "kind" operand corresponds to the type of
      generator or coroutine. The legal kinds are 0 for generator, 1
      for coroutine, and 2 for async generator.

   버전 3.10에 추가.

ROT_N(count)

   Lift the top *count* stack items one position up, and move TOS down
   to position *count*.

   버전 3.10에 추가.

HAVE_ARGUMENT

   This is not really an opcode.  It identifies the dividing line
   between opcodes which don't use their argument and those that do
   ("< HAVE_ARGUMENT" and ">= HAVE_ARGUMENT", respectively).

   버전 3.6에서 변경: 이제 모든 명령어에는 인자가 있지만, "<
   HAVE_ARGUMENT"인 옵코드는 이를 무시합니다. 이전에는, ">=
   HAVE_ARGUMENT"인 옵코드에만 인자가 있었습니다.


옵코드 모음
===========

이 모음은 바이트 코드 명령어의 자동 검사를 위해 제공됩니다:

dis.opname

   연산 이름의 시퀀스, 바이트 코드를 사용하여 인덱싱할 수 있습니다.

dis.opmap

   연산 이름을 바이트 코드로 매핑하는 딕셔너리.

dis.cmp_op

   모든 비교 연산 이름의 시퀀스.

dis.hasconst

   상수에 액세스하는 바이트 코드의 시퀀스.

dis.hasfree

   Sequence of bytecodes that access a free variable (note that 'free'
   in this context refers to names in the current scope that are
   referenced by inner scopes or names in outer scopes that are
   referenced from this scope.  It does *not* include references to
   global or builtin scopes).

dis.hasname

   어트리뷰트를 이름으로 액세스하는 바이트 코드의 시퀀스.

dis.hasjrel

   상대 점프 대상이 있는 바이트 코드의 시퀀스.

dis.hasjabs

   절대 점프 대상이 있는 바이트 코드의 시퀀스.

dis.haslocal

   지역 변수에 액세스하는 바이트 코드의 시퀀스.

dis.hascompare

   불리언 연산의 바이트 코드의 시퀀스.
