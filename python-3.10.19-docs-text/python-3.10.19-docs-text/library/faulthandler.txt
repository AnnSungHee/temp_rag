"faulthandler" --- Dump the Python traceback
********************************************

버전 3.3에 추가.

======================================================================

This module contains functions to dump Python tracebacks explicitly,
on a fault, after a timeout, or on a user signal. Call
"faulthandler.enable()" to install fault handlers for the "SIGSEGV",
"SIGFPE", "SIGABRT", "SIGBUS", and "SIGILL" signals. You can also
enable them at startup by setting the "PYTHONFAULTHANDLER" environment
variable or by using the "-X" "faulthandler" command line option.

The fault handler is compatible with system fault handlers like Apport
or the Windows fault handler. The module uses an alternative stack for
signal handlers if the "sigaltstack()" function is available. This
allows it to dump the traceback even on a stack overflow.

결함 처리기는 치명적일 때 호출되므로 시그널 안전한 함수만 사용할 수 있
습니다 (예를 들어, 힙에 메모리를 할당할 수 없습니다). 이 제한 때문에
일반적인 파이썬 트레이스백에 비해 트레이스백 덤프는 최소화됩니다:

* ASCII만 지원됩니다. 인코딩 시 "backslashreplace" 에러 처리기가 사용
  됩니다.

* 각 문자열은 500자로 제한됩니다.

* 파일명, 함수 이름 및 줄 번호만 표시됩니다. (소스 코드 없음)

* 100프레임과 100스레드로 제한됩니다.

* 순서가 뒤집힙니다: 가장 최근의 호출이 먼저 표시됩니다.

기본적으로, 파이썬 트레이스백은 "sys.stderr"에 기록됩니다. 트레이스백
을 보려면, 응용 프로그램이 터미널에서 실행되어야 합니다. 로그 파일을
"faulthandler.enable()"로 전달할 수도 있습니다.

모듈은 C로 구현되어 있으므로, 충돌 시나 파이썬이 교착 상태에 빠질 때
트레이스백을 덤프할 수 있습니다.

파이썬 개발 모드는 파이썬 시작 시 "faulthandler.enable()"을 호출합니다
.

더 보기:

  Module "pdb"
     Interactive source code debugger for Python programs.

  Module "traceback"
     Standard interface to extract, format and print stack traces of
     Python programs.


트레이스백 덤프하기
===================

faulthandler.dump_traceback(file=sys.stderr, all_threads=True)

   모든 스레드의 트레이스백을 *file*로 덤프합니다. *all_threads*가
   "False"면, 현재 스레드만 덤프합니다.

   더 보기:

     "traceback.print_tb()", which can be used to print a traceback
     object.

   버전 3.5에서 변경: 이 함수에 파일 기술자를 전달하는 지원이 추가되었
   습니다.


결함 처리기 상태
================

faulthandler.enable(file=sys.stderr, all_threads=True)

   Enable the fault handler: install handlers for the "SIGSEGV",
   "SIGFPE", "SIGABRT", "SIGBUS" and "SIGILL" signals to dump the
   Python traceback. If *all_threads* is "True", produce tracebacks
   for every running thread. Otherwise, dump only the current thread.

   *file*은 결함 처리기가 비활성화될 때까지 열려 있어야 합니다: 파일
   기술자 관련 문제를 참조하십시오.

   버전 3.5에서 변경: 이 함수에 파일 기술자를 전달하는 지원이 추가되었
   습니다.

   버전 3.6에서 변경: 윈도우에서는, 윈도우 예외(Windows exception) 처
   리기도 설치됩니다.

   버전 3.10에서 변경: The dump now mentions if a garbage collector
   collection is running if *all_threads* is true.

faulthandler.disable()

   결함 처리기를 비활성화합니다: "enable()"로 설치된 시그널 처리기를
   제거합니다.

faulthandler.is_enabled()

   결함 처리기가 활성화되었는지 검사합니다.


시간 초과 후에 트레이스백 덤프하기
==================================

faulthandler.dump_traceback_later(timeout, repeat=False, file=sys.stderr, exit=False)

   Dump the tracebacks of all threads, after a timeout of *timeout*
   seconds, or every *timeout* seconds if *repeat* is "True".  If
   *exit* is "True", call "_exit()" with status=1 after dumping the
   tracebacks.  (Note "_exit()" exits the process immediately, which
   means it doesn't do any cleanup like flushing file buffers.) If the
   function is called twice, the new call replaces previous parameters
   and resets the timeout. The timer has a sub-second resolution.

   *file*은 트레이스백이 덤프 되거나 "cancel_dump_traceback_later()"가
   호출될 때까지 열려 있어야 합니다: 파일 기술자 관련 문제를 참조하십
   시오.

   이 함수는 워치독(watchdog) 스레드를 사용하여 구현됩니다.

   버전 3.7에서 변경: 이 함수는 이제 항상 사용할 수 있습니다.

   버전 3.5에서 변경: 이 함수에 파일 기술자를 전달하는 지원이 추가되었
   습니다.

faulthandler.cancel_dump_traceback_later()

   마지막 "dump_traceback_later()" 호출을 취소합니다.


사용자 시그널에 트레이스백 덤프하기
===================================

faulthandler.register(signum, file=sys.stderr, all_threads=True, chain=False)

   사용자 시그널을 등록합니다: *signum* 시그널에 대한 처리기를 설치해
   서, 모든 스레드, 또는 *all_threads*가 "False"면 현재 스레드의, 트레
   이스백을 *file*로 덤프합니다. chain이 "True"면 이전 처리기를 호출합
   니다.

   *file*은 시그널이 "unregister()"로 등록 해지 될 때까지 열려 있어야
   합니다: 파일 기술자 관련 문제를 참조하십시오.

   윈도우에서는 사용할 수 없습니다.

   버전 3.5에서 변경: 이 함수에 파일 기술자를 전달하는 지원이 추가되었
   습니다.

faulthandler.unregister(signum)

   사용자 시그널을 등록 해지합니다: "register()"로 설치된 *signum* 시
   그널 처리기를 제거합니다. 시그널이 등록되었으면 "True"를 반환하고,
   그렇지 않으면 "False"를 반환합니다.

   윈도우에서는 사용할 수 없습니다.


파일 기술자 관련 문제
=====================

"enable()", "dump_traceback_later()" 및 "register()"는 *file* 인자의
파일 기술자를 유지합니다. 파일이 닫히고 파일 기술자가 새 파일에 의해
다시 사용되거나, "os.dup2()"가 파일 기술자를 바꾸는 데 사용되면, 트레
이스백이 다른 파일에 기록됩니다. 파일을 바꿀 때마다 이 함수들을 다시
호출하십시오.


예제
====

리눅스에서 결함 처리기를 활성화하거나 그렇지 않았을 때의 세그멘테이션
결함 예제:

   $ python3 -c "import ctypes; ctypes.string_at(0)"
   Segmentation fault

   $ python3 -q -X faulthandler
   >>> import ctypes
   >>> ctypes.string_at(0)
   Fatal Python error: Segmentation fault

   Current thread 0x00007fb899f39700 (most recent call first):
     File "/home/python/cpython/Lib/ctypes/__init__.py", line 486 in string_at
     File "<stdin>", line 1 in <module>
   Segmentation fault
