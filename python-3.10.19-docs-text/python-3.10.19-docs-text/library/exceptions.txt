내장 예외
*********

파이썬에서, 모든 예외는 "BaseException" 에서 파생된 클래스의 인스턴스
여야 합니다. 특정 클래스를 언급하는 "except" 절을 갖는 "try" 문에서,
그 절은 그 클래스에서 파생된 모든 예외 클래스를 처리합니다 (하지만 *그
것* 이 계승하는 예외 클래스는 처리하지 않습니다). 서브 클래싱을 통해
관련되지 않은 두 개의 예외 클래스는 같은 이름을 갖는다 할지라도 결코
등등하게 취급되지 않습니다.

The built-in exceptions listed below can be generated by the
interpreter or built-in functions.  Except where mentioned, they have
an "associated value" indicating the detailed cause of the error.
This may be a string or a tuple of several items of information (e.g.,
an error code and a string explaining the code).  The associated value
is usually passed as arguments to the exception class's constructor.

사용자 코드는 내장 예외를 일으킬 수 있습니다. 이것은 예외 처리기를 검
사하거나 인터프리터가 같은 예외를 발생시키는 상황과 "같은" 에러 조건을
보고하는 데 사용할 수 있습니다. 그러나 사용자 코드가 부적절한 에러를
발생시키는 것을 막을 방법이 없음을 유의하십시오.

내장 예외 클래스는 새 예외를 정의하기 위해 서브 클래싱 될 수 있습니다.
"BaseException" 이 아니라 "Exception" 클래스 나 그 서브 클래스 중 하나
에서 새로운 예외를 파생시킬 것을 권장합니다. 예외 정의에 대한 더 많은
정보는 파이썬 자습서의 사용자 정의 예외 에 있습니다.


예외 컨텍스트
=============

When raising a new exception while another exception is already being
handled, the new exception's "__context__" attribute is automatically
set to the handled exception.  An exception may be handled when an
"except" or "finally" clause, or a "with" statement, is used.

이 묵시적인 예외 컨텍스트는 암시적인 예외 상황은 명시적 원인으로 보충
될 수 있는데, "raise"와 "from"을 사용합니다:

   raise new_exc from original_exc

The expression following "from" must be an exception or "None". It
will be set as "__cause__" on the raised exception. Setting
"__cause__" also implicitly sets the "__suppress_context__" attribute
to "True", so that using "raise new_exc from None" effectively
replaces the old exception with the new one for display purposes (e.g.
converting "KeyError" to "AttributeError"), while leaving the old
exception available in "__context__" for introspection when debugging.

The default traceback display code shows these chained exceptions in
addition to the traceback for the exception itself. An explicitly
chained exception in "__cause__" is always shown when present. An
implicitly chained exception in "__context__" is shown only if
"__cause__" is "None" and "__suppress_context__" is false.

두 경우 모두, 예외 자신은 항상 연결된 예외 뒤에 표시되어서, 트레이스백
의 마지막 줄은 항상 마지막에 발생한 예외를 보여줍니다.


내장 예외를 상속받기
====================

User code can create subclasses that inherit from an exception type.
It's recommended to only subclass one exception type at a time to
avoid any possible conflicts between how the bases handle the "args"
attribute, as well as due to possible memory layout incompatibilities.

**CPython 구현 상세:** Most built-in exceptions are implemented in C
for efficiency, see: Objects/exceptions.c.  Some have custom memory
layouts which makes it impossible to create a subclass that inherits
from multiple exception types. The memory layout of a type is an
implementation detail and might change between Python versions,
leading to new conflicts in the future.  Therefore, it's recommended
to avoid subclassing multiple exception types altogether.


베이스 클래스
=============

다음 예외는 주로 다른 예외의 베이스 클래스로 사용됩니다.

exception BaseException

   모든 내장 예외의 베이스 클래스입니다. 사용자 정의 클래스에 의해 직
   접 상속되는 것이 아닙니다 (그런 목적으로는 "Exception"을 사용하세요
   ). 이 클래스의 인스턴스에 대해 "str()" 이 호출되면, 인스턴스로 전달
   된 인자(들)의 표현을 돌려줍니다. 인자가 없는 경우는 빈 문자열을 돌
   려줍니다.

   args

      예외 생성자에 주어진 인자들의 튜플. 일부 내장 예외(예,
      "OSError")는 특정 수의 인자를 기대하고 이 튜플의 요소에 특별한
      의미를 할당하는 반면, 다른 것들은 보통 오류 메시지를 제공하는 단
      일 문자열로만 호출됩니다.

   with_traceback(tb)

      This method sets *tb* as the new traceback for the exception and
      returns the exception object.  It was more commonly used before
      the exception chaining features of **PEP 3134** became
      available.  The following example shows how we can convert an
      instance of "SomeException" into an instance of "OtherException"
      while preserving the traceback.  Once raised, the current frame
      is pushed onto the traceback of the "OtherException", as would
      have happened to the traceback of the original "SomeException"
      had we allowed it to propagate to the caller.

         try:
             ...
         except SomeException:
             tb = sys.exc_info()[2]
             raise OtherException(...).with_traceback(tb)

exception Exception

   모든 시스템 종료 외의 내장 예외는 이 클래스 파생됩니다. 모든 사용자
   정의 예외도 이 클래스에서 파생되어야 합니다.

exception ArithmeticError

   다양한 산술 에러가 일으키는 내장 예외들의 베이스 클래스:
   "OverflowError", "ZeroDivisionError", "FloatingPointError".

exception BufferError

   버퍼 관련 연산을 수행할 수 없을 때 발생합니다.

exception LookupError

   매핑 또는 시퀀스에 사용된 키 나 인덱스가 잘못되었을 때 발생하는 예
   외의 베이스 클래스: "IndexError", "KeyError". "codecs.lookup()" 은
   이 예외를 직접 일으킬 수 있습니다.


구체적인 예외
=============

다음 예외는 일반적으로 직접 일으키는데 사용하는 예외입니다.

exception AssertionError

   "assert" 문이 실패할 때 발생합니다.

exception AttributeError

   어트리뷰트 참조(어트리뷰트 참조를 보세요)나 대입이 실패할 때 발생합
   니다. (객체가 어트리뷰트 참조나 어트리뷰트 대입을 아예 지원하지 않
   으면 "TypeError" 가 발생합니다.)

   "name"과 "obj" 어트리뷰트는 생성자에 키워드 전용 인자를 사용하여 설
   정할 수 있습니다. 설정된 경우, 각각 액세스가 시도된 어트리뷰트의 이
   름과 그 어트리뷰트가 액세스된 객체를 나타냅니다.

   버전 3.10에서 변경: "name"과 "obj" 어트리뷰트를 추가했습니다.

exception EOFError

   "input()" 함수가 데이터를 읽지 못한 상태에서 EOF (end-of-file) 조건
   을 만날 때 발생합니다. (주의하세요: "io.IOBase.read()" 와
   "io.IOBase.readline()" 메서드는 EOF를 만날 때 빈 문자열을 돌려줍니
   다.)

exception FloatingPointError

   현재 사용되지 않습니다.

exception GeneratorExit

   *제너레이터* 또는 *코루틴* 이 닫힐 때 발생합니다;
   "generator.close()" 와 "coroutine.close()" 를 보십시오. 기술적으로
   에러가 아니므로 "Exception" 대신에 "BaseException" 을 직접 계승합니
   다.

exception ImportError

   "import" 문이 모듈을 로드하는 데 문제가 있을 때 발생합니다. 또한
   "from ... import" 에서 임포트 하려는 이름을 찾을 수 없을 때도 발생
   합니다.

   The "name" and "path" attributes can be set using keyword-only
   arguments to the constructor. When set they represent the name of
   the module that was attempted to be imported and the path to any
   file which triggered the exception, respectively.

   버전 3.3에서 변경: "name"과 "path" 어트리뷰트를 추가했습니다.

exception ModuleNotFoundError

   "ImportError" 의 서브 클래스인데, 모듈을 찾을 수 없을 때 "import"
   가 일으킵니다. "sys.modules" 에서 "None" 이 발견될 때도 발생합니다.

   버전 3.6에 추가.

exception IndexError

   시퀀스 인덱스가 범위를 벗어날 때 발생합니다. (슬라이스 인덱스는 허
   용된 범위 내에 들어가도록 자동으로 잘립니다; 인덱스가 정수가 아니면
   "TypeError" 가 발생합니다.)

exception KeyError

   매핑 (딕셔너리) 키가 기존 키 집합에서 발견되지 않을 때 발생합니다.

exception KeyboardInterrupt

   사용자가 인터럽트 키(일반적으로 "Control-C" 또는 "Delete")를 누를
   때 발생합니다. 실행 중에 인터럽트 검사가 정기적으로 수행됩니다.
   "Exception"을 잡는 코드에 의해 우연히 잡혀서, 인터프리터가 종료하는
   것을 막지 못하도록 "BaseException" 를 계승합니다.

   참고:

     Catching a "KeyboardInterrupt" requires special consideration.
     Because it can be raised at unpredictable points, it may, in some
     circumstances, leave the running program in an inconsistent
     state. It is generally best to allow "KeyboardInterrupt" to end
     the program as quickly as possible or avoid raising it entirely.
     (See 신호 처리기와 예외에 대한 참고 사항.)

exception MemoryError

   작업에 메모리가 부족하지만, 상황이 여전히 (일부 객체를 삭제해서) 복
   구될 수 있는 경우 발생합니다. 연관된 값은 어떤 종류의 (내부) 연산이
   메모리를 다 써 버렸는지를 나타내는 문자열입니다. 하부 메모리 관리
   아키텍처(C의 "malloc()" 함수)때문에, 인터프리터가 항상 이 상황을 완
   벽하게 복구할 수 있는 것은 아닙니다; 그런데도 통제를 벗어난 프로그
   램이 원인인 경우를 위해, 스택 트레이스백을 인쇄할 수 있도록 예외를
   일으킵니다.

exception NameError

   지역 또는 전역 이름을 찾을 수 없을 때 발생합니다. 이는 정규화되지
   않은 이름에만 적용됩니다. 연관된 값은 찾을 수 없는 이름을 포함하는
   에러 메시지입니다.

   "name" 어트리뷰트는 생성자에 키워드 전용 인자를 사용하여 설정할 수
   있습니다. 설정된 경우, 액세스하려고 시도한 변수의 이름을 나타냅니다
   .

   버전 3.10에서 변경: "name" 어트리뷰트를 추가했습니다.

exception NotImplementedError

   이 예외는 "RuntimeError" 에서 파생됩니다. 사용자 정의 베이스 클래스
   에서, 파생 클래스가 재정의하도록 요구하는 추상 메서드나, 클래스가
   개발되는 도중에 실제 구현이 추가될 필요가 있음을 나타낼 때 이 예외
   를 발생시켜야 합니다.

   참고:

     연산자 나 메서드가 아예 지원되지 않는다는 것을 나타내는 데 사용해
     서는 안 됩니다 -- 그 경우는 연산자 / 메서드를 정의하지 않거나, 서
     브 클래스면 "None" 으로 설정하십시오.

   참고:

     "NotImplementedError" and "NotImplemented" are not
     interchangeable, even though they have similar names and
     purposes.  See "NotImplemented" for details on when to use it.

exception OSError([arg])
exception OSError(errno, strerror[, filename[, winerror[, filename2]]])

   이 예외는 시스템 함수가 시스템 관련 에러를 돌려줄 때 발생하는데, "
   파일을 찾을 수 없습니다(file not found)" 나 "디스크가 꽉 찼습니다
   (disk full)" 와 같은 (잘못된 인자형이나 다른 부수적인 에러가 아닌)
   입출력 실패를 포함합니다.

   생성자의 두 번째 형식은 아래에 설명된 해당 어트리뷰트를 설정합니다.
   어트리뷰트를 지정하지 않으면 기본적으로 "None" 이 됩니다. 이전 버전
   과의 호환성을 위해, 세 개의 인자가 전달되면, "args" 어트리뷰트는 처
   음 두 생성자 인자의 2-튜플만 포함합니다.

   아래의 OS 예외 에서 설명하는 것처럼, 생성자는 종종 "OSError" 의 서
   브 클래스를 돌려줍니다. 구체적인 서브 클래스는 최종 "errno" 값에 따
   라 다릅니다. 이 동작은 "OSError" 를 직접 혹은 별칭을 통해 생성할 때
   만 일어나고, 서브 클래싱할 때는 상속되지 않습니다.

   errno

      C 변수 "errno" 로부터 온 숫자 에러 코드.

   winerror

      윈도우에서, 네이티브 윈도우 에러 코드를 제공합니다. "errno" 어트
      리뷰트는 이 네이티브 에러 코드를 POSIX 코드로 대략 변환한 것입니
      다.

      윈도우에서, *winerror* 생성자 인자가 정수인 경우, "errno" 어트리
      뷰트는 윈도우 에러 코드에서 결정되며 *errno* 인자는 무시됩니다.
      다른 플랫폼에서는 *winerror* 인자가 무시되고 "winerror" 어트리뷰
      트가 없습니다.

   strerror

      운영 체제에서 제공하는 해당 에러 메시지. POSIX에서는 C 함수
      "perror()" 로, 윈도우에서는 "FormatMessage()" 로 포맷합니다.

   filename
   filename2

      ("open()" 또는 "os.unlink()" 와 같은) 파일 시스템 경로와 관련된
      예외의 경우, "filename" 은 함수에 전달 된 파일 이름입니다.
      ("os.rename()"처럼) 두 개의 파일 시스템 경로를 수반하는 함수의
      경우, "filename2" 는 두 번째 파일 이름에 해당합니다.

   버전 3.3에서 변경: "EnvironmentError", "IOError", "WindowsError",
   "socket.error", "select.error", "mmap.error" 가 "OSError" 로 병합되
   었고, 생성자는 서브 클래스를 반환할 수 있습니다.

   버전 3.4에서 변경: "filename" 속성은 이제 *파일 시스템 인코딩과 에
   러 처리기*로 인코딩되거나 디코딩된 이름 대신 함수에 전달 된 원래 파
   일 이름입니다. 또한 *filename2* 생성자 인자 및 어트리뷰트가 추가되
   었습니다.

exception OverflowError

   Raised when the result of an arithmetic operation is too large to
   be represented.  This cannot occur for integers (which would rather
   raise "MemoryError" than give up).  However, for historical
   reasons, OverflowError is sometimes raised for integers that are
   outside a required range.   Because of the lack of standardization
   of floating point exception handling in C, most floating point
   operations are not checked.

exception RecursionError

   이 예외는 "RuntimeError" 에서 파생됩니다. 인터프리터가 최대 재귀 깊
   이("sys.getrecursionlimit()" 참조)가 초과하였음을 감지할 때 발생합
   니다.

   버전 3.5에 추가: 이전에는 평범한 "RuntimeError" 가 발생했습니다.

exception ReferenceError

   이 예외는 "weakref.proxy()" 함수가 만든 약한 참조 프락시가 이미 가
   비지 수집된 참조 대상의 어트리뷰트를 액세스하는 데 사용될 때 발생합
   니다. 약한 참조에 대한 더 자세한 정보는 "weakref" 모듈을 보십시오.

exception RuntimeError

   다른 범주에 속하지 않는 에러가 감지될 때 발생합니다. 연관된 값은 정
   확히 무엇이 잘못되었는지를 나타내는 문자열입니다.

exception StopIteration

   이터레이터에 의해 생성된 항목이 더 없다는 것을 알려주기 위해, 내장
   함수 "next()"와 *이터레이터*의 "__next__()" 메서드가 일으킵니다.

   The exception object has a single attribute "value", which is given
   as an argument when constructing the exception, and defaults to
   "None".

   *제너레이터* 나 *코루틴* 함수가 복귀할 때, 새 "StopIteration" 인스
   턴스를 발생시키고, 함수가 돌려주는 값을 예외 생성자의 "value" 매개
   변수로 사용합니다.

   제너레이터 코드가 직간접적으로 "StopIteration" 를 일으키면,
   "RuntimeError" 로 변환됩니다 ("StopIteration" 은 새 예외의 원인
   ("__cause__")으로 남겨둡니다).

   버전 3.3에서 변경: "value" 어트리뷰트와 제너레이터 함수가 이 값을
   돌려주는 기능을 추가했습니다.

   버전 3.5에서 변경: "from __future__ import generator_stop" 를 통한
   RuntimeError 변환을 도입했습니다. **PEP 479**를 참조하세요.

   버전 3.7에서 변경: 기본적으로 모든 코드에서 **PEP 479**를 활성화합
   니다: 제너레이터에서 발생한 "StopIteration" 에러는 "RuntimeError"
   로 변환됩니다.

exception StopAsyncIteration

   Must be raised by "__anext__()" method of an *asynchronous
   iterator* object to stop the iteration.

   버전 3.5에 추가.

exception SyntaxError(message, details)

   파서가 문법 오류를 만날 때 발생합니다. "import" 문에서, 내장 함수
   "compile()", "exec()" 또는 "eval()" 호출에서, 초기 스크립트나 (대화
   형으로) 표준 입력을 읽을 때 발생할 수 있습니다.

   예외 인스턴스의 "str()"은 에러 메시지만 돌려줍니다. details는 각 멤
   버가 별도의 어트리뷰트로도 제공되는 튜플입니다.

   filename

      문법 오류가 발생한 파일의 이름.

   lineno

      오류가 발생한 파일의 줄 번호. 1-인덱싱됩니다: 파일의 첫 번째 줄
      은 "lineno"가 1입니다.

   offset

      오류가 발생한 줄의 열. 1-인덱싱됩니다: 줄의 첫 번째 문자는
      "offset"이 1입니다.

   text

      오류를 수반한 소스 코드 텍스트.

   end_lineno

      오류가 발생한 파일의 끝나는 줄 번호. 1-인덱싱됩니다: 파일의 첫
      번째 줄은 "lineno"가 1입니다.

   end_offset

      발생한 오류가 끝나는 줄의 열. 1-인덱싱됩니다: 줄의 첫 번째 문자
      는 "offset"이 1입니다.

   For errors in f-string fields, the message is prefixed by
   "f-string: " and the offsets are offsets in a text constructed from
   the replacement expression.  For example, compiling f'Bad {a b}
   field' results in this args attribute: ('f-string: ...', ('', 1, 2,
   '(a b)n', 1, 5)).

   버전 3.10에서 변경: "end_lineno"과 "end_offset" 어트리뷰트를 추가했
   습니다.

exception IndentationError

   잘못된 들여쓰기와 관련된 문법 오류의 베이스 클래스입니다.
   "SyntaxError" 의 서브 클래스입니다.

exception TabError

   들여쓰기가 일관성없는 탭과 스페이스 사용을 포함하는 경우 발생합니다
   . "IndentationError" 의 서브 클래스입니다.

exception SystemError

   Raised when the interpreter finds an internal error, but the
   situation does not look so serious to cause it to abandon all hope.
   The associated value is a string indicating what went wrong (in
   low-level terms).

   You should report this to the author or maintainer of your Python
   interpreter. Be sure to report the version of the Python
   interpreter ("sys.version"; it is also printed at the start of an
   interactive Python session), the exact error message (the
   exception's associated value) and if possible the source of the
   program that triggered the error.

exception SystemExit

   이 예외는 "sys.exit()" 함수가 일으킵니다. "Exception"을 잡는 코드에
   의해 우연히 잡히지 않도록, "Exception" 대신에 "BaseException" 을 상
   속합니다. 이렇게 하면 예외가 올바르게 전파되어 인터프리터가 종료됩
   니다. 처리되지 않으면, 파이썬 인터프리터가 종료됩니다; 스택 트레이
   스백은 인쇄되지 않습니다. 생성자는 "sys.exit()" 에 전달된 것과 같은
   선택적 인자를 받아들입니다. 값이 정수이면 시스템 종료 상태를 지정합
   니다 (C의 "exit()" 함수에 전달됩니다); "None" 이면 종료 상태는 0입
   니다; 다른 형(가령 문자열)이면 객체의 값이 인쇄되고 종료 상태는 1입
   니다.

   "sys.exit()" 에 대한 호출은 예외로 변환되어 뒷정리 처리기 ("try" 문
   의 "finally" 절) 가 실행될 수 있도록 합니다. 그래서 디버거는 제어권
   을 잃을 위험 없이 스크립트를 실행할 수 있습니다. 즉시 종료가 절대적
   으로 필요한 경우에는 "os._exit()" 함수를 사용할 수 있습니다 (예를
   들어, "os.fork()" 호출 후의 자식 프로세스에서).

   code

      생성자에 전달되는 종료 상태 또는 에러 메시지입니다. (기본값은
      "None" 입니다.)

exception TypeError

   연산이나 함수가 부적절한 형의 객체에 적용될 때 발생합니다. 연관된
   값은 형 불일치에 대한 세부 정보를 제공하는 문자열입니다.

   이 예외는 객체에 시도된 연산이 지원되지 않으며 그럴 의도도 없음을
   나타내기 위해 사용자 코드가 발생시킬 수 있습니다. 만약 객체가 주어
   진 연산을 지원할 의사는 있지만, 아직 구현을 제공하지 않는 경우라면,
   "NotImplementedError" 를 발생시키는 것이 적합합니다.

   잘못된 형의 인자를 전달하면 (가령 "int" 를 기대하는데 "list"를 전달
   하기), "TypeError" 를 일으켜야 합니다. 하지만 잘못된 값을 갖는 인자
   를 전달하면 (가령 범위를 넘어서는 숫자) "ValueError" 를 일으켜야 합
   니다.

exception UnboundLocalError

   함수 나 메서드에서 지역 변수를 참조하지만, 해당 변수에 값이 연결되
   지 않으면 발생합니다. 이것은 "NameError" 의 서브 클래스입니다.

exception UnicodeError

   유니코드 관련 인코딩 또는 디코딩 에러가 일어날 때 발생합니다.
   "ValueError" 의 서브 클래스입니다.

   "UnicodeError" 는 인코딩이나 디코딩 에러를 설명하는 어트리뷰트를 가
   지고 있습니다. 예를 들어, "err.object[err.start:err.end]" 는 코덱이
   실패한 잘못된 입력을 제공합니다.

   encoding

      에러를 발생시킨 인코딩의 이름입니다.

   reason

      구체적인 코덱 오류를 설명하는 문자열입니다.

   object

      코덱이 인코딩 또는 디코딩하려고 시도한 객체입니다.

   start

      "object" 에 있는 잘못된 데이터의 최초 인덱스입니다.

   end

      "object" 에 있는 마지막으로 잘못된 데이터의 바로 다음 인덱스입니
      다.

exception UnicodeEncodeError

   인코딩 중에 유니코드 관련 에러가 일어나면 발생합니다.
   "UnicodeError" 의 서브 클래스입니다.

exception UnicodeDecodeError

   디코딩 중에 유니코드 관련 에러가 일어나면 발생합니다.
   "UnicodeError" 의 서브 클래스입니다.

exception UnicodeTranslateError

   번역 중에 유니코드 관련 에러가 일어나면 발생합니다. "UnicodeError"
   의 서브 클래스입니다.

exception ValueError

   연산이나 함수가 올바른 형이지만 부적절한 값을 가진 인자를 받았고,
   상황이 "IndexError" 처럼 더 구체적인 예외로 설명되지 않는 경우 발생
   합니다.

exception ZeroDivisionError

   나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생합니다. 연관된
   값은 피연산자의 형과 연산을 나타내는 문자열입니다.

다음 예외는 이전 버전과의 호환성을 위해 유지됩니다; 파이썬 3.3부터는
"OSError" 의 별칭입니다.

exception EnvironmentError

exception IOError

exception WindowsError

   윈도우에서만 사용할 수 있습니다.


OS 예외
-------

다음의 예외는 "OSError" 의 서브 클래스이며, 시스템 에러 코드에 따라 발
생합니다.

exception BlockingIOError

   Raised when an operation would block on an object (e.g. socket) set
   for non-blocking operation. Corresponds to "errno" "EAGAIN",
   "EALREADY", "EWOULDBLOCK" and "EINPROGRESS".

   "OSError" 의 것 외에도, "BlockingIOError" 는 어트리뷰트를 하나 더
   가질 수 있습니다:

   characters_written

      블록 되기 전에 스트림에 쓴 문자 수를 포함하는 정수. 이 어트리뷰
      트는 "io" 모듈에서 버퍼링 된 입출력 클래스를 사용할 때 쓸 수 있
      습니다.

exception ChildProcessError

   Raised when an operation on a child process failed. Corresponds to
   "errno" "ECHILD".

exception ConnectionError

   연결 관련 문제에 대한 베이스 클래스입니다.

   서브 클래스는 "BrokenPipeError", "ConnectionAbortedError",
   "ConnectionRefusedError" 및 "ConnectionResetError" 입니다.

exception BrokenPipeError

   A subclass of "ConnectionError", raised when trying to write on a
   pipe while the other end has been closed, or trying to write on a
   socket which has been shutdown for writing. Corresponds to "errno"
   "EPIPE" and "ESHUTDOWN".

exception ConnectionAbortedError

   A subclass of "ConnectionError", raised when a connection attempt
   is aborted by the peer. Corresponds to "errno" "ECONNABORTED".

exception ConnectionRefusedError

   A subclass of "ConnectionError", raised when a connection attempt
   is refused by the peer. Corresponds to "errno" "ECONNREFUSED".

exception ConnectionResetError

   A subclass of "ConnectionError", raised when a connection is reset
   by the peer. Corresponds to "errno" "ECONNRESET".

exception FileExistsError

   Raised when trying to create a file or directory which already
   exists. Corresponds to "errno" "EEXIST".

exception FileNotFoundError

   Raised when a file or directory is requested but doesn't exist.
   Corresponds to "errno" "ENOENT".

exception InterruptedError

   Raised when a system call is interrupted by an incoming signal.
   Corresponds to "errno" "EINTR".

   버전 3.5에서 변경: 이제 파이썬은 시스템 호출이 시그널에 의해 중단될
   때, 시그널 처리기가 예외를 일으키는 경우를 제외하고 (이유는 **PEP
   475** 를 참조하세요), "InterruptedError" 를 일으키는 대신 시스템 호
   출을 재시도합니다.

exception IsADirectoryError

   Raised when a file operation (such as "os.remove()") is requested
   on a directory. Corresponds to "errno" "EISDIR".

exception NotADirectoryError

   Raised when a directory operation (such as "os.listdir()") is
   requested on something which is not a directory.  On most POSIX
   platforms, it may also be raised if an operation attempts to open
   or traverse a non-directory file as if it were a directory.
   Corresponds to "errno" "ENOTDIR".

exception PermissionError

   Raised when trying to run an operation without the adequate access
   rights - for example filesystem permissions. Corresponds to "errno"
   "EACCES" and "EPERM".

exception ProcessLookupError

   Raised when a given process doesn't exist. Corresponds to "errno"
   "ESRCH".

exception TimeoutError

   Raised when a system function timed out at the system level.
   Corresponds to "errno" "ETIMEDOUT".

버전 3.3에 추가: 위의 모든 "OSError" 서브 클래스가 추가되었습니다.

더 보기: **PEP 3151** - OS 및 IO 예외 계층 구조 재작업


경고
====

다음 예외는 경고 범주로 사용됩니다; 자세한 정보는 경고 범주 설명서를
보십시오.

exception Warning

   경고 범주의 베이스 클래스입니다.

exception UserWarning

   사용자 코드에 의해 만들어지는 경고의 베이스 클래스입니다.

exception DeprecationWarning

   폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 다른 파이썬
   개발자를 대상으로 하는 경우입니다.

   "__main__" 모듈을 제외하고, 기본 경고 필터에 의해 무시됩니다 (**PEP
   565**). 파이썬 개발 모드를 활성화하면 이 경고가 표시됩니다.

   The deprecation policy is described in **PEP 387**.

exception PendingDeprecationWarning

   더는 사용되지 않고 장래에 폐지될 예정이지만, 지금 당장 폐지되지는
   않은 기능에 관한 경고의 베이스 클래스입니다.

   앞으로 있을 수도 있는 폐지에 관한 경고는 일반적이지 않기 때문에, 이
   클래스는 거의 사용되지 않습니다. 이미 활성화된 폐지에는
   "DeprecationWarning"을 선호합니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

   The deprecation policy is described in **PEP 387**.

exception SyntaxWarning

   모호한 문법에 대한 경고의 베이스 클래스입니다.

exception RuntimeWarning

   모호한 실행 시간 동작에 대한 경고의 베이스 클래스입니다.

exception FutureWarning

   폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 파이썬으로
   작성된 응용 프로그램의 최종 사용자를 대상으로 하는 경우입니다.

exception ImportWarning

   모듈 임포트에 있을 수 있는 실수에 대한 경고의 베이스 클래스입니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

exception UnicodeWarning

   유니코드와 관련된 경고의 베이스 클래스입니다.

exception EncodingWarning

   인코딩과 관련된 경고의 베이스 클래스입니다.

   See Opt-in EncodingWarning for details.

   버전 3.10에 추가.

exception BytesWarning

   "bytes" 및 "bytearray" 와 관련된 경고의 베이스 클래스입니다.

exception ResourceWarning

   자원 사용과 관련된 경고의 베이스 클래스입니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

   버전 3.2에 추가.


예외 계층 구조
==============

내장 예외의 클래스 계층 구조는 다음과 같습니다:

   BaseException
    +-- SystemExit
    +-- KeyboardInterrupt
    +-- GeneratorExit
    +-- Exception
         +-- StopIteration
         +-- StopAsyncIteration
         +-- ArithmeticError
         |    +-- FloatingPointError
         |    +-- OverflowError
         |    +-- ZeroDivisionError
         +-- AssertionError
         +-- AttributeError
         +-- BufferError
         +-- EOFError
         +-- ImportError
         |    +-- ModuleNotFoundError
         +-- LookupError
         |    +-- IndexError
         |    +-- KeyError
         +-- MemoryError
         +-- NameError
         |    +-- UnboundLocalError
         +-- OSError
         |    +-- BlockingIOError
         |    +-- ChildProcessError
         |    +-- ConnectionError
         |    |    +-- BrokenPipeError
         |    |    +-- ConnectionAbortedError
         |    |    +-- ConnectionRefusedError
         |    |    +-- ConnectionResetError
         |    +-- FileExistsError
         |    +-- FileNotFoundError
         |    +-- InterruptedError
         |    +-- IsADirectoryError
         |    +-- NotADirectoryError
         |    +-- PermissionError
         |    +-- ProcessLookupError
         |    +-- TimeoutError
         +-- ReferenceError
         +-- RuntimeError
         |    +-- NotImplementedError
         |    +-- RecursionError
         +-- SyntaxError
         |    +-- IndentationError
         |         +-- TabError
         +-- SystemError
         +-- TypeError
         +-- ValueError
         |    +-- UnicodeError
         |         +-- UnicodeDecodeError
         |         +-- UnicodeEncodeError
         |         +-- UnicodeTranslateError
         +-- Warning
              +-- DeprecationWarning
              +-- PendingDeprecationWarning
              +-- RuntimeWarning
              +-- SyntaxWarning
              +-- UserWarning
              +-- FutureWarning
              +-- ImportWarning
              +-- UnicodeWarning
              +-- BytesWarning
              +-- EncodingWarning
              +-- ResourceWarning
