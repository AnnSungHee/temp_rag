"venv" --- Creation of virtual environments
*******************************************

버전 3.3에 추가.

**소스 코드:** Lib/venv/

======================================================================

The "venv" module supports creating lightweight "virtual
environments", each with their own independent set of Python packages
installed in their "site" directories. A virtual environment is
created on top of an existing Python installation, known as the
virtual environment's "base" Python, and may optionally be isolated
from the packages in the base environment, so only those explicitly
installed in the virtual environment are available.

When used from within a virtual environment, common installation tools
such as pip will install Python packages into a virtual environment
without needing to be told to do so explicitly.

파이썬 가상 환경에 대한 자세한 배경 정보는 **PEP 405**를 참조하십시오.

더 보기:

  Python Packaging User Guide: Creating and using virtual environments


가상 환경 만들기
================

Creation of virtual environments is done by executing the command
"venv":

   python -m venv /path/to/new/virtual/environment

Running this command creates the target directory (creating any parent
directories that don't exist already) and places a "pyvenv.cfg" file
in it with a "home" key pointing to the Python installation from which
the command was run (a common name for the target directory is
".venv").  It also creates a "bin" (or "Scripts" on Windows)
subdirectory containing a copy/symlink of the Python binary/binaries
(as appropriate for the platform or arguments used at environment
creation time). It also creates an (initially empty) "lib/pythonX.Y
/site-packages" subdirectory (on Windows, this is "Lib\site-
packages"). If an existing directory is specified, it will be re-used.

버전 3.6부터 폐지: "pyvenv" was the recommended tool for creating
virtual environments for Python 3.3 and 3.4, and is deprecated in
Python 3.6.

버전 3.5에서 변경: 이제 가상 환경을 만들 때 "venv"를 사용하는 것이 좋
습니다.

On Windows, invoke the "venv" command as follows:

   c:\>c:\Python35\python -m venv c:\path\to\myenv

Alternatively, if you configured the "PATH" and "PATHEXT" variables
for your Python installation:

   c:\>python -m venv c:\path\to\myenv

명령에 "-h"를 사용하면 사용 가능한 옵션이 표시됩니다:

   usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
               [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]
               ENV_DIR [ENV_DIR ...]

   Creates virtual Python environments in one or more target directories.

   positional arguments:
     ENV_DIR               A directory to create the environment in.

   optional arguments:
     -h, --help            show this help message and exit
     --system-site-packages
                           Give the virtual environment access to the system
                           site-packages dir.
     --symlinks            Try to use symlinks rather than copies, when symlinks
                           are not the default for the platform.
     --copies              Try to use copies rather than symlinks, even when
                           symlinks are the default for the platform.
     --clear               Delete the contents of the environment directory if it
                           already exists, before environment creation.
     --upgrade             Upgrade the environment directory to use this version
                           of Python, assuming Python has been upgraded in-place.
     --without-pip         Skips installing or upgrading pip in the virtual
                           environment (pip is bootstrapped by default)
     --prompt PROMPT       Provides an alternative prompt prefix for this
                           environment.
     --upgrade-deps        Upgrade core dependencies: pip setuptools to the
                           latest version in PyPI

   Once an environment has been created, you may wish to activate it, e.g. by
   sourcing an activate script in its bin directory.

버전 3.9에서 변경: Add "--upgrade-deps" option to upgrade pip +
setuptools to the latest on PyPI

버전 3.4에서 변경: Installs pip by default, added the "--without-pip"
and "--copies" options

버전 3.4에서 변경: 이전 버전에서는, "--clear" 나 "--upgrade" 옵션이 제
공되지 않았을 때, 대상 디렉터리가 이미 존재하면 에러가 발생했습니다.

참고:

  심볼릭 링크가 윈도우에서 지원되지만, 추천하지는 않습니다. 특히 파일
  탐색기에서 "python.exe"를 더블 클릭하면 심볼릭 링크를 열심히 따라가
  고(resolve) 가상 환경은 무시됩니다.

참고:

  마이크로소프트 윈도우에서는 사용자에 대한 실행 정책을 설정하여
  "Activate.ps1" 스크립트를 활성화해야 할 수도 있습니다. 다음
  PowerShell 명령을 실행하여 이를 수행할 수 있습니다:PS C:> Set-
  ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser자세
  한 정보는 About Execution Policies를 참조하십시오.

The created "pyvenv.cfg" file also includes the "include-system-site-
packages" key, set to "true" if "venv" is run with the "--system-site-
packages" option, "false" otherwise.

"--without-pip" 옵션을 주지 않는 한, 가상 환경으로 "pip"을 부트스트랩
하기 위해 "ensurepip"가 호출됩니다.

"venv"에 여러 경로를 지정할 수 있습니다. 이때 지정된 옵션에 따라 제공
된 각 경로에서 같은 가상 환경이 만들어집니다.


How venvs work
==============

When a Python interpreter is running from a virtual environment,
"sys.prefix" and "sys.exec_prefix" point to the directories of the
virtual environment, whereas "sys.base_prefix" and
"sys.base_exec_prefix" point to those of the base Python used to
create the environment. It is sufficient to check "sys.prefix ==
sys.base_prefix" to determine if the current interpreter is running
from a virtual environment.

A virtual environment may be "activated" using a script in its binary
directory ("bin" on POSIX; "Scripts" on Windows). This will prepend
that directory to your "PATH", so that running **python** will invoke
the environment's Python interpreter and you can run installed scripts
without having to use their full path. The invocation of the
activation script is platform-specific ("*<venv>*" must be replaced by
the path to the directory containing the virtual environment):

+---------------+--------------+----------------------------------------------------+
| 플랫폼        | 셸           | 가상 환경을 활성화하는 명령                        |
|===============|==============|====================================================|
| POSIX         | bash/zsh     | "$ source *<venv>*/bin/activate"                   |
|               +--------------+----------------------------------------------------+
|               | fish         | "$ source *<venv>*/bin/activate.fish"              |
|               +--------------+----------------------------------------------------+
|               | csh/tcsh     | "$ source *<venv>*/bin/activate.csh"               |
|               +--------------+----------------------------------------------------+
|               | PowerShell   | "$ *<venv>*/bin/Activate.ps1"                      |
+---------------+--------------+----------------------------------------------------+
| 윈도우        | cmd.exe      | "C:\> *<venv>*\Scripts\activate.bat"               |
|               +--------------+----------------------------------------------------+
|               | PowerShell   | "PS C:\> *<venv>*\Scripts\Activate.ps1"            |
+---------------+--------------+----------------------------------------------------+

버전 3.4에 추가: **fish** 와 **csh** 활성화 스크립트.

버전 3.8에 추가: PowerShell Core 지원을 위해 POSIX에 설치된 PowerShell
활성화 스크립트.

가상 환경을 구체적으로 활성화할 *필요*는 없습니다, 파이썬을 호출할 때
그 환경의 파이썬 인터프리터를 가리키는 전체 경로를 지정하기만 하면 되
기 때문입니다. 또한, 환경에 설치된 모든 스크립트는 활성화하지 않고도
실행 가능해야 합니다.

In order to achieve this, scripts installed into virtual environments
have a "shebang" line which points to the environment's Python
interpreter, i.e. "#!/*<path-to-venv>*/bin/python". This means that
the script will run with that interpreter regardless of the value of
"PATH". On Windows, "shebang" line processing is supported if you have
the 윈도우 용 파이썬 런처 installed. Thus, double-clicking an
installed script in a Windows Explorer window should run it with the
correct interpreter without the environment needing to be activated or
on the "PATH".

가상 환경이 활성화되면, "VIRTUAL_ENV" 환경 변수가 환경의 경로로 설정됩
니다. 가상 환경을 사용하기 위해 명시적으로 활성화할 필요가 없기 때문에
, "VIRTUAL_ENV"로 가상 환경이 사용 중인지를 판단할 수 없습니다.

경고:

  Because scripts installed in environments should not expect the
  environment to be activated, their shebang lines contain the
  absolute paths to their environment's interpreters. Because of this,
  environments are inherently non-portable, in the general case. You
  should always have a simple means of recreating an environment (for
  example, if you have a requirements file "requirements.txt", you can
  invoke "pip install -r requirements.txt" using the environment's
  "pip" to install all of the packages needed by the environment). If
  for any reason you need to move the environment to a new location,
  you should recreate it at the desired location and delete the one at
  the old location. If you move an environment because you moved a
  parent directory of it, you should recreate the environment in its
  new location. Otherwise, software installed into the environment may
  not work as expected.

셸에서 "deactivate"를 입력하여 가상 환경을 비활성화할 수 있습니다. 정
확한 메커니즘은 플랫폼에 따라 다르고 내부 구현 상세입니다 (보통, 스크
립트나 셸 함수가 사용됩니다).


API
===

위에서 설명한 고수준 메서드는 제삼자 가상 환경 작성자가 필요에 따라 환
경을 사용자 정의할 수 있는 메커니즘을 제공하는 간단한 API를 사용합니다
: "EnvBuilder" 클래스.

class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False, prompt=None, upgrade_deps=False)

   "EnvBuilder" 클래스는 인스턴스를 만들 때 다음 키워드 인자를 받아들
   입니다:

   * "system_site_packages" -- a Boolean value indicating that the
     system Python site-packages should be available to the
     environment (defaults to "False").

   * "clear" -- a Boolean value which, if true, will delete the
     contents of any existing target directory, before creating the
     environment.

   * "symlinks" -- a Boolean value indicating whether to attempt to
     symlink the Python binary rather than copying.

   * "upgrade" -- a Boolean value which, if true, will upgrade an
     existing environment with the running Python - for use when that
     Python has been upgraded in-place (defaults to "False").

   * "with_pip" -- a Boolean value which, if true, ensures pip is
     installed in the virtual environment. This uses "ensurepip" with
     the "--default-pip" option.

   * "prompt" -- a String to be used after virtual environment is
     activated (defaults to "None" which means directory name of the
     environment would be used). If the special string ""."" is
     provided, the basename of the current directory is used as the
     prompt.

   * "upgrade_deps" -- Update the base venv modules to the latest on
     PyPI

   버전 3.4에서 변경: "with_pip" 매개 변수 추가

   버전 3.6에 추가: "prompt" 매개 변수 추가

   버전 3.9에 추가: "upgrade_deps" 매개 변수 추가

   Creators of third-party virtual environment tools will be free to
   use the provided "EnvBuilder" class as a base class.

   The returned env-builder is an object which has a method, "create":

   create(env_dir)

      가상 환경을 담을 대상 디렉터리(절대 또는 현재 디렉터리에 대한 상
      대)를 지정해서 가상 환경을 만듭니다. "create" 메서드는 지정된 디
      렉터리에 환경을 만들거나 적절한 예외를 발생시킵니다.

      "EnvBuilder" 클래스의 "create" 메서드는 서브 클래스가 사용자 정
      의할 수 있는 훅을 보여줍니다:

         def create(self, env_dir):
             """
             Create a virtualized Python environment in a directory.
             env_dir is the target directory to create an environment in.
             """
             env_dir = os.path.abspath(env_dir)
             context = self.ensure_directories(env_dir)
             self.create_configuration(context)
             self.setup_python(context)
             self.setup_scripts(context)
             self.post_setup(context)

      메서드 "ensure_directories()", "create_configuration()",
      "setup_python()", "setup_scripts()" 및 "post_setup()" 각각을 재
      정의할 수 있습니다.

   ensure_directories(env_dir)

      환경 디렉터리와 이미 존재하지 않는 필요한 모든 서브 디렉터리를
      만들고, 문맥 객체를 돌려줍니다. 문맥 객체는 다른 메서드에서 사용
      하기 위한 어트리뷰트(가령 경로)를 담고 있을 뿐입니다.
      "EnvBuilder"가 "clear=True" 인자로 만들어지면, 환경 디렉터리의
      내용이 지워진 후 모든 필요한 서브 디렉터리가 재생성됩니다.

      The returned context object is a "types.SimpleNamespace" with
      the following attributes:

      * "env_dir" - The location of the virtual environment. Used for
        "__VENV_DIR__" in activation scripts (see
        "install_scripts()").

      * "env_name" - The name of the virtual environment. Used for
        "__VENV_NAME__" in activation scripts (see
        "install_scripts()").

      * "prompt" - The prompt to be used by the activation scripts.
        Used for "__VENV_PROMPT__" in activation scripts (see
        "install_scripts()").

      * "executable" - The underlying Python executable used by the
        virtual environment. This takes into account the case where a
        virtual environment is created from another virtual
        environment.

      * "inc_path" - The include path for the virtual environment.

      * "lib_path" - The purelib path for the virtual environment.

      * "bin_path" - 가상 환경의 스크립트 경로.

      * "bin_name" - The name of the script path relative to the
        virtual environment location. Used for "__VENV_BIN_NAME__" in
        activation scripts (see "install_scripts()").

      * "env_exe" - The name of the Python interpreter in the virtual
        environment. Used for "__VENV_PYTHON__" in activation scripts
        (see "install_scripts()").

      * "env_exec_cmd" - The name of the Python interpreter, taking
        into account filesystem redirections. This can be used to run
        Python in the virtual environment.

      버전 3.12에서 변경: The attribute "lib_path" was added to the
      context, and the context object was documented.

      버전 3.11에서 변경: The *venv* sysconfig installation scheme is
      used to construct the paths of the created directories.

   create_configuration(context)

      환경에 "pyvenv.cfg" 구성 파일을 만듭니다.

   setup_python(context)

      환경에 파이썬 실행 파일의 복사본이나 심볼릭 링크를 만듭니다.
      POSIX 시스템에서, 특정 실행 파일 "python3.x"가 사용되면, 해당 이
      름의 파일이 이미 존재하지 않는 한 "python" 과 "python3" 심볼릭
      링크가 해당 실행 파일을 가리키도록 만들어집니다.

   setup_scripts(context)

      플랫폼에 적합한 활성화 스크립트를 가상 환경에 설치합니다.

   upgrade_dependencies(context)

      Upgrades the core venv dependency packages (currently "pip" and
      "setuptools") in the environment. This is done by shelling out
      to the "pip" executable in the environment.

      버전 3.9에 추가.

   post_setup(context)

      제삼자 구현에서 재정의하여 가상 환경에 패키지를 사전 설치하거나
      다른 생성 후 단계를 수행할 수 있는 메서드입니다.

   버전 3.7.2에서 변경: 윈도우는 이제 실제 바이너리를 복사하는 대신
   "python[w].exe"를 위한 리디렉터 스크립트를 사용합니다. 3.7.2 에서만
   , 소스 트리의 빌드에서 실행하지 않는 한 "setup_python()"아무 작업도
   수행하지 않습니다.

   버전 3.7.3에서 변경: 윈도우는 "setup_scripts()" 대신
   "setup_python()"의 일부로 리디렉터 스크립트를 복사합니다. 이것은
   3.7.2는 해당하지 않습니다. 심볼릭 링크를 사용하면, 원래 실행 파일이
   링크됩니다.

   In addition, "EnvBuilder" provides this utility method that can be
   called from "setup_scripts()" or "post_setup()" in subclasses to
   assist in installing custom scripts into the virtual environment.

   install_scripts(context, path)

      *path* is the path to a directory that should contain
      subdirectories "common", "posix", "nt", each containing scripts
      destined for the bin directory in the environment.  The contents
      of "common" and the directory corresponding to "os.name" are
      copied after some text replacement of placeholders:

      * "__VENV_DIR__"은 환경 디렉터리의 절대 경로로 치환됩니다.

      * "__VENV_NAME__"은 환경 이름(환경 디렉터리의 최종 경로 세그먼트
        )으로 치환됩니다.

      * "__VENV_PROMPT__"는 프롬프트(괄호로 묶인 환경 이름과 그 뒤의
        스페이스)로 치환됩니다

      * "__VENV_BIN_NAME__"은 bin 디렉터리의 이름("bin" 이나
        "Scripts")으로 치환됩니다.

      * "__VENV_PYTHON__"은 환경의 실행 파일의 절대 경로로 치환됩니다.

      디렉터리는 존재하는 것이 허용됩니다 (기존 환경이 업그레이드될 때
      ).

모듈 수준의 편리 함수도 있습니다:

venv.create(env_dir, system_site_packages=False, clear=False, symlinks=False, with_pip=False, prompt=None, upgrade_deps=False)

   주어진 키워드 인자로 "EnvBuilder"를 만들고, *env_dir* 인자로
   "create()" 메서드를 호출합니다.

   버전 3.3에 추가.

   버전 3.4에서 변경: "with_pip" 매개 변수 추가

   버전 3.6에서 변경: "prompt" 매개 변수 추가

   버전 3.9에서 변경: "upgrade_deps" 매개 변수 추가


"EnvBuilder" 확장 예제
======================

다음 스크립트는 생성된 가상 환경에 setuptools 와 pip을 설치하는 서브
클래스를 구현하여 "EnvBuilder"를 확장하는 방법을 보여줍니다:

   import os
   import os.path
   from subprocess import Popen, PIPE
   import sys
   from threading import Thread
   from urllib.parse import urlparse
   from urllib.request import urlretrieve
   import venv

   class ExtendedEnvBuilder(venv.EnvBuilder):
       """
       This builder installs setuptools and pip so that you can pip or
       easy_install other packages into the created virtual environment.

       :param nodist: If true, setuptools and pip are not installed into the
                      created virtual environment.
       :param nopip: If true, pip is not installed into the created
                     virtual environment.
       :param progress: If setuptools or pip are installed, the progress of the
                        installation can be monitored by passing a progress
                        callable. If specified, it is called with two
                        arguments: a string indicating some progress, and a
                        context indicating where the string is coming from.
                        The context argument can have one of three values:
                        'main', indicating that it is called from virtualize()
                        itself, and 'stdout' and 'stderr', which are obtained
                        by reading lines from the output streams of a subprocess
                        which is used to install the app.

                        If a callable is not specified, default progress
                        information is output to sys.stderr.
       """

       def __init__(self, *args, **kwargs):
           self.nodist = kwargs.pop('nodist', False)
           self.nopip = kwargs.pop('nopip', False)
           self.progress = kwargs.pop('progress', None)
           self.verbose = kwargs.pop('verbose', False)
           super().__init__(*args, **kwargs)

       def post_setup(self, context):
           """
           Set up any packages which need to be pre-installed into the
           virtual environment being created.

           :param context: The information for the virtual environment
                           creation request being processed.
           """
           os.environ['VIRTUAL_ENV'] = context.env_dir
           if not self.nodist:
               self.install_setuptools(context)
           # Can't install pip without setuptools
           if not self.nopip and not self.nodist:
               self.install_pip(context)

       def reader(self, stream, context):
           """
           Read lines from a subprocess' output stream and either pass to a progress
           callable (if specified) or write progress information to sys.stderr.
           """
           progress = self.progress
           while True:
               s = stream.readline()
               if not s:
                   break
               if progress is not None:
                   progress(s, context)
               else:
                   if not self.verbose:
                       sys.stderr.write('.')
                   else:
                       sys.stderr.write(s.decode('utf-8'))
                   sys.stderr.flush()
           stream.close()

       def install_script(self, context, name, url):
           _, _, path, _, _, _ = urlparse(url)
           fn = os.path.split(path)[-1]
           binpath = context.bin_path
           distpath = os.path.join(binpath, fn)
           # Download script into the virtual environment's binaries folder
           urlretrieve(url, distpath)
           progress = self.progress
           if self.verbose:
               term = '\n'
           else:
               term = ''
           if progress is not None:
               progress('Installing %s ...%s' % (name, term), 'main')
           else:
               sys.stderr.write('Installing %s ...%s' % (name, term))
               sys.stderr.flush()
           # Install in the virtual environment
           args = [context.env_exe, fn]
           p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath)
           t1 = Thread(target=self.reader, args=(p.stdout, 'stdout'))
           t1.start()
           t2 = Thread(target=self.reader, args=(p.stderr, 'stderr'))
           t2.start()
           p.wait()
           t1.join()
           t2.join()
           if progress is not None:
               progress('done.', 'main')
           else:
               sys.stderr.write('done.\n')
           # Clean up - no longer needed
           os.unlink(distpath)

       def install_setuptools(self, context):
           """
           Install setuptools in the virtual environment.

           :param context: The information for the virtual environment
                           creation request being processed.
           """
           url = 'https://bitbucket.org/pypa/setuptools/downloads/ez_setup.py'
           self.install_script(context, 'setuptools', url)
           # clear up the setuptools archive which gets downloaded
           pred = lambda o: o.startswith('setuptools-') and o.endswith('.tar.gz')
           files = filter(pred, os.listdir(context.bin_path))
           for f in files:
               f = os.path.join(context.bin_path, f)
               os.unlink(f)

       def install_pip(self, context):
           """
           Install pip in the virtual environment.

           :param context: The information for the virtual environment
                           creation request being processed.
           """
           url = 'https://bootstrap.pypa.io/get-pip.py'
           self.install_script(context, 'pip', url)

   def main(args=None):
       compatible = True
       if sys.version_info < (3, 3):
           compatible = False
       elif not hasattr(sys, 'base_prefix'):
           compatible = False
       if not compatible:
           raise ValueError('This script is only for use with '
                            'Python 3.3 or later')
       else:
           import argparse

           parser = argparse.ArgumentParser(prog=__name__,
                                            description='Creates virtual Python '
                                                        'environments in one or '
                                                        'more target '
                                                        'directories.')
           parser.add_argument('dirs', metavar='ENV_DIR', nargs='+',
                               help='A directory in which to create the '
                                    'virtual environment.')
           parser.add_argument('--no-setuptools', default=False,
                               action='store_true', dest='nodist',
                               help="Don't install setuptools or pip in the "
                                    "virtual environment.")
           parser.add_argument('--no-pip', default=False,
                               action='store_true', dest='nopip',
                               help="Don't install pip in the virtual "
                                    "environment.")
           parser.add_argument('--system-site-packages', default=False,
                               action='store_true', dest='system_site',
                               help='Give the virtual environment access to the '
                                    'system site-packages dir.')
           if os.name == 'nt':
               use_symlinks = False
           else:
               use_symlinks = True
           parser.add_argument('--symlinks', default=use_symlinks,
                               action='store_true', dest='symlinks',
                               help='Try to use symlinks rather than copies, '
                                    'when symlinks are not the default for '
                                    'the platform.')
           parser.add_argument('--clear', default=False, action='store_true',
                               dest='clear', help='Delete the contents of the '
                                                  'virtual environment '
                                                  'directory if it already '
                                                  'exists, before virtual '
                                                  'environment creation.')
           parser.add_argument('--upgrade', default=False, action='store_true',
                               dest='upgrade', help='Upgrade the virtual '
                                                    'environment directory to '
                                                    'use this version of '
                                                    'Python, assuming Python '
                                                    'has been upgraded '
                                                    'in-place.')
           parser.add_argument('--verbose', default=False, action='store_true',
                               dest='verbose', help='Display the output '
                                                  'from the scripts which '
                                                  'install setuptools and pip.')
           options = parser.parse_args(args)
           if options.upgrade and options.clear:
               raise ValueError('you cannot supply --upgrade and --clear together.')
           builder = ExtendedEnvBuilder(system_site_packages=options.system_site,
                                          clear=options.clear,
                                          symlinks=options.symlinks,
                                          upgrade=options.upgrade,
                                          nodist=options.nodist,
                                          nopip=options.nopip,
                                          verbose=options.verbose)
           for d in options.dirs:
               builder.create(d)

   if __name__ == '__main__':
       rc = 1
       try:
           main()
           rc = 0
       except Exception as e:
           print('Error: %s' % e, file=sys.stderr)
       sys.exit(rc)

이 스크립트는 온라인에서 내려받을 수도 있습니다.
