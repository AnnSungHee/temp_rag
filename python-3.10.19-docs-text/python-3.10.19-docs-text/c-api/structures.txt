공통 객체 구조체
****************

파이썬의 객체 형 정의에 사용되는 많은 구조체가 있습니다. 이 섹션에서는
이러한 구조체와 사용 방법에 관해 설명합니다.


기본 객체 형과 매크로
=====================

All Python objects ultimately share a small number of fields at the
beginning of the object's representation in memory.  These are
represented by the "PyObject" and "PyVarObject" types, which are
defined, in turn, by the expansions of some macros also used, whether
directly or indirectly, in the definition of all other Python objects.

type PyObject
    * Part of the Limited API. (Only some members are part of the
   stable ABI.)*

   모든 객체 형은 이 형의 확장입니다. 이것은 파이썬이 객체에 대한 포인
   터를 객체로 취급하는 데 필요한 정보를 포함하는 형입니다. 일반적인 "
   릴리스" 빌드에는, 객체의 참조 횟수와 해당 형 객체에 대한 포인터만
   포함됩니다. 실제로 "PyObject"로 선언된 것은 없지만, 파이썬 객체에
   대한 모든 포인터를 "PyObject*"로 캐스트 할 수 있습니다. "Py_REFCNT"
   와 "Py_TYPE" 매크로를 사용하여 멤버에 액세스해야 합니다.

type PyVarObject
    * Part of the Limited API. (Only some members are part of the
   stable ABI.)*

   This is an extension of "PyObject" that adds the "ob_size" field.
   This is only used for objects that have some notion of *length*.
   This type does not often appear in the Python/C API. Access to the
   members must be done by using the macros "Py_REFCNT", "Py_TYPE",
   and "Py_SIZE".

PyObject_HEAD

   길이가 변하지 않는 객체를 나타내는 새로운 형을 선언할 때 사용되는
   매크로입니다. PyObject_HEAD 매크로는 다음과 같이 확장됩니다:

      PyObject ob_base;

   위의 "PyObject" 설명서를 참조하십시오.

PyObject_VAR_HEAD

   인스턴스마다 길이가 다른 객체를 나타내는 새로운 형을 선언할 때 사용
   되는 매크로입니다. PyObject_VAR_HEAD 매크로는 다음과 같이 확장됩니
   다:

      PyVarObject ob_base;

   위의 "PyVarObject" 설명서를 참조하십시오.

int Py_Is(const PyObject *x, const PyObject *y)
    * Part of the Stable ABI since version 3.10.*

   Test if the *x* object is the *y* object, the same as "x is y" in
   Python.

   버전 3.10에 추가.

int Py_IsNone(const PyObject *x)
    * Part of the Stable ABI since version 3.10.*

   Test if an object is the "None" singleton, the same as "x is None"
   in Python.

   버전 3.10에 추가.

int Py_IsTrue(const PyObject *x)
    * Part of the Stable ABI since version 3.10.*

   Test if an object is the "True" singleton, the same as "x is True"
   in Python.

   버전 3.10에 추가.

int Py_IsFalse(const PyObject *x)
    * Part of the Stable ABI since version 3.10.*

   Test if an object is the "False" singleton, the same as "x is
   False" in Python.

   버전 3.10에 추가.

PyTypeObject *Py_TYPE(const PyObject *o)

   Get the type of the Python object *o*.

   Return a *borrowed reference*.

   Use the "Py_SET_TYPE()" function to set an object type.

int Py_IS_TYPE(PyObject *o, PyTypeObject *type)

   객체 *o*의 형이 *type*이면 0이 아닌 값을 반환합니다. 그렇지 않으면
   0을 반환합니다. "Py_TYPE(o) == type"과 동등합니다.

   버전 3.9에 추가.

void Py_SET_TYPE(PyObject *o, PyTypeObject *type)

   객체 *o*의 형을 *type*으로 설정합니다.

   버전 3.9에 추가.

Py_ssize_t Py_REFCNT(const PyObject *o)

   Get the reference count of the Python object *o*.

   버전 3.10에서 변경: "Py_REFCNT()" is changed to the inline static
   function. Use "Py_SET_REFCNT()" to set an object reference count.

void Py_SET_REFCNT(PyObject *o, Py_ssize_t refcnt)

   Set the object *o* reference counter to *refcnt*.

   버전 3.9에 추가.

Py_ssize_t Py_SIZE(const PyVarObject *o)

   Get the size of the Python object *o*.

   Use the "Py_SET_SIZE()" function to set an object size.

void Py_SET_SIZE(PyVarObject *o, Py_ssize_t size)

   객체 *o*의 크기를 *size*로 설정합니다.

   버전 3.9에 추가.

PyObject_HEAD_INIT(type)

   이것은 새로운 "PyObject" 형의 초기화 값으로 확장되는 매크로입니다.
   이 매크로는 다음으로 확장됩니다:

      _PyObject_EXTRA_INIT
      1, type,

PyVarObject_HEAD_INIT(type, size)

   This is a macro which expands to initialization values for a new
   "PyVarObject" type, including the "ob_size" field. This macro
   expands to:

      _PyObject_EXTRA_INIT
      1, type, size,


함수와 메서드 구현
==================

type PyCFunction
    * Part of the Stable ABI.*

   대부분 파이썬 콜러블을 C로 구현하는 데 사용되는 함수 형. 이 형의 함
   수는 두 개의 "PyObject*" 매개 변수를 취하고 하나의 값을 반환합니다.
   반환 값이 *NULL*이면, 예외가 설정되어 있어야 합니다. "NULL"이 아니
   면, 반환 값은 파이썬에 노출된 함수의 반환 값으로 해석됩니다. 함수는
   새로운 참조를 반환해야 합니다.

   함수 서명은 다음과 같습니다:

      PyObject *PyCFunction(PyObject *self,
                            PyObject *args);

type PyCFunctionWithKeywords
    * Part of the Stable ABI.*

   Type of the functions used to implement Python callables in C with
   signature "METH_VARARGS | METH_KEYWORDS". The function signature
   is:

      PyObject *PyCFunctionWithKeywords(PyObject *self,
                                        PyObject *args,
                                        PyObject *kwargs);

type _PyCFunctionFast

   Type of the functions used to implement Python callables in C with
   signature "METH_FASTCALL". The function signature is:

      PyObject *_PyCFunctionFast(PyObject *self,
                                 PyObject *const *args,
                                 Py_ssize_t nargs);

type _PyCFunctionFastWithKeywords

   Type of the functions used to implement Python callables in C with
   signature "METH_FASTCALL | METH_KEYWORDS". The function signature
   is:

      PyObject *_PyCFunctionFastWithKeywords(PyObject *self,
                                             PyObject *const *args,
                                             Py_ssize_t nargs,
                                             PyObject *kwnames);

type PyCMethod

   Type of the functions used to implement Python callables in C with
   signature "METH_METHOD | METH_FASTCALL | METH_KEYWORDS". The
   function signature is:

      PyObject *PyCMethod(PyObject *self,
                          PyTypeObject *defining_class,
                          PyObject *const *args,
                          Py_ssize_t nargs,
                          PyObject *kwnames)

   버전 3.9에 추가.

type PyMethodDef
    * Part of the Stable ABI (including all members).*

   확장형의 메서드를 기술하는 데 사용되는 구조체. 이 구조체에는 네 개
   의 필드가 있습니다:

   const char *ml_name

      name of the method

   PyCFunction ml_meth

      pointer to the C implementation

   int ml_flags

      flags bits indicating how the call should be constructed

   const char *ml_doc

      points to the contents of the docstring

The "ml_meth" is a C function pointer.  The functions may be of
different types, but they always return "PyObject*".  If the function
is not of the "PyCFunction", the compiler will require a cast in the
method table. Even though "PyCFunction" defines the first parameter as
"PyObject*", it is common that the method implementation uses the
specific C type of the *self* object.

The "ml_flags" field is a bitfield which can include the following
flags. The individual flags indicate either a calling convention or a
binding convention.

다음과 같은 호출 규칙이 있습니다:

METH_VARARGS

   이는 메서드가 "PyCFunction" 형인 일반적인 호출 규칙입니다. 함수는
   두 개의 "PyObject*" 값을 기대합니다. 첫 번째는 메서드의 *self* 객체
   입니다; 모듈 함수의 경우, 모듈 객체입니다. 두 번째 매개 변수(종종
   *args*라고 합니다)는 모든 인자를 나타내는 튜플 객체입니다. 이 매개
   변수는 일반적으로 "PyArg_ParseTuple()"이나 "PyArg_UnpackTuple()"을
   사용하여 처리됩니다.

METH_VARARGS | METH_KEYWORDS

   이러한 플래그가 있는 메서드는 "PyCFunctionWithKeywords" 형이어야 합
   니다. 이 함수는 세 개의 매개 변수를 기대합니다: *self*, *args*,
   *kwargs*. 여기서 *kwargs*는 모든 키워드 인자의 딕셔너리이거나 키워
   드 인자가 없으면 "NULL"일 수 있습니다. 매개 변수는 일반적으로
   "PyArg_ParseTupleAndKeywords()"를 사용하여 처리됩니다.

METH_FASTCALL

   Fast calling convention supporting only positional arguments. The
   methods have the type "_PyCFunctionFast". The first parameter is
   *self*, the second parameter is a C array of "PyObject*" values
   indicating the arguments and the third parameter is the number of
   arguments (the length of the array).

   버전 3.7에 추가.

   버전 3.10에서 변경: "METH_FASTCALL" is now part of the stable ABI.

METH_FASTCALL | METH_KEYWORDS

   Extension of "METH_FASTCALL" supporting also keyword arguments,
   with methods of type "_PyCFunctionFastWithKeywords". Keyword
   arguments are passed the same way as in the vectorcall protocol:
   there is an additional fourth "PyObject*" parameter which is a
   tuple representing the names of the keyword arguments (which are
   guaranteed to be strings) or possibly "NULL" if there are no
   keywords.  The values of the keyword arguments are stored in the
   *args* array, after the positional arguments.

   버전 3.7에 추가.

METH_METHOD | METH_FASTCALL | METH_KEYWORDS

   Extension of "METH_FASTCALL | METH_KEYWORDS" supporting the
   *defining class*, that is, the class that contains the method in
   question. The defining class might be a superclass of
   "Py_TYPE(self)".

   메서드는 "PyCMethod" 형이어야 하는데, "self" 뒤에 "defining_class"
   인자가 추가된 "METH_FASTCALL | METH_KEYWORDS"와 같습니다.

   버전 3.9에 추가.

METH_NOARGS

   Methods without parameters don't need to check whether arguments
   are given if they are listed with the "METH_NOARGS" flag.  They
   need to be of type "PyCFunction".  The first parameter is typically
   named *self* and will hold a reference to the module or object
   instance.  In all cases the second parameter will be "NULL".

METH_O

   Methods with a single object argument can be listed with the
   "METH_O" flag, instead of invoking "PyArg_ParseTuple()" with a
   ""O"" argument. They have the type "PyCFunction", with the *self*
   parameter, and a "PyObject*" parameter representing the single
   argument.

이 두 상수는 호출 규칙을 나타내는 데 사용되지 않고 클래스의 메서드와
함께 사용할 때 바인딩을 나타냅니다. 모듈에 정의된 함수에는 사용할 수
없습니다. 이러한 플래그 중 최대 하나를 주어진 메서드에 대해 설정할 수
있습니다.

METH_CLASS

   메서드로 형의 인스턴스가 아닌 형 객체가 첫 번째 매개 변수로 전달됩
   니다. "classmethod()" 내장 함수를 사용할 때 만들어지는 것과 유사한
   *클래스 메서드(class methods)*를 만드는 데 사용됩니다.

METH_STATIC

   메서드로 형의 인스턴스가 아닌 "NULL"이 첫 번째 매개 변수로 전달됩니
   다. "staticmethod()" 내장 함수를 사용할 때 만들어지는 것과 유사한 *
   정적 메서드(static methods)*를 만드는 데 사용됩니다.

하나의 다른 상수는 같은 메서드 이름을 가진 다른 정의 대신 메서드가 로
드되는지를 제어합니다.

METH_COEXIST

   The method will be loaded in place of existing definitions.
   Without *METH_COEXIST*, the default is to skip repeated
   definitions.  Since slot wrappers are loaded before the method
   table, the existence of a *sq_contains* slot, for example, would
   generate a wrapped method named "__contains__()" and preclude the
   loading of a corresponding PyCFunction with the same name.  With
   the flag defined, the PyCFunction will be loaded in place of the
   wrapper object and will co-exist with the slot.  This is helpful
   because calls to PyCFunctions are optimized more than wrapper
   object calls.


확장형의 어트리뷰트 액세스
==========================

type PyMemberDef
    * Part of the Stable ABI (including all members).*

   Structure which describes an attribute of a type which corresponds
   to a C struct member.  Its fields are:

   +--------------------+-----------------+---------------------------------+
   | Field              | C Type          | Meaning                         |
   |====================|=================|=================================|
   | "name"             | const char *    | name of the member              |
   +--------------------+-----------------+---------------------------------+
   | "type"             | int             | the type of the member in the C |
   |                    |                 | struct                          |
   +--------------------+-----------------+---------------------------------+
   | "offset"           | Py_ssize_t      | the offset in bytes that the    |
   |                    |                 | member is located on the type's |
   |                    |                 | object struct                   |
   +--------------------+-----------------+---------------------------------+
   | "flags"            | int             | flag bits indicating if the     |
   |                    |                 | field should be read-only or    |
   |                    |                 | writable                        |
   +--------------------+-----------------+---------------------------------+
   | "doc"              | const char *    | points to the contents of the   |
   |                    |                 | docstring                       |
   +--------------------+-----------------+---------------------------------+

   "type" can be one of many "T_" macros corresponding to various C
   types.  When the member is accessed in Python, it will be converted
   to the equivalent Python type.

   +-----------------+--------------------+
   | 매크로 이름     | C 형               |
   |=================|====================|
   | T_SHORT         | short              |
   +-----------------+--------------------+
   | T_INT           | int                |
   +-----------------+--------------------+
   | T_LONG          | long               |
   +-----------------+--------------------+
   | T_FLOAT         | float              |
   +-----------------+--------------------+
   | T_DOUBLE        | double             |
   +-----------------+--------------------+
   | T_STRING        | const char *       |
   +-----------------+--------------------+
   | T_OBJECT        | PyObject *         |
   +-----------------+--------------------+
   | T_OBJECT_EX     | PyObject *         |
   +-----------------+--------------------+
   | T_CHAR          | char               |
   +-----------------+--------------------+
   | T_BYTE          | char               |
   +-----------------+--------------------+
   | T_UBYTE         | unsigned char      |
   +-----------------+--------------------+
   | T_UINT          | unsigned int       |
   +-----------------+--------------------+
   | T_USHORT        | unsigned short     |
   +-----------------+--------------------+
   | T_ULONG         | unsigned long      |
   +-----------------+--------------------+
   | T_BOOL          | char               |
   +-----------------+--------------------+
   | T_LONGLONG      | long long          |
   +-----------------+--------------------+
   | T_ULONGLONG     | unsigned long long |
   +-----------------+--------------------+
   | T_PYSSIZET      | Py_ssize_t         |
   +-----------------+--------------------+

   "T_OBJECT" and "T_OBJECT_EX" differ in that "T_OBJECT" returns
   "None" if the member is "NULL" and "T_OBJECT_EX" raises an
   "AttributeError".  Try to use "T_OBJECT_EX" over "T_OBJECT" because
   "T_OBJECT_EX" handles use of the "del" statement on that attribute
   more correctly than "T_OBJECT".

   "flags" can be "0" for write and read access or "READONLY" for
   read-only access.  Using "T_STRING" for "type" implies "READONLY".
   "T_STRING" data is interpreted as UTF-8. Only "T_OBJECT" and
   "T_OBJECT_EX" members can be deleted.  (They are set to "NULL").

   Heap allocated types (created using "PyType_FromSpec()" or
   similar), "PyMemberDef" may contain definitions for the special
   members "__dictoffset__", "__weaklistoffset__" and
   "__vectorcalloffset__", corresponding to "tp_dictoffset",
   "tp_weaklistoffset" and "tp_vectorcall_offset" in type objects.
   These must be defined with "T_PYSSIZET" and "READONLY", for
   example:

      static PyMemberDef spam_type_members[] = {
          {"__dictoffset__", T_PYSSIZET, offsetof(Spam_object, dict), READONLY},
          {NULL}  /* Sentinel */
      };

PyObject *PyMember_GetOne(const char *obj_addr, struct PyMemberDef *m)

   Get an attribute belonging to the object at address *obj_addr*.
   The attribute is described by "PyMemberDef" *m*.  Returns "NULL" on
   error.

int PyMember_SetOne(char *obj_addr, struct PyMemberDef *m, PyObject *o)

   Set an attribute belonging to the object at address *obj_addr* to
   object *o*. The attribute to set is described by "PyMemberDef" *m*.
   Returns "0" if successful and a negative value on failure.

type PyGetSetDef
    * Part of the Stable ABI (including all members).*

   형에 대한 프로퍼티 같은 액세스를 정의하는 구조체.
   "PyTypeObject.tp_getset" 슬롯에 대한 설명도 참조하십시오.

   +---------------+--------------------+-------------------------------------+
   | Field         | C Type             | Meaning                             |
   |===============|====================|=====================================|
   | name          | const char *       | 어트리뷰트 이름                     |
   +---------------+--------------------+-------------------------------------+
   | get           | getter             | C function to get the attribute     |
   +---------------+--------------------+-------------------------------------+
   | set           | setter             | optional C function to set or       |
   |               |                    | delete the attribute, if omitted    |
   |               |                    | the attribute is readonly           |
   +---------------+--------------------+-------------------------------------+
   | doc           | const char *       | 선택적 독스트링                     |
   +---------------+--------------------+-------------------------------------+
   | closure       | void *             | optional function pointer,          |
   |               |                    | providing additional data for       |
   |               |                    | getter and setter                   |
   +---------------+--------------------+-------------------------------------+

   The "get" function takes one "PyObject*" parameter (the instance)
   and a function pointer (the associated "closure"):

      typedef PyObject *(*getter)(PyObject *, void *);

   성공하면 새 참조를 반환하고, 실패하면 설정된 예외와 함께 "NULL"을
   반환해야 합니다.

   "set" functions take two "PyObject*" parameters (the instance and
   the value to be set) and a function pointer (the associated
   "closure"):

      typedef int (*setter)(PyObject *, PyObject *, void *);

   어트리뷰트를 삭제해야 하는 경우 두 번째 매개 변수는 "NULL"입니다.
   성공하면 "0"을, 실패하면 설정된 예외와 함께 "-1"을 반환해야 합니다.
