Type Objects
************

Perhaps one of the most important structures of the Python object
system is the structure that defines a new type: the "PyTypeObject"
structure.  Type objects can be handled using any of the "PyObject_*"
or "PyType_*" functions, but do not offer much that's interesting to
most Python applications. These objects are fundamental to how objects
behave, so they are very important to the interpreter itself and to
any extension module that implements new types.

형 객체는 대부분 표준형보다 상당히 큽니다. 크기가 큰 이유는 각 형 객체
가 많은 수의 값을 저장하기 때문인데, 주로 C 함수 포인터이고 각기 형의
기능 중 작은 부분을 구현합니다. 이 섹션에서는 형 객체의 필드를 자세히
살펴봅니다. 필드는 구조체에서 나타나는 순서대로 설명됩니다.

다음의 간략 참조 외에도, 예 섹션은 "PyTypeObject"의 의미와 사용에 대한
통찰을 제공합니다.


간략 참조
=========


"tp 슬롯"
---------

+--------------------+--------------------+--------------------+----+----+----+----+
| PyTypeObject 슬롯  | 형                 | 특수 메서드/어트리 | 정보 [2]          |
| [1]                |                    | 뷰트               |                   |
|                    |                    |                    +----+----+----+----+
|                    |                    |                    | O  | T  | D  | I  |
|                    |                    |                    |    |    |    |    |
|====================|====================|====================|====|====|====|====|
| <R> "tp_name"      | const char *       | __name__           | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_basicsize"     | "Py_ssize_t"       |                    | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_itemsize"      | "Py_ssize_t"       |                    |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_dealloc"       | "destructor"       |                    | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_vectorcall_of  | "Py_ssize_t"       |                    |    | X  |    | X  |
| fset"              |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_getattr")     | "getattrfunc"      | __getattribute__,  |    |    |    | G  |
|                    |                    | __getattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_setattr")     | "setattrfunc"      | __setattr__,       |    |    |    | G  |
|                    |                    | __delattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_async"      | "PyAsyncMethods" * | 서브 슬롯          |    |    |    | %  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_repr"          | "reprfunc"         | __repr__           | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_number"     | "PyNumberMethods"  | 서브 슬롯          |    |    |    | %  |
|                    | *                  |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_sequence"   | "PySequenceMethod  | 서브 슬롯          |    |    |    | %  |
|                    | s" *               |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_mapping"    | "PyMappingMethods" | 서브 슬롯          |    |    |    | %  |
|                    | *                  |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_hash"          | "hashfunc"         | __hash__           | X  |    |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_call"          | "ternaryfunc"      | __call__           |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_str"           | "reprfunc"         | __str__            | X  |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_getattro"      | "getattrofunc"     | __getattribute__,  | X  | X  |    | G  |
|                    |                    | __getattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_setattro"      | "setattrofunc"     | __setattr__,       | X  | X  |    | G  |
|                    |                    | __delattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_buffer"     | "PyBufferProcs" *  |                    |    |    |    | %  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_flags"         | unsigned long      |                    | X  | X  |    | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_doc"           | const char *       | __doc__            | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_traverse"      | "traverseproc"     |                    |    | X  |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_clear"         | "inquiry"          |                    |    | X  |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_richcompare"   | "richcmpfunc"      | __lt__, __le__,    | X  |    |    | G  |
|                    |                    | __eq__, __ne__,    |    |    |    |    |
|                    |                    | __gt__, __ge__     |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_weaklistoffse  | "Py_ssize_t"       |                    |    | X  |    | ?  |
| t"                 |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_iter"          | "getiterfunc"      | __iter__           |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_iternext"      | "iternextfunc"     | __next__           |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_methods"       | "PyMethodDef" []   |                    | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_members"       | "PyMemberDef" []   |                    |    | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_getset"        | "PyGetSetDef" []   |                    | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_base"          | "PyTypeObject" *   | __base__           |    |    | X  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_dict"          | "PyObject" *       | __dict__           |    |    | ?  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_descr_get"     | "descrgetfunc"     | __get__            |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_descr_set"     | "descrsetfunc"     | __set__,           |    |    |    | X  |
|                    |                    | __delete__         |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_dictoffset"    | "Py_ssize_t"       |                    |    | X  |    | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_init"          | "initproc"         | __init__           | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_alloc"         | "allocfunc"        |                    | X  |    | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_new"           | "newfunc"          | __new__            | X  | X  | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_free"          | "freefunc"         |                    | X  | X  | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_is_gc"         | "inquiry"          |                    |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| <"tp_bases">       | "PyObject" *       | __bases__          |    |    | ~  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| <"tp_mro">         | "PyObject" *       | __mro__            |    |    | ~  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_cache"]       | "PyObject" *       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_subclasses"]  | "PyObject" *       | __subclasses__     |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_weaklist"]    | "PyObject" *       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_del")         | "destructor"       |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_version_tag"] | unsigned int       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_finalize"      | "destructor"       | __del__            |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_vectorcall"    | "vectorcallfunc"   |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+

[1] **()**: A slot name in parentheses indicates it is (effectively)
    deprecated.

    **<>**: Names in angle brackets should be initially set to "NULL"
    and treated as read-only.

    **[]**: Names in square brackets are for internal use only.

    **<R>** (as a prefix) means the field is required (must be
    non-"NULL").

[2] 열:

    **"O"**:  set on "PyBaseObject_Type"

    **"T"**:  set on "PyType_Type"

    **"D"**: 기본값 (슬롯이 "NULL"로 설정된 경우)

       X - PyType_Ready sets this value if it is NULL
       ~ - PyType_Ready always sets this value (it should be NULL)
       ? - PyType_Ready may set this value depending on other slots

       Also see the inheritance column ("I").

    **"I"**: 상속

       X - type slot is inherited via *PyType_Ready* if defined with a *NULL* value
       % - the slots of the sub-struct are inherited individually
       G - inherited, but only in combination with other slots; see the slot's description
       ? - it's complicated; see the slot's description

    일부 슬롯은 일반 어트리뷰트 조회 체인을 통해 효과적으로 상속됨에
    유의하십시오.


서브 슬롯
---------

+----------------------------+-------------------+--------------+
| 슬롯                       | 형                | 특수 메서드  |
|============================|===================|==============|
| "am_await"                 | "unaryfunc"       | __await__    |
+----------------------------+-------------------+--------------+
| "am_aiter"                 | "unaryfunc"       | __aiter__    |
+----------------------------+-------------------+--------------+
| "am_anext"                 | "unaryfunc"       | __anext__    |
+----------------------------+-------------------+--------------+
| "am_send"                  | "sendfunc"        |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "nb_add"                   | "binaryfunc"      | __add__      |
|                            |                   | __radd__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_add"           | "binaryfunc"      | __iadd__     |
+----------------------------+-------------------+--------------+
| "nb_subtract"              | "binaryfunc"      | __sub__      |
|                            |                   | __rsub__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_subtract"      | "binaryfunc"      | __isub__     |
+----------------------------+-------------------+--------------+
| "nb_multiply"              | "binaryfunc"      | __mul__      |
|                            |                   | __rmul__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_multiply"      | "binaryfunc"      | __imul__     |
+----------------------------+-------------------+--------------+
| "nb_remainder"             | "binaryfunc"      | __mod__      |
|                            |                   | __rmod__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_remainder"     | "binaryfunc"      | __imod__     |
+----------------------------+-------------------+--------------+
| "nb_divmod"                | "binaryfunc"      | __divmod__   |
|                            |                   | __rdivmod__  |
+----------------------------+-------------------+--------------+
| "nb_power"                 | "ternaryfunc"     | __pow__      |
|                            |                   | __rpow__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_power"         | "ternaryfunc"     | __ipow__     |
+----------------------------+-------------------+--------------+
| "nb_negative"              | "unaryfunc"       | __neg__      |
+----------------------------+-------------------+--------------+
| "nb_positive"              | "unaryfunc"       | __pos__      |
+----------------------------+-------------------+--------------+
| "nb_absolute"              | "unaryfunc"       | __abs__      |
+----------------------------+-------------------+--------------+
| "nb_bool"                  | "inquiry"         | __bool__     |
+----------------------------+-------------------+--------------+
| "nb_invert"                | "unaryfunc"       | __invert__   |
+----------------------------+-------------------+--------------+
| "nb_lshift"                | "binaryfunc"      | __lshift__   |
|                            |                   | __rlshift__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_lshift"        | "binaryfunc"      | __ilshift__  |
+----------------------------+-------------------+--------------+
| "nb_rshift"                | "binaryfunc"      | __rshift__   |
|                            |                   | __rrshift__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_rshift"        | "binaryfunc"      | __irshift__  |
+----------------------------+-------------------+--------------+
| "nb_and"                   | "binaryfunc"      | __and__      |
|                            |                   | __rand__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_and"           | "binaryfunc"      | __iand__     |
+----------------------------+-------------------+--------------+
| "nb_xor"                   | "binaryfunc"      | __xor__      |
|                            |                   | __rxor__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_xor"           | "binaryfunc"      | __ixor__     |
+----------------------------+-------------------+--------------+
| "nb_or"                    | "binaryfunc"      | __or__       |
|                            |                   | __ror__      |
+----------------------------+-------------------+--------------+
| "nb_inplace_or"            | "binaryfunc"      | __ior__      |
+----------------------------+-------------------+--------------+
| "nb_int"                   | "unaryfunc"       | __int__      |
+----------------------------+-------------------+--------------+
| "nb_reserved"              | void *            |              |
+----------------------------+-------------------+--------------+
| "nb_float"                 | "unaryfunc"       | __float__    |
+----------------------------+-------------------+--------------+
| "nb_floor_divide"          | "binaryfunc"      | __floordiv__ |
+----------------------------+-------------------+--------------+
| "nb_inplace_floor_divide"  | "binaryfunc"      | __ifloordiv  |
|                            |                   | __           |
+----------------------------+-------------------+--------------+
| "nb_true_divide"           | "binaryfunc"      | __truediv__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_true_divide"   | "binaryfunc"      | __itruediv__ |
+----------------------------+-------------------+--------------+
| "nb_index"                 | "unaryfunc"       | __index__    |
+----------------------------+-------------------+--------------+
| "nb_matrix_multiply"       | "binaryfunc"      | __matmul__   |
|                            |                   | __rmatmul__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_matrix_multip  | "binaryfunc"      | __imatmul__  |
| ly"                        |                   |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "mp_length"                | "lenfunc"         | __len__      |
+----------------------------+-------------------+--------------+
| "mp_subscript"             | "binaryfunc"      | __getitem__  |
+----------------------------+-------------------+--------------+
| "mp_ass_subscript"         | "objobjargproc"   | __setitem__, |
|                            |                   | __delitem__  |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "sq_length"                | "lenfunc"         | __len__      |
+----------------------------+-------------------+--------------+
| "sq_concat"                | "binaryfunc"      | __add__      |
+----------------------------+-------------------+--------------+
| "sq_repeat"                | "ssizeargfunc"    | __mul__      |
+----------------------------+-------------------+--------------+
| "sq_item"                  | "ssizeargfunc"    | __getitem__  |
+----------------------------+-------------------+--------------+
| "sq_ass_item"              | "ssizeobjargproc" | __setitem__  |
|                            |                   | __delitem__  |
+----------------------------+-------------------+--------------+
| "sq_contains"              | "objobjproc"      | __contains__ |
+----------------------------+-------------------+--------------+
| "sq_inplace_concat"        | "binaryfunc"      | __iadd__     |
+----------------------------+-------------------+--------------+
| "sq_inplace_repeat"        | "ssizeargfunc"    | __imul__     |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "bf_getbuffer"             | "getbufferproc()" |              |
+----------------------------+-------------------+--------------+
| "bf_releasebuffer"         | "releasebufferpr  |              |
|                            | oc()"             |              |
+----------------------------+-------------------+--------------+


슬롯 typedef
------------

+-------------------------------+-------------------------------+------------------------+
| typedef                       | 매개 변수 형                  | 반환형                 |
|===============================|===============================|========================|
| "allocfunc"                   | "PyTypeObject" * "Py_ssize_t" | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "destructor"                  | void *                        | void                   |
+-------------------------------+-------------------------------+------------------------+
| "freefunc"                    | void *                        | void                   |
+-------------------------------+-------------------------------+------------------------+
| "traverseproc"                | void * "visitproc" void *     | int                    |
+-------------------------------+-------------------------------+------------------------+
| "newfunc"                     | "PyObject" * "PyObject" *     | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "initproc"                    | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "reprfunc"                    | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "getattrfunc"                 | "PyObject" * const char *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "setattrfunc"                 | "PyObject" * const char *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "getattrofunc"                | "PyObject" * "PyObject" *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "setattrofunc"                | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "descrgetfunc"                | "PyObject" * "PyObject" *     | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "descrsetfunc"                | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "hashfunc"                    | "PyObject" *                  | Py_hash_t              |
+-------------------------------+-------------------------------+------------------------+
| "richcmpfunc"                 | "PyObject" * "PyObject" * int | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "getiterfunc"                 | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "iternextfunc"                | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "lenfunc"                     | "PyObject" *                  | "Py_ssize_t"           |
+-------------------------------+-------------------------------+------------------------+
| "getbufferproc"               | "PyObject" * "Py_buffer" *    | int                    |
|                               | int                           |                        |
+-------------------------------+-------------------------------+------------------------+
| "releasebufferproc"           | "PyObject" * "Py_buffer" *    | void                   |
+-------------------------------+-------------------------------+------------------------+
| "inquiry"                     | void *                        | int                    |
+-------------------------------+-------------------------------+------------------------+
| "unaryfunc"                   | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "binaryfunc"                  | "PyObject" * "PyObject" *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "ternaryfunc"                 | "PyObject" * "PyObject" *     | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "ssizeargfunc"                | "PyObject" * "Py_ssize_t"     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "ssizeobjargproc"             | "PyObject" * "Py_ssize_t"     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "objobjproc"                  | "PyObject" * "PyObject" *     | int                    |
+-------------------------------+-------------------------------+------------------------+
| "objobjargproc"               | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+

자세한 내용은 아래 슬롯 형 typedef를 참조하십시오.


PyTypeObject 정의
=================

The structure definition for "PyTypeObject" can be found in
"Include/object.h".  For convenience of reference, this repeats the
definition found there:

   typedef struct _typeobject {
       PyObject_VAR_HEAD
       const char *tp_name; /* For printing, in format "<module>.<name>" */
       Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

       /* Methods to implement standard operations */

       destructor tp_dealloc;
       Py_ssize_t tp_vectorcall_offset;
       getattrfunc tp_getattr;
       setattrfunc tp_setattr;
       PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                       or tp_reserved (Python 3) */
       reprfunc tp_repr;

       /* Method suites for standard classes */

       PyNumberMethods *tp_as_number;
       PySequenceMethods *tp_as_sequence;
       PyMappingMethods *tp_as_mapping;

       /* More standard operations (here for binary compatibility) */

       hashfunc tp_hash;
       ternaryfunc tp_call;
       reprfunc tp_str;
       getattrofunc tp_getattro;
       setattrofunc tp_setattro;

       /* Functions to access object as input/output buffer */
       PyBufferProcs *tp_as_buffer;

       /* Flags to define presence of optional/expanded features */
       unsigned long tp_flags;

       const char *tp_doc; /* Documentation string */

       /* Assigned meaning in release 2.0 */
       /* call function for all accessible objects */
       traverseproc tp_traverse;

       /* delete references to contained objects */
       inquiry tp_clear;

       /* Assigned meaning in release 2.1 */
       /* rich comparisons */
       richcmpfunc tp_richcompare;

       /* weak reference enabler */
       Py_ssize_t tp_weaklistoffset;

       /* Iterators */
       getiterfunc tp_iter;
       iternextfunc tp_iternext;

       /* Attribute descriptor and subclassing stuff */
       struct PyMethodDef *tp_methods;
       struct PyMemberDef *tp_members;
       struct PyGetSetDef *tp_getset;
       // Strong reference on a heap type, borrowed reference on a static type
       struct _typeobject *tp_base;
       PyObject *tp_dict;
       descrgetfunc tp_descr_get;
       descrsetfunc tp_descr_set;
       Py_ssize_t tp_dictoffset;
       initproc tp_init;
       allocfunc tp_alloc;
       newfunc tp_new;
       freefunc tp_free; /* Low-level free-memory routine */
       inquiry tp_is_gc; /* For PyObject_IS_GC */
       PyObject *tp_bases;
       PyObject *tp_mro; /* method resolution order */
       PyObject *tp_cache;
       PyObject *tp_subclasses;
       PyObject *tp_weaklist;
       destructor tp_del;

       /* Type attribute cache version tag. Added in version 2.6 */
       unsigned int tp_version_tag;

       destructor tp_finalize;
       vectorcallfunc tp_vectorcall;
   } PyTypeObject;


PyObject 슬롯
=============

The type object structure extends the "PyVarObject" structure. The
"ob_size" field is used for dynamic types (created by "type_new()",
usually called from a class statement). Note that "PyType_Type" (the
metatype) initializes "tp_itemsize", which means that its instances
(i.e. type objects) *must* have the "ob_size" field.

Py_ssize_t PyObject.ob_refcnt
    * Part of the Stable ABI.*

   This is the type object's reference count, initialized to "1" by
   the "PyObject_HEAD_INIT" macro.  Note that for statically allocated
   type objects, the type's instances (objects whose "ob_type" points
   back to the type) do *not* count as references.  But for
   dynamically allocated type objects, the instances *do* count as
   references.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.

PyTypeObject *PyObject.ob_type
    * Part of the Stable ABI.*

   이것은 형의 형, 즉 메타 형(metatype)입니다. "PyObject_HEAD_INIT" 매
   크로에 대한 인자로 초기화되며, 값은 일반적으로 "&PyType_Type"이어야
   합니다. 그러나, (적어도) 윈도우에서 사용 가능해야 하는 동적으로 로
   드 가능한 확장 모듈의 경우, 컴파일러는 유효한 초기화자가 아니라고
   불평합니다. 따라서, 규칙은 "NULL"을 "PyObject_HEAD_INIT" 매크로로
   전달하고, 다른 작업을 수행하기 전에 모듈의 초기화 함수 시작에서 필
   드를 명시적으로 초기화하는 것입니다. 이것은 일반적으로 다음과 같이
   수행됩니다:

      Foo_Type.ob_type = &PyType_Type;

   This should be done before any instances of the type are created.
   "PyType_Ready()" checks if "ob_type" is "NULL", and if so,
   initializes it to the "ob_type" field of the base class.
   "PyType_Ready()" will not change this field if it is non-zero.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

PyObject *PyObject._ob_next
PyObject *PyObject._ob_prev

   These fields are only present when the macro "Py_TRACE_REFS" is
   defined (see the "configure --with-trace-refs option").

   Their initialization to "NULL" is taken care of by the
   "PyObject_HEAD_INIT" macro.  For statically allocated objects,
   these fields always remain "NULL".  For dynamically allocated
   objects, these two fields are used to link the object into a doubly
   linked list of *all* live objects on the heap.

   This could be used for various debugging purposes; currently the
   only uses are the "sys.getobjects()" function and to print the
   objects that are still alive at the end of a run when the
   environment variable "PYTHONDUMPREFS" is set.

   **계승:**

   These fields are not inherited by subtypes.


PyVarObject 슬롯
================

Py_ssize_t PyVarObject.ob_size
    * Part of the Stable ABI.*

   For statically allocated type objects, this should be initialized
   to zero. For dynamically allocated type objects, this field has a
   special internal meaning.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.


PyTypeObject 슬롯
=================

Each slot has a section describing inheritance.  If "PyType_Ready()"
may set a value when the field is set to "NULL" then there will also
be a "Default" section.  (Note that many fields set on
"PyBaseObject_Type" and "PyType_Type" effectively act as defaults.)

const char *PyTypeObject.tp_name

   Pointer to a NUL-terminated string containing the name of the type.
   For types that are accessible as module globals, the string should
   be the full module name, followed by a dot, followed by the type
   name; for built-in types, it should be just the type name.  If the
   module is a submodule of a package, the full package name is part
   of the full module name.  For example, a type named "T" defined in
   module "M" in subpackage "Q" in package "P" should have the
   "tp_name" initializer ""P.Q.M.T"".

   For dynamically allocated type objects, this should just be the
   type name, and the module name explicitly stored in the type dict
   as the value for key "'__module__'".

   For statically allocated type objects, the *tp_name* field should
   contain a dot. Everything before the last dot is made accessible as
   the "__module__" attribute, and everything after the last dot is
   made accessible as the "__name__" attribute.

   If no dot is present, the entire "tp_name" field is made accessible
   as the "__name__" attribute, and the "__module__" attribute is
   undefined (unless explicitly set in the dictionary, as explained
   above).  This means your type will be impossible to pickle.
   Additionally, it will not be listed in module documentations
   created with pydoc.

   이 필드는 "NULL"이 아니어야 합니다. "PyTypeObject()"에서 유일하게
   필요한 필드입니다 (잠재적인 "tp_itemsize"를 제외하고).

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.

Py_ssize_t PyTypeObject.tp_basicsize
Py_ssize_t PyTypeObject.tp_itemsize

   이 필드를 사용하면 형 인스턴스의 크기를 바이트 단위로 계산할 수 있
   습니다.

   There are two kinds of types: types with fixed-length instances
   have a zero "tp_itemsize" field, types with variable-length
   instances have a non-zero "tp_itemsize" field.  For a type with
   fixed-length instances, all instances have the same size, given in
   "tp_basicsize".

   For a type with variable-length instances, the instances must have
   an "ob_size" field, and the instance size is "tp_basicsize" plus N
   times "tp_itemsize", where N is the "length" of the object.  The
   value of N is typically stored in the instance's "ob_size" field.
   There are exceptions:  for example, ints use a negative "ob_size"
   to indicate a negative number, and N is "abs(ob_size)" there.
   Also, the presence of an "ob_size" field in the instance layout
   doesn't mean that the instance structure is variable-length (for
   example, the structure for the list type has fixed-length
   instances, yet those instances have a meaningful "ob_size" field).

   The basic size includes the fields in the instance declared by the
   macro "PyObject_HEAD" or "PyObject_VAR_HEAD" (whichever is used to
   declare the instance struct) and this in turn includes the
   "_ob_prev" and "_ob_next" fields if they are present.  This means
   that the only correct way to get an initializer for the
   "tp_basicsize" is to use the "sizeof" operator on the struct used
   to declare the instance layout. The basic size does not include the
   GC header size.

   A note about alignment: if the variable items require a particular
   alignment, this should be taken care of by the value of
   "tp_basicsize".  Example: suppose a type implements an array of
   "double". "tp_itemsize" is "sizeof(double)". It is the programmer's
   responsibility that "tp_basicsize" is a multiple of
   "sizeof(double)" (assuming this is the alignment requirement for
   "double").

   For any type with variable-length instances, this field must not be
   "NULL".

   **계승:**

   These fields are inherited separately by subtypes.  If the base
   type has a non-zero "tp_itemsize", it is generally not safe to set
   "tp_itemsize" to a different non-zero value in a subtype (though
   this depends on the implementation of the base type).

destructor PyTypeObject.tp_dealloc

   인스턴스 파괴자(destructor) 함수에 대한 포인터. (싱글톤 "None"과
   "Ellipsis"의 경우처럼) 형이 해당 인스턴스가 할당 해제되지 않도록 보
   장하지 않는 한, 이 함수를 정의해야 합니다. 함수 서명은 다음과 같습
   니다:

      void tp_dealloc(PyObject *self);

   The destructor function is called by the "Py_DECREF()" and
   "Py_XDECREF()" macros when the new reference count is zero.  At
   this point, the instance is still in existence, but there are no
   references to it.  The destructor function should free all
   references which the instance owns, free all memory buffers owned
   by the instance (using the freeing function corresponding to the
   allocation function used to allocate the buffer), and call the
   type's "tp_free" function.  If the type is not subtypable (doesn't
   have the "Py_TPFLAGS_BASETYPE" flag bit set), it is permissible to
   call the object deallocator directly instead of via "tp_free".  The
   object deallocator should be the one used to allocate the instance;
   this is normally "PyObject_Del()" if the instance was allocated
   using "PyObject_New()" or "PyObject_VarNew()", or
   "PyObject_GC_Del()" if the instance was allocated using
   "PyObject_GC_New()" or "PyObject_GC_NewVar()".

   If the type supports garbage collection (has the
   "Py_TPFLAGS_HAVE_GC" flag bit set), the destructor should call
   "PyObject_GC_UnTrack()" before clearing any member fields.

      static void foo_dealloc(foo_object *self) {
          PyObject_GC_UnTrack(self);
          Py_CLEAR(self->ref);
          Py_TYPE(self)->tp_free((PyObject *)self);
      }

   Finally, if the type is heap allocated ("Py_TPFLAGS_HEAPTYPE"), the
   deallocator should release the owned reference to its type object
   (via "Py_DECREF()")  after calling the type deallocator. In order
   to avoid dangling pointers, the recommended way to achieve this is:

      static void foo_dealloc(foo_object *self) {
          PyTypeObject *tp = Py_TYPE(self);
          // free references and buffers here
          tp->tp_free(self);
          Py_DECREF(tp);
      }

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

Py_ssize_t PyTypeObject.tp_vectorcall_offset

   간단한 "tp_call"의 더 효율적인 대안인 벡터콜(vectorcall) 프로토콜을
   사용하여 객체를 호출하는 것을 구현하는 인스턴스별 함수에 대한 선택
   적 오프셋입니다.

   This field is only used if the flag "Py_TPFLAGS_HAVE_VECTORCALL" is
   set. If so, this must be a positive integer containing the offset
   in the instance of a "vectorcallfunc" pointer.

   The *vectorcallfunc* pointer may be "NULL", in which case the
   instance behaves as if "Py_TPFLAGS_HAVE_VECTORCALL" was not set:
   calling the instance falls back to "tp_call".

   "Py_TPFLAGS_HAVE_VECTORCALL"을 설정하는 모든 클래스는 "tp_call"도
   설정해야 하고, 해당 동작이 *vectorcallfunc* 함수와 일관되도록 만들
   어야 합니다. *tp_call*을 "PyVectorcall_Call()"로 설정하면 됩니다:

   경고:

     It is not recommended for heap types to implement the vectorcall
     protocol. When a user sets "__call__" in Python code, only
     *tp_call* is updated, likely making it inconsistent with the
     vectorcall function.

   버전 3.8에서 변경: 버전 3.8 이전에는, 이 슬롯의 이름이 "tp_print"였
   습니다. 파이썬 2.x에서는, 파일로 인쇄하는 데 사용되었습니다. 파이썬
   3.0에서 3.7까지는, 사용되지 않았습니다.

   **계승:**

   This field is always inherited. However, the
   "Py_TPFLAGS_HAVE_VECTORCALL" flag is not always inherited. If it's
   not, then the subclass won't use vectorcall, except when
   "PyVectorcall_Call()" is explicitly called. This is in particular
   the case for heap types (including subclasses defined in Python).

getattrfunc PyTypeObject.tp_getattr

   get-attribute-string 함수에 대한 선택적 포인터.

   이 필드는 폐지되었습니다. 정의될 때, "tp_getattro" 함수와 같게 작동
   하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C
   문자열을 받아들이는 함수를 가리켜야 합니다.

   **계승:**

   Group: "tp_getattr", "tp_getattro"

   이 필드는 "tp_getattro"와 함께 서브 형에 의해 상속됩니다: 서브 형은
   서브 형의 "tp_getattr"과 "tp_getattro"가 모두 "NULL"일 때 베이스형
   에서 "tp_getattr"과 "tp_getattro"를 모두 상속합니다.

setattrfunc PyTypeObject.tp_setattr

   어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.

   이 필드는 폐지되었습니다. 정의될 때, "tp_setattro" 함수와 같게 작동
   하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C
   문자열을 받아들이는 함수를 가리켜야 합니다.

   **계승:**

   Group: "tp_setattr", "tp_setattro"

   이 필드는 "tp_setattro"와 함께 서브 형에 의해 상속됩니다. 서브 형은
   서브 형의 "tp_setattr"과 "tp_setattro"가 모두 "NULL"일 때 베이스형
   에서 "tp_setattr"과 "tp_setattro"를 모두 상속합니다.

PyAsyncMethods *PyTypeObject.tp_as_async

   C 수준에서 *어웨이터블*과 *비동기 이터레이터* 프로토콜을 구현하는
   객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 자세한
   내용은 비동기 객체 구조체를 참조하십시오.

   버전 3.5에 추가: 이전에는 "tp_compare"와 "tp_reserved"라고 했습니다
   .

   **계승:**

   "tp_as_async" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속
   됩니다.

reprfunc PyTypeObject.tp_repr

   내장 함수 "repr()"을 구현하는 함수에 대한 선택적 포인터.

   서명은 "PyObject_Repr()"과 같습니다:

      PyObject *tp_repr(PyObject *self);

   함수는 문자열이나 유니코드 객체를 반환해야 합니다. 이상적으로, 이
   함수는 "eval()"에 전달될 때 적합한 환경이 주어지면 같은 값을 가진
   객체를 반환하는 문자열을 반환해야 합니다. 이것이 가능하지 않으면,
   "'<'"로 시작하고 "'>'"로 끝나는 문자열을 반환해야 하는데, 이 문자열
   에서 객체의 형과 값을 모두 추론할 수 있어야 합니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   이 필드를 설정하지 않으면, "<%s object at %p>" 형식의 문자열이 반환
   됩니다. 여기서 "%s"는 형 이름으로, "%p"는 객체의 메모리 주소로 치환
   됩니다.

PyNumberMethods *PyTypeObject.tp_as_number

   숫자 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조
   체에 대한 포인터. 이 필드는 숫자 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_number" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

PySequenceMethods *PyTypeObject.tp_as_sequence

   시퀀스 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구
   조체에 대한 포인터. 이 필드는 시퀀스 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_sequence" 필드는 상속되지 않지만, 포함된 필드는 개별적으로
   상속됩니다.

PyMappingMethods *PyTypeObject.tp_as_mapping

   매핑 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조
   체에 대한 포인터. 이 필드는 매핑 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_mapping" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

hashfunc PyTypeObject.tp_hash

   내장 함수 "hash()"를 구현하는 함수에 대한 선택적 포인터.

   서명은 "PyObject_Hash()"와 같습니다:

      Py_hash_t tp_hash(PyObject *);

   "-1" 값은 정상적인 반환 값으로 반환되지 않아야 합니다; 해시값을 계
   산하는 동안 에러가 발생하면 함수는 예외를 설정하고 "-1"을 반환해야
   합니다.

   When this field is not set (*and* "tp_richcompare" is not set), an
   attempt to take the hash of the object raises "TypeError". This is
   the same as setting it to "PyObject_HashNotImplemented()".

   이 필드는 부모 형에서 해시 메서드의 상속을 차단하기 위해
   "PyObject_HashNotImplemented()"로 명시적으로 설정할 수 있습니다. 이
   것은 파이썬 수준에서의 "__hash__ = None"과 동등한 것으로 해석되어,
   "isinstance(o, collections.Hashable)"이 "False"를 올바르게 반환하게
   합니다. 반대의 경우도 마찬가지입니다 - 파이썬 수준의 클래스에서
   "__hash__ = None"을 설정하면 "tp_hash" 슬롯이
   "PyObject_HashNotImplemented()"로 설정됩니다.

   **계승:**

   Group: "tp_hash", "tp_richcompare"

   이 필드는 "tp_richcompare"와 함께 서브 형에 의해 상속됩니다: 서브
   형의 "tp_richcompare"와 "tp_hash"가 모두 "NULL"일 때, 서브 형은
   "tp_richcompare"와 "tp_hash"를 모두 상속합니다.

ternaryfunc PyTypeObject.tp_call

   객체 호출을 구현하는 함수에 대한 선택적 포인터. 객체가 콜러블이 아
   니면 "NULL"이어야 합니다. 서명은 "PyObject_Call()"과 같습니다:

      PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

reprfunc PyTypeObject.tp_str

   내장 연산 "str()"을 구현하는 함수에 대한 선택적 포인터. ("str"는 이
   제 형이며, "str()"은 그 형의 생성자를 호출함에 유의하십시오. 이 생
   성자는 "PyObject_Str()"를 호출하여 실제 작업을 수행하고,
   "PyObject_Str()"은 이 처리기를 호출합니다.)

   서명은 "PyObject_Str()"과 같습니다:

      PyObject *tp_str(PyObject *self);

   함수는 문자열이나 유니코드 객체를 반환해야 합니다. 다른 것 중에서도
   , "print()" 함수에 의해 사용될 표현이기 때문에, 객체의 "친숙한" 문
   자열 표현이어야 합니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   이 필드를 설정하지 않으면, 문자열 표현을 반환하기 위해
   "PyObject_Repr()"이 호출됩니다.

getattrofunc PyTypeObject.tp_getattro

   어트리뷰트 읽기(get-attribute) 함수에 대한 선택적 포인터.

   서명은 "PyObject_GetAttr()"과 같습니다:

      PyObject *tp_getattro(PyObject *self, PyObject *attr);

   일반적으로 이 필드를 "PyObject_GenericGetAttr()"로 설정하는 것이 편
   리합니다, 객체 어트리뷰트를 찾는 일반적인 방법을 구현합니다.

   **계승:**

   Group: "tp_getattr", "tp_getattro"

   이 필드는 "tp_getattr"과 함께 서브 형에 의해 상속됩니다: 서브 형의
   "tp_getattr"과 "tp_getattro"가 모두 "NULL"일 때 서브 형은 베이스형
   에서 "tp_getattr"과 "tp_getattro"를 모두 상속합니다.

   **기본값:**

   "PyBaseObject_Type" uses "PyObject_GenericGetAttr()".

setattrofunc PyTypeObject.tp_setattro

   어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.

   서명은 "PyObject_SetAttr()"과 같습니다:

      int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);

   또한, *value*를 "NULL"로 설정하여 어트리뷰트를 삭제하는 것을 반드시
   지원해야 합니다. 일반적으로 이 필드를 "PyObject_GenericSetAttr()"로
   설정하는 것이 편리합니다, 객체 어트리뷰트를 설정하는 일반적인 방법
   을 구현합니다.

   **계승:**

   Group: "tp_setattr", "tp_setattro"

   이 필드는 "tp_setattr"과 함께 서브 형에 의해 상속됩니다: 서브 형의
   "tp_setattr"과 "tp_setattro"가 모두 "NULL"일 때, 서브 형은 베이스형
   에서 "tp_setattr"과 "tp_setattro"를 모두 상속합니다.

   **기본값:**

   "PyBaseObject_Type" uses "PyObject_GenericSetAttr()".

PyBufferProcs *PyTypeObject.tp_as_buffer

   버퍼 인터페이스를 구현하는 객체에만 관련된 필드를 포함하는 추가 구
   조체에 대한 포인터. 이 필드는 버퍼 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_buffer" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

unsigned long PyTypeObject.tp_flags

   이 필드는 다양한 플래그의 비트 마스크입니다. 일부 플래그는 특정 상
   황에 대한 변형 의미론을 나타냅니다; 다른 것들은 역사적으로 항상 존
   재하지는 않았던 형 객체(또는 "tp_as_number", "tp_as_sequence",
   "tp_as_mapping" 및 "tp_as_buffer"를 통해 참조되는 확장 구조체)의 특
   정 필드가 유효함을 나타내는 데 사용됩니다; 이러한 플래그 비트가 없
   으면, 이것이 보호하는 형 필드에 액세스하지 말아야 하며 대신 0이나
   "NULL" 값을 갖는 것으로 간주해야 합니다.

   **계승:**

   Inheritance of this field is complicated.  Most flag bits are
   inherited individually, i.e. if the base type has a flag bit set,
   the subtype inherits this flag bit.  The flag bits that pertain to
   extension structures are strictly inherited if the extension
   structure is inherited, i.e. the base type's value of the flag bit
   is copied into the subtype together with a pointer to the extension
   structure.  The "Py_TPFLAGS_HAVE_GC" flag bit is inherited together
   with the "tp_traverse" and "tp_clear" fields, i.e. if the
   "Py_TPFLAGS_HAVE_GC" flag bit is clear in the subtype and the
   "tp_traverse" and "tp_clear" fields in the subtype exist and have
   "NULL" values.

   **기본값:**

   "PyBaseObject_Type" uses "Py_TPFLAGS_DEFAULT |
   Py_TPFLAGS_BASETYPE".

   **비트 마스크:**

   다음 비트 마스크가 현재 정의되어 있습니다; 이들은 "|" 연산자로 함께
   OR 하여 "tp_flags" 필드의 값을 형성할 수 있습니다. 매크로
   "PyType_HasFeature()"는 형과 플래그 값 *tp*와 *f*를 취하고
   "tp->tp_flags & f"가 0이 아닌지 확인합니다.

   Py_TPFLAGS_HEAPTYPE

      This bit is set when the type object itself is allocated on the
      heap, for example, types created dynamically using
      "PyType_FromSpec()".  In this case, the "ob_type" field of its
      instances is considered a reference to the type, and the type
      object is INCREF'ed when a new instance is created, and
      DECREF'ed when an instance is destroyed (this does not apply to
      instances of subtypes; only the type referenced by the
      instance's ob_type gets INCREF'ed or DECREF'ed).

      **계승:**

      ???

   Py_TPFLAGS_BASETYPE

      이 비트는 형을 다른 형의 베이스형으로 사용할 수 있을 때 설정됩니
      다. 이 비트가 설정되지 않으면 이 형으로 서브 형을 만들 수 없습니
      다 (Java의 "final" 클래스와 유사합니다).

      **계승:**

      ???

   Py_TPFLAGS_READY

      이 비트는 "PyType_Ready()"에 의해 형 객체가 완전히 초기화될 때
      설정됩니다.

      **계승:**

      ???

   Py_TPFLAGS_READYING

      이 비트는 "PyType_Ready()"가 형 객체를 초기화하는 동안 설정됩니
      다.

      **계승:**

      ???

   Py_TPFLAGS_HAVE_GC

      This bit is set when the object supports garbage collection.  If
      this bit is set, instances must be created using
      "PyObject_GC_New()" and destroyed using "PyObject_GC_Del()".
      More information in section 순환 가비지 수집 지원.  This bit
      also implies that the GC-related fields "tp_traverse" and
      "tp_clear" are present in the type object.

      **계승:**

      Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

      The "Py_TPFLAGS_HAVE_GC" flag bit is inherited together with the
      "tp_traverse" and "tp_clear" fields, i.e.  if the
      "Py_TPFLAGS_HAVE_GC" flag bit is clear in the subtype and the
      "tp_traverse" and "tp_clear" fields in the subtype exist and
      have "NULL" values.

   Py_TPFLAGS_DEFAULT

      This is a bitmask of all the bits that pertain to the existence
      of certain fields in the type object and its extension
      structures. Currently, it includes the following bits:
      "Py_TPFLAGS_HAVE_STACKLESS_EXTENSION".

      **계승:**

      ???

   Py_TPFLAGS_METHOD_DESCRIPTOR

      이 비트는 객체가 연결되지 않은 메서드(unbound method)처럼 동작함
      을 나타냅니다.

      이 플래그가 "type(meth)"에 설정되면:

      * "meth.__get__(obj, cls)(*args, **kwds)"("obj"가 None이 아닐 때
        )는 "meth(obj, *args, **kwds)"와 동등해야 합니다.

      * "meth.__get__(None, cls)(*args, **kwds)"는 "meth(*args,
        **kwds)"와 동등해야 합니다.

      이 플래그는 "obj.meth()"와 같은 일반적인 메서드 호출에 대한 최적
      화를 가능하게 합니다: "obj.meth"에 대한 임시 "연결된 메서드
      (bound method)" 객체를 만들지 않습니다.

      버전 3.8에 추가.

      **계승:**

      This flag is never inherited by heap types. For extension types,
      it is inherited whenever "tp_descr_get" is inherited.

   Py_TPFLAGS_LONG_SUBCLASS

   Py_TPFLAGS_LIST_SUBCLASS

   Py_TPFLAGS_TUPLE_SUBCLASS

   Py_TPFLAGS_BYTES_SUBCLASS

   Py_TPFLAGS_UNICODE_SUBCLASS

   Py_TPFLAGS_DICT_SUBCLASS

   Py_TPFLAGS_BASE_EXC_SUBCLASS

   Py_TPFLAGS_TYPE_SUBCLASS

      이 플래그는 "PyLong_Check()" 와 같은 함수에서 형이 내장형의 서브
      클래스인지 신속하게 판별하는 데 사용됩니다; 이러한 특정 검사는
      "PyObject_IsInstance()"와 같은 일반 검사보다 빠릅니다. 내장에서
      상속된 사용자 정의 형은 "tp_flags"를 적절하게 설정해야 합니다,
      그렇지 않으면 그러한 형과 상호 작용하는 코드가 사용되는 검사의
      유형에 따라 다르게 작동합니다.

   Py_TPFLAGS_HAVE_FINALIZE

      이 비트는 "tp_finalize" 슬롯이 형 구조체에 있을 때 설정됩니다.

      버전 3.4에 추가.

      버전 3.8부터 폐지: 인터프리터는 "tp_finalize" 슬롯이 항상 형 구
      조체에 있다고 가정하기 때문에, 이 플래그는 더는 필요하지 않습니
      다.

   Py_TPFLAGS_HAVE_VECTORCALL

      이 비트는 클래스가 벡터콜 프로토콜을 구현할 때 설정됩니다. 자세
      한 내용은 "tp_vectorcall_offset"을 참조하십시오.

      **계승:**

      This bit is inherited for static subtypes if "tp_call" is also
      inherited. Heap types do not inherit
      "Py_TPFLAGS_HAVE_VECTORCALL".

      버전 3.9에 추가.

   Py_TPFLAGS_IMMUTABLETYPE

      This bit is set for type objects that are immutable: type
      attributes cannot be set nor deleted.

      "PyType_Ready()" automatically applies this flag to static
      types.

      **계승:**

      This flag is not inherited.

      버전 3.10에 추가.

   Py_TPFLAGS_DISALLOW_INSTANTIATION

      Disallow creating instances of the type: set "tp_new" to NULL
      and don't create the "__new__" key in the type dictionary.

      The flag must be set before creating the type, not after. For
      example, it must be set before "PyType_Ready()" is called on the
      type.

      The flag is set automatically on static types if "tp_base" is
      NULL or "&PyBaseObject_Type" and "tp_new" is NULL.

      **계승:**

      This flag is not inherited. However, subclasses will not be
      instantiable unless they provide a non-NULL "tp_new" (which is
      only possible via the C API).

      참고:

        To disallow instantiating a class directly but allow
        instantiating its subclasses (e.g. for an *abstract base
        class*), do not use this flag. Instead, make "tp_new" only
        succeed for subclasses.

      버전 3.10에 추가.

   Py_TPFLAGS_MAPPING

      This bit indicates that instances of the class may match mapping
      patterns when used as the subject of a "match" block. It is
      automatically set when registering or subclassing
      "collections.abc.Mapping", and unset when registering
      "collections.abc.Sequence".

      참고:

        "Py_TPFLAGS_MAPPING" and "Py_TPFLAGS_SEQUENCE" are mutually
        exclusive; it is an error to enable both flags simultaneously.

      **계승:**

      This flag is inherited by types that do not already set
      "Py_TPFLAGS_SEQUENCE".

      더 보기: **PEP 634** -- Structural Pattern Matching: Specification

      버전 3.10에 추가.

   Py_TPFLAGS_SEQUENCE

      This bit indicates that instances of the class may match
      sequence patterns when used as the subject of a "match" block.
      It is automatically set when registering or subclassing
      "collections.abc.Sequence", and unset when registering
      "collections.abc.Mapping".

      참고:

        "Py_TPFLAGS_MAPPING" and "Py_TPFLAGS_SEQUENCE" are mutually
        exclusive; it is an error to enable both flags simultaneously.

      **계승:**

      This flag is inherited by types that do not already set
      "Py_TPFLAGS_MAPPING".

      더 보기: **PEP 634** -- Structural Pattern Matching: Specification

      버전 3.10에 추가.

const char *PyTypeObject.tp_doc

   An optional pointer to a NUL-terminated C string giving the
   docstring for this type object.  This is exposed as the "__doc__"
   attribute on the type and instances of the type.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 *않습니다*.

traverseproc PyTypeObject.tp_traverse

   An optional pointer to a traversal function for the garbage
   collector.  This is only used if the "Py_TPFLAGS_HAVE_GC" flag bit
   is set.  The signature is:

      int tp_traverse(PyObject *self, visitproc visit, void *arg);

   파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 순환 가비지 수
   집 지원에서 찾을 수 있습니다.

   The "tp_traverse" pointer is used by the garbage collector to
   detect reference cycles. A typical implementation of a
   "tp_traverse" function simply calls "Py_VISIT()" on each of the
   instance's members that are Python objects that the instance owns.
   For example, this is function "local_traverse()" from the "_thread"
   extension module:

      static int
      local_traverse(localobject *self, visitproc visit, void *arg)
      {
          Py_VISIT(self->args);
          Py_VISIT(self->kw);
          Py_VISIT(self->dict);
          return 0;
      }

   "Py_VISIT()"는 참조 순환에 참여할 수 있는 멤버에 대해서만 호출됨에
   유의하십시오. "self->key" 멤버도 있지만, "NULL"이나 파이썬 문자열만
   가능해서 참조 순환의 일부가 될 수 없습니다.

   반면에, 멤버가 사이클의 일부가 될 수 없다는 것을 알고 있더라도, 디
   버깅 지원을 위해 "gc" 모듈의 "get_referents()" 함수가 그것을 포함하
   도록 어쨌거나 방문하고 싶을 수 있습니다.

   경고:

     When implementing "tp_traverse", only the members that the
     instance *owns* (by having *strong references* to them) must be
     visited. For instance, if an object supports weak references via
     the "tp_weaklist" slot, the pointer supporting the linked list
     (what *tp_weaklist* points to) must **not** be visited as the
     instance does not directly own the weak references to itself (the
     weakreference list is there to support the weak reference
     machinery, but the instance has no strong reference to the
     elements inside it, as they are allowed to be removed even if the
     instance is still alive).

   Note that "Py_VISIT()" requires the *visit* and *arg* parameters to
   "local_traverse()" to have these specific names; don't name them
   just anything.

   Instances of heap-allocated types hold a reference to their type.
   Their traversal function must therefore either visit
   "Py_TYPE(self)", or delegate this responsibility by calling
   "tp_traverse" of another heap-allocated type (such as a heap-
   allocated superclass). If they do not, the type object may not be
   garbage-collected.

   버전 3.9에서 변경: 힙 할당 형은 "tp_traverse"에서 "Py_TYPE(self)"를
   방문할 것으로 기대됩니다. 이전 버전의 파이썬에서는, 버그 40217로 인
   해, 이렇게 하면 서브 클래스에서 충돌이 발생할 수 있습니다.

   **계승:**

   Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with "tp_clear" and
   the "Py_TPFLAGS_HAVE_GC" flag bit: the flag bit, "tp_traverse", and
   "tp_clear" are all inherited from the base type if they are all
   zero in the subtype.

inquiry PyTypeObject.tp_clear

   An optional pointer to a clear function for the garbage collector.
   This is only used if the "Py_TPFLAGS_HAVE_GC" flag bit is set.  The
   signature is:

      int tp_clear(PyObject *);

   "tp_clear" 멤버 함수는 가비지 수집기에서 감지한 순환 가비지에서 참
   조 순환을 끊는 데 사용됩니다. 종합하여, 시스템의 모든 "tp_clear" 함
   수가 결합하여 모든 참조 순환을 끊어야 합니다. 이것은 미묘합니다, 확
   신이 서지 않으면 "tp_clear" 함수를 제공하십시오. 예를 들어, 튜플 형
   은 "tp_clear" 함수를 구현하지 않습니다. 튜플만으로는 참조 순환이 구
   성될 수 없음을 증명할 수 있기 때문입니다. 따라서 다른 형의
   "tp_clear" 함수만으로 튜플을 포함하는 순환을 끊기에 충분해야 합니다
   . 이것은 그리 자명하지 않으며, "tp_clear"를 구현하지 않아도 좋을 만
   한 이유는 거의 없습니다.

   "tp_clear"의 구현은 다음 예제와 같이 파이썬 객체일 수 있는 자신의
   멤버에 대한 인스턴스의 참조를 삭제하고 해당 멤버에 대한 포인터를
   "NULL"로 설정해야 합니다:

      static int
      local_clear(localobject *self)
      {
          Py_CLEAR(self->key);
          Py_CLEAR(self->args);
          Py_CLEAR(self->kw);
          Py_CLEAR(self->dict);
          return 0;
      }

   The "Py_CLEAR()" macro should be used, because clearing references
   is delicate:  the reference to the contained object must not be
   released (via "Py_DECREF()") until after the pointer to the
   contained object is set to "NULL".  This is because releasing the
   reference may cause the contained object to become trash,
   triggering a chain of reclamation activity that may include
   invoking arbitrary Python code (due to finalizers, or weakref
   callbacks, associated with the contained object). If it's possible
   for such code to reference *self* again, it's important that the
   pointer to the contained object be "NULL" at that time, so that
   *self* knows the contained object can no longer be used.  The
   "Py_CLEAR()" macro performs the operations in a safe order.

   Note that "tp_clear" is not *always* called before an instance is
   deallocated. For example, when reference counting is enough to
   determine that an object is no longer used, the cyclic garbage
   collector is not involved and "tp_dealloc" is called directly.

   "tp_clear" 함수의 목표는 참조 순환을 끊는 것이기 때문에, 참조 순환
   에 참여할 수 없는 파이썬 문자열이나 파이썬 정수와 같은 포함된 객체
   를 정리할 필요는 없습니다. 반면에, 포함된 모든 파이썬 객체를 정리하
   고, 형의 "tp_dealloc" 함수가 "tp_clear"를 호출하도록 작성하는 것이
   편리할 수 있습니다.

   파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 순환 가비지 수
   집 지원에서 찾을 수 있습니다.

   **계승:**

   Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with "tp_traverse" and
   the "Py_TPFLAGS_HAVE_GC" flag bit: the flag bit, "tp_traverse", and
   "tp_clear" are all inherited from the base type if they are all
   zero in the subtype.

richcmpfunc PyTypeObject.tp_richcompare

   풍부한 비교 함수(rich comparison function)에 대한 선택적 포인터. 서
   명은 다음과 같습니다:

      PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);

   첫 번째 매개 변수는 "PyTypeObject"에 의해 정의된 형의 인스턴스임이
   보장됩니다.

   이 함수는 비교 결과(일반적으로 "Py_True"나 "Py_False")를 반환해야
   합니다. 비교가 정의되어 있지 않으면, "Py_NotImplemented"를 반환하고
   , 다른 에러가 발생하면 "NULL"을 반환하고 예외 조건을 설정해야 합니
   다.

   다음 상수는 "tp_richcompare"와 "PyObject_RichCompare()"의 세 번째
   인자로 사용되도록 정의됩니다:

   +------------------+--------------+
   | 상수             | 비교         |
   |==================|==============|
   | "Py_LT"          | "<"          |
   +------------------+--------------+
   | "Py_LE"          | "<="         |
   +------------------+--------------+
   | "Py_EQ"          | "=="         |
   +------------------+--------------+
   | "Py_NE"          | "!="         |
   +------------------+--------------+
   | "Py_GT"          | ">"          |
   +------------------+--------------+
   | "Py_GE"          | ">="         |
   +------------------+--------------+

   풍부한 비교 함수를 쉽게 작성할 수 있도록 다음 매크로가 정의됩니다:

   Py_RETURN_RICHCOMPARE(VAL_A, VAL_B, op)

      비교 결과에 따라, 함수에서 "Py_True"나 "Py_False"를 반환합니다.
      VAL_A와 VAL_B는 C 비교 연산자로 순서를 정할 수 있어야 합니다 (예
      를 들어, C int나 float일 수 있습니다). 세 번째 인자는
      "PyObject_RichCompare()"에서처럼 요청된 연산을 지정합니다.

      The returned value is a new *strong reference*.

      에러가 발생하면, 예외를 설정하고 함수에서 "NULL"을 반환합니다.

      버전 3.7에 추가.

   **계승:**

   Group: "tp_hash", "tp_richcompare"

   이 필드는 "tp_hash"와 함께 서브 형에 의해 상속됩니다. 서브 형의
   "tp_richcompare"와 "tp_hash"가 모두 "NULL"이면 서브 형은
   "tp_richcompare"와 "tp_hash"를 상속합니다.

   **기본값:**

   "PyBaseObject_Type" provides a "tp_richcompare" implementation,
   which may be inherited.  However, if only "tp_hash" is defined, not
   even the inherited function is used and instances of the type will
   not be able to participate in any comparisons.

Py_ssize_t PyTypeObject.tp_weaklistoffset

   If the instances of this type are weakly referenceable, this field
   is greater than zero and contains the offset in the instance
   structure of the weak reference list head (ignoring the GC header,
   if present); this offset is used by "PyObject_ClearWeakRefs()" and
   the "PyWeakref_*" functions.  The instance structure needs to
   include a field of type "PyObject*" which is initialized to "NULL".

   이 필드를 "tp_weaklist"와 혼동하지 마십시오; 그것은 형 객체 자체에
   대한 약한 참조의 리스트 헤드입니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지만, 아래 나열된 규칙을 참조하십시
   오. 서브 형이 이 오프셋을 재정의할 수 있습니다; 이는 서브 형이 베이
   스형과 다른 약한 참조 리스트 헤드를 사용함을 의미합니다. 리스트 헤
   드는 항상 "tp_weaklistoffset"을 통해 발견되므로, 문제가 되지 않습니
   다.

   When a type defined by a class statement has no "__slots__"
   declaration, and none of its base types are weakly referenceable,
   the type is made weakly referenceable by adding a weak reference
   list head slot to the instance layout and setting the
   "tp_weaklistoffset" of that slot's offset.

   When a type's "__slots__" declaration contains a slot named
   "__weakref__", that slot becomes the weak reference list head for
   instances of the type, and the slot's offset is stored in the
   type's "tp_weaklistoffset".

   When a type's "__slots__" declaration does not contain a slot named
   "__weakref__", the type inherits its "tp_weaklistoffset" from its
   base type.

getiterfunc PyTypeObject.tp_iter

   An optional pointer to a function that returns an *iterator* for
   the object.  Its presence normally signals that the instances of
   this type are *iterable* (although sequences may be iterable
   without this function).

   이 함수는 "PyObject_GetIter()"와 같은 서명을 갖습니다:

      PyObject *tp_iter(PyObject *self);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

iternextfunc PyTypeObject.tp_iternext

   An optional pointer to a function that returns the next item in an
   *iterator*. The signature is:

      PyObject *tp_iternext(PyObject *self);

   이터레이터가 소진되면 "NULL"을 반환해야 합니다; "StopIteration" 예
   외가 설정될 수도, 그렇지 않을 수도 있습니다. 다른 에러가 발생하면,
   역시 "NULL"을 반환해야 합니다. 그 존재는 이 형의 인스턴스가 이터레
   이터라는 신호입니다.

   이터레이터 형은 "tp_iter" 함수도 정의해야 하며, 해당 함수는 (새 이
   터레이터 인스턴스가 아닌) 이터레이터 인스턴스 자체를 반환해야 합니
   다.

   이 함수는 "PyIter_Next()"와 같은 서명을 갖습니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

struct PyMethodDef *PyTypeObject.tp_methods

   이 형의 일반 메서드를 선언하는 "PyMethodDef" 구조체의 정적 "NULL"-
   종료 배열에 대한 선택적 포인터.

   배열의 항목마다, 메서드 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (메서드는 다른 메커니즘
   을 통해 상속됩니다).

struct PyMemberDef *PyTypeObject.tp_members

   이 형의 인스턴스의 일반 데이터 멤버(필드나 슬롯)를 선언하는
   "PyMemberDef" 구조체의 정적 "NULL"-종료 배열에 대한 선택적 포인터.

   배열의 항목마다, 멤버 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (멤버는 다른 메커니즘을
   통해 상속됩니다).

struct PyGetSetDef *PyTypeObject.tp_getset

   이 형의 인스턴스의 계산된 어트리뷰트를 선언하는 "PyGetSetDef" 구조
   체의 정적 "NULL"-종료 배열에 대한 선택적 포인터.

   배열의 항목마다, getset 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (계산된 어트리뷰트는 다
   른 메커니즘을 통해 상속됩니다).

PyTypeObject *PyTypeObject.tp_base

   형 속성이 상속되는 베이스형에 대한 선택적 포인터. 이 수준에서는, 단
   일 상속만 지원됩니다; 다중 상속은 메타 형을 호출하여 형 객체를 동적
   으로 작성해야 합니다.

   참고:

     슬롯 초기화에는 전역 초기화 규칙이 적용됩니다. C99에서는 초기화자
     가 "주소 상수(address constants)"여야 합니다. 포인터로 묵시적으로
     변환되는 "PyType_GenericNew()"와 같은 함수 지정자는 유효한 C99 주
     소 상수입니다.However, the unary '&' operator applied to a non-
     static variable like "PyBaseObject_Type()" is not required to
     produce an address constant.  Compilers may support this (gcc
     does), MSVC does not. Both compilers are strictly standard
     conforming in this particular behavior.결과적으로, "tp_base"는 확
     장 모듈의 초기화 함수에서 설정되어야 합니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (명백히).

   **기본값:**

   이 필드의 기본값은 "&PyBaseObject_Type"입니다 (파이썬 프로그래머에
   게는 "object" 형으로 알려져 있습니다).

PyObject *PyTypeObject.tp_dict

   형의 딕셔너리는 "PyType_Ready()"에 의해 여기에 저장됩니다.

   This field should normally be initialized to "NULL" before
   PyType_Ready is called; it may also be initialized to a dictionary
   containing initial attributes for the type.  Once "PyType_Ready()"
   has initialized the type, extra attributes for the type may be
   added to this dictionary only if they don't correspond to
   overloaded operations (like "__add__()").

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (여기에 정의된 어트리뷰
   트는 다른 메커니즘을 통해 상속됩니다).

   **기본값:**

   이 필드가 "NULL"이면, "PyType_Ready()"는 새 딕셔너리를 할당합니다.

   경고:

     "PyDict_SetItem()"을 사용하거나 다른 식으로 딕셔너리 C-API로
     "tp_dict"를 수정하는 것은 안전하지 않습니다.

descrgetfunc PyTypeObject.tp_descr_get

   "디스크립터 get" 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

descrsetfunc PyTypeObject.tp_descr_set

   디스크립터 값을 설정하고 삭제하기 위한 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);

   *value* 인자는 값을 삭제하기 위해 "NULL"로 설정됩니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

Py_ssize_t PyTypeObject.tp_dictoffset

   이 형의 인스턴스에 인스턴스 변수를 포함하는 딕셔너리가 있으면, 이
   필드는 0이 아니며 인스턴스 변수 딕셔너리 형의 인스턴스에서의 오프셋
   을 포함합니다; 이 오프셋은 "PyObject_GenericGetAttr()"에서 사용됩니
   다.

   이 필드를 "tp_dict"와 혼동하지 마십시오; 그것은 형 객체 자체의 어트
   리뷰트에 대한 딕셔너리입니다.

   If the value of this field is greater than zero, it specifies the
   offset from the start of the instance structure.  If the value is
   less than zero, it specifies the offset from the *end* of the
   instance structure.  A negative offset is more expensive to use,
   and should only be used when the instance structure contains a
   variable-length part.  This is used for example to add an instance
   variable dictionary to subtypes of "str" or "tuple". Note that the
   "tp_basicsize" field should account for the dictionary added to the
   end in that case, even though the dictionary is not included in the
   basic object layout.  On a system with a pointer size of 4 bytes,
   "tp_dictoffset" should be set to "-4" to indicate that the
   dictionary is at the very end of the structure.

   The real dictionary offset in an instance can be computed from a
   negative "tp_dictoffset" as follows:

      dictoffset = tp_basicsize + abs(ob_size)*tp_itemsize + tp_dictoffset
      if dictoffset is not aligned on sizeof(void*):
          round up to sizeof(void*)

   where "tp_basicsize", "tp_itemsize" and "tp_dictoffset" are taken
   from the type object, and "ob_size" is taken from the instance.
   The absolute value is taken because ints use the sign of "ob_size"
   to store the sign of the number.  (There's never a need to do this
   calculation yourself; it is done for you by
   "_PyObject_GetDictPtr()".)

   **계승:**

   This field is inherited by subtypes, but see the rules listed
   below. A subtype may override this offset; this means that the
   subtype instances store the dictionary at a difference offset than
   the base type.  Since the dictionary is always found via
   "tp_dictoffset", this should not be a problem.

   When a type defined by a class statement has no "__slots__"
   declaration, and none of its base types has an instance variable
   dictionary, a dictionary slot is added to the instance layout and
   the "tp_dictoffset" is set to that slot's offset.

   When a type defined by a class statement has a "__slots__"
   declaration, the type inherits its "tp_dictoffset" from its base
   type.

   (Adding a slot named "__dict__" to the "__slots__" declaration does
   not have the expected effect, it just causes confusion.  Maybe this
   should be added as a feature just like "__weakref__" though.)

   **기본값:**

   This slot has no default.  For static types, if the field is "NULL"
   then no "__dict__" gets created for instances.

initproc PyTypeObject.tp_init

   인스턴스 초기화 함수에 대한 선택적 포인터.

   This function corresponds to the "__init__()" method of classes.
   Like "__init__()", it is possible to create an instance without
   calling "__init__()", and it is possible to reinitialize an
   instance by calling its "__init__()" method again.

   함수 서명은 다음과 같습니다:

      int tp_init(PyObject *self, PyObject *args, PyObject *kwds);

   The self argument is the instance to be initialized; the *args* and
   *kwds* arguments represent positional and keyword arguments of the
   call to "__init__()".

   "NULL"이 아닐 때, "tp_init" 함수는 형을 호출하여 인스턴스를 정상적
   으로 만들 때, 형의 "tp_new" 함수가 형의 인스턴스를 반환한 후 호출됩
   니다. "tp_new" 함수가 원래 형의 서브 형이 아닌 다른 형의 인스턴스를
   반환하면, 아무런 "tp_init" 함수도 호출되지 않습니다; "tp_new"가 원
   래 형의 서브 형 인스턴스를 반환하면, 서브 형의 "tp_init"가 호출됩니
   다.

   성공하면 "0"을 반환하고, 에러 시에는 "-1"을 반환하고 예외를 설정합
   니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   For static types this field does not have a default.

allocfunc PyTypeObject.tp_alloc

   인스턴스 할당 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);

   **계승:**

   이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으
   로 만들어진 서브 형)에는 상속되지 않습니다.

   **기본값:**

   동적 서브 형의 경우, 이 필드는 표준 힙 할당 전략을 강제하기 위해 항
   상 "PyType_GenericAlloc()"으로 설정됩니다.

   For static subtypes, "PyBaseObject_Type" uses
   "PyType_GenericAlloc()".  That is the recommended value for all
   statically defined types.

newfunc PyTypeObject.tp_new

   인스턴스 생성 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);

   *subtype* 인자는 만들어지고 있는 객체의 형입니다; *args*와 *kwds*
   인자는 형 호출의 위치와 키워드 인자를 나타냅니다. *subtype*이
   "tp_new" 함수가 호출되는 형과 같을 필요는 없음에 유의하십시오; 이
   형의 서브 형일 수 있습니다 (하지만 관련이 없는 형은 아닙니다).

   "tp_new" 함수는 객체에 공간을 할당하기 위해
   "subtype->tp_alloc(subtype, nitems)"를 호출해야 하고, 그런 다음 꼭
   필요한 만큼만 추가 초기화를 수행해야 합니다. 안전하게 무시하거나 반
   복할 수 있는 초기화는 "tp_init" 처리기에 배치해야 합니다. 간단한 규
   칙은, 불변 형의 경우 모든 초기화가 "tp_new"에서 수행되어야 하고, 가
   변형의 경우 대부분 초기화는 "tp_init"로 미뤄져야 합니다.

   Set the "Py_TPFLAGS_DISALLOW_INSTANTIATION" flag to disallow
   creating instances of the type in Python.

   **계승:**

   This field is inherited by subtypes, except it is not inherited by
   static types whose "tp_base" is "NULL" or "&PyBaseObject_Type".

   **기본값:**

   For static types this field has no default. This means if the slot
   is defined as "NULL", the type cannot be called to create new
   instances; presumably there is some other way to create instances,
   like a factory function.

freefunc PyTypeObject.tp_free

   인스턴스 할당 해제 함수에 대한 선택적 포인터. 서명은 다음과 같습니
   다:

      void tp_free(void *self);

   이 서명과 호환되는 초기화자는 "PyObject_Free()"입니다.

   **계승:**

   이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으
   로 만들어진 서브 형)에는 상속되지 않습니다.

   **기본값:**

   In dynamic subtypes, this field is set to a deallocator suitable to
   match "PyType_GenericAlloc()" and the value of the
   "Py_TPFLAGS_HAVE_GC" flag bit.

   For static subtypes, "PyBaseObject_Type" uses PyObject_Del.

inquiry PyTypeObject.tp_is_gc

   가비지 수집기에서 호출되는 함수에 대한 선택적 포인터.

   The garbage collector needs to know whether a particular object is
   collectible or not.  Normally, it is sufficient to look at the
   object's type's "tp_flags" field, and check the
   "Py_TPFLAGS_HAVE_GC" flag bit.  But some types have a mixture of
   statically and dynamically allocated instances, and the statically
   allocated instances are not collectible.  Such types should define
   this function; it should return "1" for a collectible instance, and
   "0" for a non-collectible instance. The signature is:

      int tp_is_gc(PyObject *self);

   (The only example of this are types themselves.  The metatype,
   "PyType_Type", defines this function to distinguish between
   statically and dynamically allocated types.)

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   This slot has no default.  If this field is "NULL",
   "Py_TPFLAGS_HAVE_GC" is used as the functional equivalent.

PyObject *PyTypeObject.tp_bases

   베이스형의 튜플.

   This field should be set to "NULL" and treated as read-only. Python
   will fill it in when the type is "initialized".

   For dynamically created classes, the "Py_tp_bases" "slot" can be
   used instead of the *bases* argument of
   "PyType_FromSpecWithBases()". The argument form is preferred.

   경고:

     Multiple inheritance does not work well for statically defined
     types. If you set "tp_bases" to a tuple, Python will not raise an
     error, but some slots will only be inherited from the first base.

   **계승:**

   이 필드는 상속되지 않습니다.

PyObject *PyTypeObject.tp_mro

   형 자체에서 시작하여 "object"로 끝나는 확장된 베이스형 집합을 포함
   하는 튜플.

   This field should be set to "NULL" and treated as read-only. Python
   will fill it in when the type is "initialized".

   **계승:**

   이 필드는 상속되지 않습니다; "PyType_Ready()"에 의해 새로 계산됩니
   다.

PyObject *PyTypeObject.tp_cache

   사용되지 않습니다. 내부 전용.

   **계승:**

   이 필드는 상속되지 않습니다.

PyObject *PyTypeObject.tp_subclasses

   List of weak references to subclasses.  Internal use only.

   **계승:**

   이 필드는 상속되지 않습니다.

PyObject *PyTypeObject.tp_weaklist

   이 형 객체에 대한 약한 참조를 위한 약한 참조 리스트 헤드. 상속되지
   않습니다. 내부 전용.

   **계승:**

   이 필드는 상속되지 않습니다.

destructor PyTypeObject.tp_del

   이 필드는 폐지되었습니다. 대신 "tp_finalize"를 사용하십시오.

unsigned int PyTypeObject.tp_version_tag

   메서드 캐시에 인덱싱하는 데 사용됩니다. 내부 전용.

   **계승:**

   이 필드는 상속되지 않습니다.

destructor PyTypeObject.tp_finalize

   인스턴스 파이널리제이션 함수에 대한 선택적 포인터. 서명은 다음과 같
   습니다:

      void tp_finalize(PyObject *self);

   "tp_finalize"가 설정되면, 인터프리터는 인스턴스를 파이널라이즈 할
   때 이를 한 번 호출합니다. 가비지 수집기(인스턴스가 격리된 참조 순환
   의 일부인 경우)나 객체가 할당 해제되기 직전에 호출됩니다. 어느 쪽이
   든, 참조 순환을 끊기 전에 호출되어 정상 상태에 있는 객체를 보도록
   보장합니다.

   "tp_finalize"는 현재 예외 상태를 변경하지 않아야 합니다; 따라서 사
   소하지 않은 파이널라이저를 작성하는 권장 방법은 다음과 같습니다:

      static void
      local_finalize(PyObject *self)
      {
          PyObject *error_type, *error_value, *error_traceback;

          /* Save the current exception, if any. */
          PyErr_Fetch(&error_type, &error_value, &error_traceback);

          /* ... */

          /* Restore the saved exception. */
          PyErr_Restore(error_type, error_value, error_traceback);
      }

   Also, note that, in a garbage collected Python, "tp_dealloc" may be
   called from any Python thread, not just the thread which created
   the object (if the object becomes part of a refcount cycle, that
   cycle might be collected by a garbage collection on any thread).
   This is not a problem for Python API calls, since the thread on
   which tp_dealloc is called will own the Global Interpreter Lock
   (GIL). However, if the object being destroyed in turn destroys
   objects from some other C or C++ library, care should be taken to
   ensure that destroying those objects on the thread which called
   tp_dealloc will not violate any assumptions of the library.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   버전 3.4에 추가.

   버전 3.8에서 변경: Before version 3.8 it was necessary to set the
   "Py_TPFLAGS_HAVE_FINALIZE" flags bit in order for this field to be
   used.  This is no longer required.

   더 보기: "안전한 객체 파이널리제이션" (**PEP 442**)

vectorcallfunc PyTypeObject.tp_vectorcall

   Vectorcall function to use for calls of this type object. In other
   words, it is used to implement vectorcall for "type.__call__". If
   "tp_vectorcall" is "NULL", the default call implementation using
   "__new__" and "__init__" is used.

   **계승:**

   이 필드는 상속되지 않습니다.

   버전 3.9에 추가: (필드는 3.8부터 존재하지만 3.9부터 사용됩니다)


Static Types
============

전통적으로, C 코드에서 정의된 형은 *정적(static)*입니다. 즉 정적
"PyTypeObject" 구조체는 코드에서 직접 정의되고 "PyType_Ready()"를 사용
하여 초기화됩니다.

결과적으로 파이썬에서 정의된 형에 비해 형이 제한됩니다:

* 정적 형은 하나의 베이스로 제한됩니다. 즉, 다중 상속을 사용할 수 없습
  니다.

* 정적 형 객체(그러나 이들의 인스턴스는 아닙니다)는 불변입니다. 파이썬
  에서 형 객체의 어트리뷰트를 추가하거나 수정할 수 없습니다.

* 정적 형 객체는 서브 인터프리터에서 공유되므로, 서브 인터프리터 관련
  상태를 포함하지 않아야 합니다.

Also, since "PyTypeObject" is only part of the Limited API as an
opaque struct, any extension modules using static types must be
compiled for a specific Python minor version.


힙 형
=====

An alternative to static types is *heap-allocated types*, or *heap
types* for short, which correspond closely to classes created by
Python's "class" statement. Heap types have the "Py_TPFLAGS_HEAPTYPE"
flag set.

This is done by filling a "PyType_Spec" structure and calling
"PyType_FromSpec()", "PyType_FromSpecWithBases()", or
"PyType_FromModuleAndSpec()".


숫자 객체 구조체
****************

type PyNumberMethods

   이 구조체는 객체가 숫자 프로토콜을 구현하는 데 사용하는 함수에 대한
   포인터를 담습니다. 각 함수는 숫자 프로토콜 섹션에서 설명하는 유사한
   이름의 함수가 사용합니다.

   구조체 정의는 다음과 같습니다:

      typedef struct {
           binaryfunc nb_add;
           binaryfunc nb_subtract;
           binaryfunc nb_multiply;
           binaryfunc nb_remainder;
           binaryfunc nb_divmod;
           ternaryfunc nb_power;
           unaryfunc nb_negative;
           unaryfunc nb_positive;
           unaryfunc nb_absolute;
           inquiry nb_bool;
           unaryfunc nb_invert;
           binaryfunc nb_lshift;
           binaryfunc nb_rshift;
           binaryfunc nb_and;
           binaryfunc nb_xor;
           binaryfunc nb_or;
           unaryfunc nb_int;
           void *nb_reserved;
           unaryfunc nb_float;

           binaryfunc nb_inplace_add;
           binaryfunc nb_inplace_subtract;
           binaryfunc nb_inplace_multiply;
           binaryfunc nb_inplace_remainder;
           ternaryfunc nb_inplace_power;
           binaryfunc nb_inplace_lshift;
           binaryfunc nb_inplace_rshift;
           binaryfunc nb_inplace_and;
           binaryfunc nb_inplace_xor;
           binaryfunc nb_inplace_or;

           binaryfunc nb_floor_divide;
           binaryfunc nb_true_divide;
           binaryfunc nb_inplace_floor_divide;
           binaryfunc nb_inplace_true_divide;

           unaryfunc nb_index;

           binaryfunc nb_matrix_multiply;
           binaryfunc nb_inplace_matrix_multiply;
      } PyNumberMethods;

   참고:

     이항과 삼항 함수는 모든 피연산자의 형을 확인하고, 필요한 변환을
     구현해야합니다 (적어도 피연산자 중 하나는 정의된 형의 인스턴스입
     니다). 주어진 피연산자에 대해 연산이 정의되지 않으면, 이항과 삼항
     함수는 "Py_NotImplemented"를 반환해야하며, 다른 에러가 발생하면
     "NULL"을 반환하고 예외를 설정해야 합니다.

   참고:

     The "nb_reserved" field should always be "NULL".  It was
     previously called "nb_long", and was renamed in Python 3.0.1.

binaryfunc PyNumberMethods.nb_add

binaryfunc PyNumberMethods.nb_subtract

binaryfunc PyNumberMethods.nb_multiply

binaryfunc PyNumberMethods.nb_remainder

binaryfunc PyNumberMethods.nb_divmod

ternaryfunc PyNumberMethods.nb_power

unaryfunc PyNumberMethods.nb_negative

unaryfunc PyNumberMethods.nb_positive

unaryfunc PyNumberMethods.nb_absolute

inquiry PyNumberMethods.nb_bool

unaryfunc PyNumberMethods.nb_invert

binaryfunc PyNumberMethods.nb_lshift

binaryfunc PyNumberMethods.nb_rshift

binaryfunc PyNumberMethods.nb_and

binaryfunc PyNumberMethods.nb_xor

binaryfunc PyNumberMethods.nb_or

unaryfunc PyNumberMethods.nb_int

void *PyNumberMethods.nb_reserved

unaryfunc PyNumberMethods.nb_float

binaryfunc PyNumberMethods.nb_inplace_add

binaryfunc PyNumberMethods.nb_inplace_subtract

binaryfunc PyNumberMethods.nb_inplace_multiply

binaryfunc PyNumberMethods.nb_inplace_remainder

ternaryfunc PyNumberMethods.nb_inplace_power

binaryfunc PyNumberMethods.nb_inplace_lshift

binaryfunc PyNumberMethods.nb_inplace_rshift

binaryfunc PyNumberMethods.nb_inplace_and

binaryfunc PyNumberMethods.nb_inplace_xor

binaryfunc PyNumberMethods.nb_inplace_or

binaryfunc PyNumberMethods.nb_floor_divide

binaryfunc PyNumberMethods.nb_true_divide

binaryfunc PyNumberMethods.nb_inplace_floor_divide

binaryfunc PyNumberMethods.nb_inplace_true_divide

unaryfunc PyNumberMethods.nb_index

binaryfunc PyNumberMethods.nb_matrix_multiply

binaryfunc PyNumberMethods.nb_inplace_matrix_multiply


매핑 객체 구조체
****************

type PyMappingMethods

   이 구조체에는 객체가 매핑 프로토콜을 구현하는 데 사용하는 함수에 대
   한 포인터를 담습니다. 세 개의 멤버가 있습니다:

lenfunc PyMappingMethods.mp_length

   이 함수는 "PyMapping_Size()"와 "PyObject_Size()"에서 사용되며, 같은
   서명을 갖습니다. 객체에 길이가 정의되어 있지 않으면 이 슬롯을
   "NULL"로 설정할 수 있습니다.

binaryfunc PyMappingMethods.mp_subscript

   이 함수는 "PyObject_GetItem()"과 "PySequence_GetSlice()"에서 사용되
   며, "PyObject_GetItem()"과 같은 서명을 갖습니다.
   "PyMapping_Check()" 함수가 "1"을 반환하려면, 이 슬롯을 채워야합니다
   , 그렇지 않으면 "NULL"일 수 있습니다.

objobjargproc PyMappingMethods.mp_ass_subscript

   This function is used by "PyObject_SetItem()",
   "PyObject_DelItem()", "PyObject_SetSlice()" and
   "PyObject_DelSlice()".  It has the same signature as
   "PyObject_SetItem()", but *v* can also be set to "NULL" to delete
   an item.  If this slot is "NULL", the object does not support item
   assignment and deletion.


시퀀스 객체 구조체
******************

type PySequenceMethods

   이 구조체는 객체가 시퀀스 프로토콜을 구현하는 데 사용하는 함수에 대
   한 포인터를 담습니다.

lenfunc PySequenceMethods.sq_length

   이 함수는 "PySequence_Size()"와 "PyObject_Size()"에서 사용되며, 같
   은 서명을 갖습니다. 또한 "sq_item"과 "sq_ass_item" 슬롯을 통해 음수
   인덱스를 처리하는 데 사용됩니다.

binaryfunc PySequenceMethods.sq_concat

   이 함수는 "PySequence_Concat()"에서 사용되며 같은 서명을 갖습니다.
   "nb_add" 슬롯을 통해 숫자 덧셈을 시도한 후, "+" 연산자에서도 사용됩
   니다.

ssizeargfunc PySequenceMethods.sq_repeat

   이 함수는 "PySequence_Repeat()"에서 사용되며 같은 서명을 갖습니다.
   "nb_multiply" 슬롯을 통해 숫자 곱셈을 시도한 후, "*" 연산자에서도
   사용됩니다.

ssizeargfunc PySequenceMethods.sq_item

   이 함수는 "PySequence_GetItem()"에서 사용되며 같은 서명을 갖습니다.
   "mp_subscript" 슬롯을 통해 서브스크립션(subscription)을 시도한 후,
   "PyObject_GetItem()"에서도 사용됩니다. "PySequence_Check()" 함수가
   "1"을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 "NULL"일 수
   있습니다.

   Negative indexes are handled as follows: if the "sq_length" slot is
   filled, it is called and the sequence length is used to compute a
   positive index which is passed to "sq_item".  If "sq_length" is
   "NULL", the index is passed as is to the function.

ssizeobjargproc PySequenceMethods.sq_ass_item

   이 함수는 "PySequence_SetItem()"에서 사용되며 같은 서명을 갖습니다.
   "mp_ass_subscript" 슬롯을 통해 항목 대입과 삭제를 시도한 후,
   "PyObject_SetItem()"과 "PyObject_DelItem()"에서도 사용됩니다. 객체
   가 항목 대입과 삭제를 지원하지 않으면 이 슬롯은 "NULL"로 남겨 둘 수
   있습니다.

objobjproc PySequenceMethods.sq_contains

   이 함수는 "PySequence_Contains()"에서 사용될 수 있으며 같은 서명을
   갖습니다. 이 슬롯은 "NULL"로 남겨 둘 수 있습니다, 이때
   "PySequence_Contains()"는 일치하는 것을 찾을 때까지 시퀀스를 단순히
   탐색합니다.

binaryfunc PySequenceMethods.sq_inplace_concat

   이 함수는 "PySequence_InPlaceConcat()"에서 사용되며 같은 서명을 갖
   습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯
   은 "NULL"로 남겨 둘 수 있으며, 이때 "PySequence_InPlaceConcat()"은
   "PySequence_Concat()"으로 폴백 됩니다. "nb_inplace_add" 슬롯을 통해
   숫자 제자리 덧셈을 시도한 후, 증분 대입 "+="에서 사용됩니다.

ssizeargfunc PySequenceMethods.sq_inplace_repeat

   이 함수는 "PySequence_InPlaceRepeat()"에서 사용되며 같은 서명을 갖
   습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯
   은 "NULL"로 남겨 둘 수 있으며, 이때 "PySequence_InPlaceRepeat()"는
   "PySequence_Repeat()"로 폴백 됩니다. "nb_inplace_multiply" 슬롯을
   통해 숫자 제자리 곱셈을 시도한 후, 증분 대입 "*="에서도 사용됩니다.


버퍼 객체 구조체
****************

type PyBufferProcs

   이 구조체는 버퍼 프로토콜에 필요한 함수에 대한 포인터를 담습니다.
   프로토콜은 제공자(exporter) 객체가 내부 데이터를 소비자 객체에 노출
   하는 방법을 정의합니다.

getbufferproc PyBufferProcs.bf_getbuffer

   이 함수의 서명은 다음과 같습니다:

      int (PyObject *exporter, Py_buffer *view, int flags);

   *view*를 채우기 위해 *exporter*에 대한 *flags*에 지정된 요청을 처리
   합니다. 포인트 (3) 을 제외하고, 이 함수의 구현은 다음 단계를 반드시
   수행해야 합니다:

   1. Check if the request can be met. If not, raise
      "PyExc_BufferError", set "view->obj" to "NULL" and return "-1".

   2. 요청된 필드를 채웁니다.

   3. 내보내기 횟수에 대한 내부 카운터를 증가시킵니다.

   4. Set "view->obj" to *exporter* and increment "view->obj".

   5. "0"을 반환합니다.

   *exporter*가 버퍼 공급자의 체인이나 트리의 일부이면, 두 가지 주요
   체계를 사용할 수 있습니다:

   * Re-export: Each member of the tree acts as the exporting object
     and sets "view->obj" to a new reference to itself.

   * Redirect: The buffer request is redirected to the root object of
     the tree. Here, "view->obj" will be a new reference to the root
     object.

   *view*의 개별 필드는 섹션 버퍼 구조체에 설명되어 있으며, 제공자가
   특정 요청에 응답해야 하는 규칙은 섹션 버퍼 요청 유형에 있습니다.

   "Py_buffer" 구조체에서 가리키는 모든 메모리는 제공자에게 속하며 남
   은 소비자가 없어질 때까지 유효해야 합니다. "format", "shape",
   "strides", "suboffsets" 및 "internal"은 소비자에게는 읽기 전용입니
   다.

   "PyBuffer_FillInfo()"는 모든 요청 유형을 올바르게 처리하면서 간단한
   바이트열 버퍼를 쉽게 노출 할 수 있는 방법을 제공합니다.

   "PyObject_GetBuffer()"는 이 함수를 감싸는 소비자 용 인터페이스입니
   다.

releasebufferproc PyBufferProcs.bf_releasebuffer

   이 함수의 서명은 다음과 같습니다:

      void (PyObject *exporter, Py_buffer *view);

   버퍼 자원 해제 요청을 처리합니다. 자원을 해제할 필요가 없으면,
   "PyBufferProcs.bf_releasebuffer"는 "NULL"일 수 있습니다. 그렇지 않
   으면, 이 함수의 표준 구현은 다음과 같은 선택적 단계를 수행합니다:

   1. 내보내기 횟수에 대한 내부 카운터를 줄입니다.

   2. 카운터가 "0"이면, *view*와 관련된 모든 메모리를 해제합니다.

   제공자는 반드시 "internal" 필드를 사용하여 버퍼 특정 자원을 추적해
   야 합니다. 이 필드는 변경되지 않고 유지됨이 보장되지만, 소비자는 원
   래 버퍼의 사본을 *view* 인자로 전달할 수 있습니다.

   This function MUST NOT decrement "view->obj", since that is done
   automatically in "PyBuffer_Release()" (this scheme is useful for
   breaking reference cycles).

   "PyBuffer_Release()"는 이 기능을 감싸는 소비자 용 인터페이스입니다.


비동기 객체 구조체
******************

버전 3.5에 추가.

type PyAsyncMethods

   이 구조체는 *어웨이터블*와 *비동기 이터레이터* 객체를 구현하는 데
   필요한 함수에 대한 포인터를 담습니다.

   구조체 정의는 다음과 같습니다:

      typedef struct {
          unaryfunc am_await;
          unaryfunc am_aiter;
          unaryfunc am_anext;
          sendfunc am_send;
      } PyAsyncMethods;

unaryfunc PyAsyncMethods.am_await

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_await(PyObject *self);

   The returned object must be an *iterator*, i.e. "PyIter_Check()"
   must return "1" for it.

   객체가 *어웨이터블*이 아니면 이 슬롯을 "NULL"로 설정할 수 있습니다.

unaryfunc PyAsyncMethods.am_aiter

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_aiter(PyObject *self);

   Must return an *asynchronous iterator* object. See "__anext__()"
   for details.

   객체가 비동기 이터레이션 프로토콜을 구현하지 않으면 이 슬롯은
   "NULL"로 설정될 수 있습니다.

unaryfunc PyAsyncMethods.am_anext

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_anext(PyObject *self);

   Must return an *awaitable* object.  See "__anext__()" for details.
   This slot may be set to "NULL".

sendfunc PyAsyncMethods.am_send

   이 함수의 서명은 다음과 같습니다:

      PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);

   See "PyIter_Send()" for details. This slot may be set to "NULL".

   버전 3.10에 추가.


슬롯 형 typedef
***************

typedef PyObject *(*allocfunc)(PyTypeObject *cls, Py_ssize_t nitems)
    * Part of the Stable ABI.*

   The purpose of this function is to separate memory allocation from
   memory initialization.  It should return a pointer to a block of
   memory of adequate length for the instance, suitably aligned, and
   initialized to zeros, but with "ob_refcnt" set to "1" and "ob_type"
   set to the type argument.  If the type's "tp_itemsize" is non-zero,
   the object's "ob_size" field should be initialized to *nitems* and
   the length of the allocated memory block should be "tp_basicsize +
   nitems*tp_itemsize", rounded up to a multiple of "sizeof(void*)";
   otherwise, *nitems* is not used and the length of the block should
   be "tp_basicsize".

   이 함수는 다른 인스턴스 초기화를 수행하지 않아야 합니다, 추가 메모
   리를 할당도 안 됩니다; 그것은 "tp_new"에 의해 수행되어야 합니다.

typedef void (*destructor)(PyObject*)
    * Part of the Stable ABI.*

typedef void (*freefunc)(void*)

   "tp_free"를 참조하십시오.

typedef PyObject *(*newfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*

   "tp_new"를 참조하십시오.

typedef int (*initproc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*

   "tp_init"를 참조하십시오.

typedef PyObject *(*reprfunc)(PyObject*)
    * Part of the Stable ABI.*

   "tp_repr"을 참조하십시오.

typedef PyObject *(*getattrfunc)(PyObject *self, char *attr)
    * Part of the Stable ABI.*

   객체의 명명된 어트리뷰트 값을 반환합니다.

typedef int (*setattrfunc)(PyObject *self, char *attr, PyObject *value)
    * Part of the Stable ABI.*

   객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면
   value 인자가 "NULL"로 설정됩니다.

typedef PyObject *(*getattrofunc)(PyObject *self, PyObject *attr)
    * Part of the Stable ABI.*

   객체의 명명된 어트리뷰트 값을 반환합니다.

   "tp_getattro"를 참조하십시오.

typedef int (*setattrofunc)(PyObject *self, PyObject *attr, PyObject *value)
    * Part of the Stable ABI.*

   객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면
   value 인자가 "NULL"로 설정됩니다.

   "tp_setattro"를 참조하십시오.

typedef PyObject *(*descrgetfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*

   See "tp_descr_get".

typedef int (*descrsetfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*

   See "tp_descr_set".

typedef Py_hash_t (*hashfunc)(PyObject*)
    * Part of the Stable ABI.*

   "tp_hash"를 참조하십시오.

typedef PyObject *(*richcmpfunc)(PyObject*, PyObject*, int)
    * Part of the Stable ABI.*

   "tp_richcompare"를 참조하십시오.

typedef PyObject *(*getiterfunc)(PyObject*)
    * Part of the Stable ABI.*

   "tp_iter"를 참조하십시오.

typedef PyObject *(*iternextfunc)(PyObject*)
    * Part of the Stable ABI.*

   "tp_iternext"를 참조하십시오.

typedef Py_ssize_t (*lenfunc)(PyObject*)
    * Part of the Stable ABI.*

typedef int (*getbufferproc)(PyObject*, Py_buffer*, int)

typedef void (*releasebufferproc)(PyObject*, Py_buffer*)

typedef PyObject *(*unaryfunc)(PyObject*)
    * Part of the Stable ABI.*

typedef PyObject *(*binaryfunc)(PyObject*, PyObject*)
    * Part of the Stable ABI.*

typedef PySendResult (*sendfunc)(PyObject*, PyObject*, PyObject**)

   See "am_send".

typedef PyObject *(*ternaryfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*

typedef PyObject *(*ssizeargfunc)(PyObject*, Py_ssize_t)
    * Part of the Stable ABI.*

typedef int (*ssizeobjargproc)(PyObject*, Py_ssize_t, PyObject*)
    * Part of the Stable ABI.*

typedef int (*objobjproc)(PyObject*, PyObject*)
    * Part of the Stable ABI.*

typedef int (*objobjargproc)(PyObject*, PyObject*, PyObject*)
    * Part of the Stable ABI.*


예
**

다음은 파이썬 형 정의의 간단한 예입니다. 여기에는 여러분이 만날 수 있
는 일반적인 사용법이 포함됩니다. 일부는 까다로운 코너 사례를 보여줍니
다. 더 많은 예제, 실용 정보 및 자습서는 확장형 정의하기: 자습서와 확장
형 정의하기: 여러 가지 주제를 참조하십시오.

A basic static type:

   typedef struct {
       PyObject_HEAD
       const char *data;
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject),
       .tp_doc = PyDoc_STR("My objects"),
       .tp_new = myobj_new,
       .tp_dealloc = (destructor)myobj_dealloc,
       .tp_repr = (reprfunc)myobj_repr,
   };

더 상세한 초기화자를 사용하는 이전 코드(특히 CPython 코드 베이스에서)
를 찾을 수도 있습니다:

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       "mymod.MyObject",               /* tp_name */
       sizeof(MyObject),               /* tp_basicsize */
       0,                              /* tp_itemsize */
       (destructor)myobj_dealloc,      /* tp_dealloc */
       0,                              /* tp_vectorcall_offset */
       0,                              /* tp_getattr */
       0,                              /* tp_setattr */
       0,                              /* tp_as_async */
       (reprfunc)myobj_repr,           /* tp_repr */
       0,                              /* tp_as_number */
       0,                              /* tp_as_sequence */
       0,                              /* tp_as_mapping */
       0,                              /* tp_hash */
       0,                              /* tp_call */
       0,                              /* tp_str */
       0,                              /* tp_getattro */
       0,                              /* tp_setattro */
       0,                              /* tp_as_buffer */
       0,                              /* tp_flags */
       PyDoc_STR("My objects"),        /* tp_doc */
       0,                              /* tp_traverse */
       0,                              /* tp_clear */
       0,                              /* tp_richcompare */
       0,                              /* tp_weaklistoffset */
       0,                              /* tp_iter */
       0,                              /* tp_iternext */
       0,                              /* tp_methods */
       0,                              /* tp_members */
       0,                              /* tp_getset */
       0,                              /* tp_base */
       0,                              /* tp_dict */
       0,                              /* tp_descr_get */
       0,                              /* tp_descr_set */
       0,                              /* tp_dictoffset */
       0,                              /* tp_init */
       0,                              /* tp_alloc */
       myobj_new,                      /* tp_new */
   };

약한 참조, 인스턴스 딕셔너리 및 해싱을 지원하는 형:

   typedef struct {
       PyObject_HEAD
       const char *data;
       PyObject *inst_dict;
       PyObject *weakreflist;
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject),
       .tp_doc = PyDoc_STR("My objects"),
       .tp_weaklistoffset = offsetof(MyObject, weakreflist),
       .tp_dictoffset = offsetof(MyObject, inst_dict),
       .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
       .tp_new = myobj_new,
       .tp_traverse = (traverseproc)myobj_traverse,
       .tp_clear = (inquiry)myobj_clear,
       .tp_alloc = PyType_GenericNew,
       .tp_dealloc = (destructor)myobj_dealloc,
       .tp_repr = (reprfunc)myobj_repr,
       .tp_hash = (hashfunc)myobj_hash,
       .tp_richcompare = PyBaseObject_Type.tp_richcompare,
   };

A str subclass that cannot be subclassed and cannot be called to
create instances (e.g. uses a separate factory func) using
"Py_TPFLAGS_DISALLOW_INSTANTIATION" flag:

   typedef struct {
       PyUnicodeObject raw;
       char *extra;
   } MyStr;

   static PyTypeObject MyStr_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyStr",
       .tp_basicsize = sizeof(MyStr),
       .tp_base = NULL,  // set to &PyUnicode_Type in module init
       .tp_doc = PyDoc_STR("my custom str"),
       .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,
       .tp_repr = (reprfunc)myobj_repr,
   };

The simplest static type with fixed-length instances:

   typedef struct {
       PyObject_HEAD
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
   };

The simplest static type with variable-length instances:

   typedef struct {
       PyObject_VAR_HEAD
       const char *data[1];
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject) - sizeof(char *),
       .tp_itemsize = sizeof(char *),
   };
