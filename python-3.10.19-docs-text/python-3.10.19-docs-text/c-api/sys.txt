운영 체제 유틸리티
******************

PyObject *PyOS_FSPath(PyObject *path)
    *반환값: 새 참조.** Part of the Stable ABI since version 3.6.*

   *path*에 대한 파일 시스템 표현을 반환합니다. 객체가 "str"이나
   "bytes" 객체이면, 새 *강한 참조*를 반환합니다. 객체가 "os.PathLike"
   인터페이스를 구현하면, "__fspath__()"가 "str"나 "bytes" 객체일 때
   반환됩니다. 그렇지 않으면, "TypeError"가 발생하고 "NULL"이 반환됩니
   다.

   버전 3.6에 추가.

int Py_FdIsInteractive(FILE *fp, const char *filename)

   Return true (nonzero) if the standard I/O file *fp* with name
   *filename* is deemed interactive.  This is the case for files for
   which "isatty(fileno(fp))" is true.  If the global flag
   "Py_InteractiveFlag" is true, this function also returns true if
   the *filename* pointer is "NULL" or if the name is equal to one of
   the strings "'<stdin>'" or "'???'".

void PyOS_BeforeFork()
    * Part of the Stable ABI on platforms with fork() since version
   3.7.*

   프로세스 포크 전에 내부 상태를 준비하는 함수. "fork()"나 현재 프로
   세스를 복제하는 유사한 함수를 호출하기 전에 호출해야 합니다.
   "fork()"가 정의된 시스템에서만 사용 가능합니다.

   경고:

     C "fork()" 호출은 ("메인" 인터프리터의) "메인" 스레드에서만 이루
     어져야 합니다. "PyOS_BeforeFork()"도 마찬가지입니다.

   버전 3.7에 추가.

void PyOS_AfterFork_Parent()
    * Part of the Stable ABI on platforms with fork() since version
   3.7.*

   프로세스 포크 후 일부 내부 상태를 갱신하는 함수. 프로세스 복제가 성
   공했는지와 관계없이, "fork()"나 현재 프로세스를 복제하는 유사한 함
   수를 호출한 후 부모 프로세스에서 호출해야 합니다. "fork()"가 정의된
   시스템에서만 사용 가능합니다.

   경고:

     C "fork()" 호출은 ("메인" 인터프리터의) "메인" 스레드에서만 이루
     어져야 합니다. "PyOS_AfterFork_Parent()"도 마찬가지입니다.

   버전 3.7에 추가.

void PyOS_AfterFork_Child()
    * Part of the Stable ABI on platforms with fork() since version
   3.7.*

   프로세스 포크 후 내부 인터프리터 상태를 갱신하는 함수. "fork()"나
   현재 프로세스를 복제하는 유사한 함수를 호출한 후, 프로세스가 파이썬
   인터프리터를 다시 호출할 가능성이 있으면 자식 프로세스에서 호출해야
   합니다. "fork()"가 정의된 시스템에서만 사용 가능합니다.

   경고:

     C "fork()" 호출은 ("메인" 인터프리터의) "메인" 스레드에서만 이루
     어져야 합니다. "PyOS_AfterFork_Child()"도 마찬가지입니다.

   버전 3.7에 추가.

   더 보기:

     "os.register_at_fork()"를 사용하면 "PyOS_BeforeFork()",
     "PyOS_AfterFork_Parent()" 및 "PyOS_AfterFork_Child()"에서 호출될
     사용자 정의 파이썬 함수를 등록 할 수 있습니다.

void PyOS_AfterFork()
    * Part of the Stable ABI on platforms with fork().*

   프로세스 포크 후 일부 내부 상태를 갱신하는 함수; 파이썬 인터프리터
   가 계속 사용된다면 새로운 프로세스에서 호출되어야 합니다. 새 실행
   파일이 새 프로세스에 로드되면, 이 함수를 호출할 필요가 없습니다.

   버전 3.7부터 폐지: 이 함수는 "PyOS_AfterFork_Child()"로 대체되었습
   니다.

int PyOS_CheckStack()
    * Part of the Stable ABI on platforms with USE_STACKCHECK since
   version 3.7.*

   Return true when the interpreter runs out of stack space.  This is
   a reliable check, but is only available when "USE_STACKCHECK" is
   defined (currently on Windows using the Microsoft Visual C++
   compiler).  "USE_STACKCHECK" will be defined automatically; you
   should never change the definition in your own code.

PyOS_sighandler_t PyOS_getsig(int i)
    * Part of the Stable ABI.*

   Return the current signal handler for signal *i*.  This is a thin
   wrapper around either "sigaction()" or "signal()".  Do not call
   those functions directly! "PyOS_sighandler_t" is a typedef alias
   for "void (*)(int)".

PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)
    * Part of the Stable ABI.*

   Set the signal handler for signal *i* to be *h*; return the old
   signal handler. This is a thin wrapper around either "sigaction()"
   or "signal()".  Do not call those functions directly!
   "PyOS_sighandler_t" is a typedef alias for "void (*)(int)".

wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
    * Part of the Stable ABI since version 3.7.*

   경고:

     This function should not be called directly: use the "PyConfig"
     API with the "PyConfig_SetBytesString()" function which ensures
     that Python is preinitialized.This function must not be called
     before Python is preinitialized and so that the LC_CTYPE locale
     is properly configured: see the "Py_PreInitialize()" function.

   *파일시스템 인코딩과 에러 처리기*로 바이트열을 디코딩합니다. 에러
   처리기가 surrogateescape 에러 처리기면, 디코딩할 수 없는 바이트열은
   U+DC80..U+DCFF 범위의 문자로 디코딩됩니다; 그리고, 바이트 시퀀스를
   서로게이트 문자로 디코딩 할 수 있으면, 이들을 디코딩하는 대신
   surrogateescape 에러 처리기를 사용하여 바이트열를 이스케이프 합니다
   .

   새로 할당된 와이드 문자(wide character) 문자열에 대한 포인터를 반환
   합니다, 메모리를 해제하려면 "PyMem_RawFree()"를 사용하십시오. size
   가 "NULL"이 아니면, 널 문자를 제외한 와이드 문자 수를 "*size"에 기
   록합니다.

   디코딩 에러나 메모리 할당 에러 시 "NULL"을 반환합니다. *size*가
   "NULL"이 아니면, 메모리 에러 시 "*size"가 "(size_t)-1"로 설정되고,
   디코딩 에러 시 "(size_t)-2"로 설정됩니다.

   The *filesystem encoding and error handler* are selected by
   "PyConfig_Read()": see "filesystem_encoding" and
   "filesystem_errors" members of "PyConfig".

   C 라이브러리에 버그가 없으면, 디코딩 에러가 발생하지 않아야 합니다.

   문자열을 바이트열로 다시 인코딩하려면 "Py_EncodeLocale()" 함수를 사
   용하십시오.

   더 보기:

     "PyUnicode_DecodeFSDefaultAndSize()"와
     "PyUnicode_DecodeLocaleAndSize()" 함수.

   버전 3.5에 추가.

   버전 3.7에서 변경: 이 함수는 이제 파이썬 UTF-8 모드에서 UTF-8 인코
   딩을 사용합니다.

   버전 3.8에서 변경: The function now uses the UTF-8 encoding on
   Windows if "Py_LegacyWindowsFSEncodingFlag" is zero;

char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
    * Part of the Stable ABI since version 3.7.*

   와이드 문자(wide character) 문자열을 *파일시스템 인코딩과 에러 처리
   기*로 인코딩합니다. 에러 처리기가 surrogateescape 에러 처리기면
   U+DC80..U+DCFF 범위의 서로게이트 문자는 바이트 0x80..0xFF로 변환됩
   니다.

   새로 할당된 바이트열에 대한 포인터를 반환합니다, 메모리를 해제하려
   면 "PyMem_Free()"를 사용하십시오. 인코딩 에러나 메모리 할당 에러 시
   "NULL"을 반환합니다.

   error_pos가 "NULL"이 아니면, "*error_pos"는 성공 시 "(size_t)-1"로
   설정되고, 인코딩 에러 시 유효하지 않은 문자의 인덱스로 설정됩니다.

   The *filesystem encoding and error handler* are selected by
   "PyConfig_Read()": see "filesystem_encoding" and
   "filesystem_errors" members of "PyConfig".

   바이트열을 와이드 문자 문자열로 다시 디코딩하려면
   "Py_DecodeLocale()" 함수를 사용하십시오.

   경고:

     This function must not be called before Python is preinitialized
     and so that the LC_CTYPE locale is properly configured: see the
     "Py_PreInitialize()" function.

   더 보기: "PyUnicode_EncodeFSDefault()"와 "PyUnicode_EncodeLocale()" 함수.

   버전 3.5에 추가.

   버전 3.7에서 변경: 이 함수는 이제 파이썬 UTF-8 모드에서 UTF-8 인코
   딩을 사용합니다.

   버전 3.8에서 변경: The function now uses the UTF-8 encoding on
   Windows if "Py_LegacyWindowsFSEncodingFlag" is zero.


시스템 함수
***********

"sys" 모듈의 기능을 C 코드에서 액세스 할 수 있게 하는 유틸리티 함수입
니다. 모두 내부 스레드 상태 구조체에 포함된 현재 인터프리터 스레드의
"sys" 모듈의 딕셔너리에 작동합니다.

PyObject *PySys_GetObject(const char *name)
    *반환값: 빌린 참조.** Part of the Stable ABI.*

   "sys" 모듈에서 객체 *name*을 반환하거나, 존재하지 않으면 예외를 설
   정하지 않고 "NULL"을 반환합니다.

int PySys_SetObject(const char *name, PyObject *v)
    * Part of the Stable ABI.*

   *v*가 *NULL*이 아닌 한 "sys" 모듈의 *name*을 *v*로 설정합니다.
   "NULL"이면 *name*은 sys 모듈에서 삭제됩니다. 성공하면 "0", 에러 시
   "-1"을 반환합니다.

void PySys_ResetWarnOptions()
    * Part of the Stable ABI.*

   "sys.warnoptions"를 빈 리스트로 재설정합니다. 이 함수는
   "Py_Initialize()" 이전에 호출할 수 있습니다.

void PySys_AddWarnOption(const wchar_t *s)
    * Part of the Stable ABI.*

   Append *s* to "sys.warnoptions". This function must be called prior
   to "Py_Initialize()" in order to affect the warnings filter list.

void PySys_AddWarnOptionUnicode(PyObject *unicode)
    * Part of the Stable ABI.*

   Append *unicode* to "sys.warnoptions".

   Note: this function is not currently usable from outside the
   CPython implementation, as it must be called prior to the implicit
   import of "warnings" in "Py_Initialize()" to be effective, but
   can't be called until enough of the runtime has been initialized to
   permit the creation of Unicode objects.

void PySys_SetPath(const wchar_t *path)
    * Part of the Stable ABI.*

   Set "sys.path" to a list object of paths found in *path* which
   should be a list of paths separated with the platform's search path
   delimiter (":" on Unix, ";" on Windows).

void PySys_WriteStdout(const char *format, ...)
    * Part of the Stable ABI.*

   *format*으로 기술되는 출력 문자열을 "sys.stdout"에 기록합니다. 잘림
   이 발생하더라도 예외는 발생하지 않습니다 (아래를 참조하십시오).

   *format*은 포맷된 출력 문자열의 총 크기를 1000바이트 이하로 제한해
   야 합니다 -- 1000바이트 이후에는, 출력 문자열이 잘립니다. 특히, 이
   것은 무제한 "%s" 포맷이 있어서는 안 됨을 의미합니다; "%.<N>s"를 사
   용하여 제한해야 합니다, 여기서 <N>은 <N>에 다른 포맷된 텍스트의 최
   대 크기를 더할 때 1000바이트를 초과하지 않도록 계산된 십진수입니다.
   또한 "%f"도 주의하십시오, 아주 큰 숫자는 수백 자리를 인쇄할 수 있습
   니다.

   문제가 발생하거나, "sys.stdout"가 설정되어 있지 않으면, 포맷된 메시
   지는 실제(C 수준) *stdout*에 기록됩니다.

void PySys_WriteStderr(const char *format, ...)
    * Part of the Stable ABI.*

   "PySys_WriteStdout()"과 같지만, 대신 "sys.stderr"이나 *stderr*에 씁
   니다.

void PySys_FormatStdout(const char *format, ...)
    * Part of the Stable ABI.*

   PySys_WriteStdout()과 유사한 함수이지만, 메시지를
   "PyUnicode_FromFormatV()"를 사용하여 포맷하고 메시지를 임의의 길이
   로 자르지 않습니다.

   버전 3.2에 추가.

void PySys_FormatStderr(const char *format, ...)
    * Part of the Stable ABI.*

   "PySys_FormatStdout()"과 같지만, 대신 "sys.stderr"이나 *stderr*에
   씁니다.

   버전 3.2에 추가.

void PySys_AddXOption(const wchar_t *s)
    * Part of the Stable ABI since version 3.7.*

   Parse *s* as a set of "-X" options and add them to the current
   options mapping as returned by "PySys_GetXOptions()". This function
   may be called prior to "Py_Initialize()".

   버전 3.2에 추가.

PyObject *PySys_GetXOptions()
    *반환값: 빌린 참조.** Part of the Stable ABI since version 3.7.*

   "sys._xoptions"와 유사하게, "-X" 옵션의 현재 딕셔너리를 반환합니다.
   에러가 발생하면, "NULL"이 반환되고 예외가 설정됩니다.

   버전 3.2에 추가.

int PySys_Audit(const char *event, const char *format, ...)

   모든 활성 훅으로 감사 이벤트를 발생시킵니다. 성공 시 0을 반환하고
   실패 시 예외를 설정하여 0이 아닌 값을 반환합니다.

   If any hooks have been added, *format* and other arguments will be
   used to construct a tuple to pass. Apart from "N", the same format
   characters as used in "Py_BuildValue()" are available. If the built
   value is not a tuple, it will be added into a single-element tuple.
   (The "N" format option consumes a reference, but since there is no
   way to know whether arguments to this function will be consumed,
   using it may cause reference leaks.)

   "PY_SSIZE_T_CLEAN"이 정의되었는지와 관계없이, "#" 포맷 문자는 항상
   "Py_ssize_t"로 처리되어야 합니다.

   "sys.audit()"은 파이썬 코드와 동일한 기능을 수행합니다.

   버전 3.8에 추가.

   버전 3.8.2에서 변경: "#" 포맷 문자에 대해 "Py_ssize_t"를 요구합니다
   . 이전에는, 피할 수 없는 폐지 경고가 발생했습니다.

int PySys_AddAuditHook(Py_AuditHookFunction hook, void *userData)

   활성 감사 훅 리스트에 콜러블 *hook*을 추가합니다. 성공하면 0을, 실
   패하면 0이 아닌 값을 반환합니다. 런타임이 초기화되었으면, 실패 시
   에러도 설정합니다. 이 API를 통해 추가된 훅은 런타임이 만든 모든 인
   터프리터에 대해 호출됩니다.

   *userData* 포인터는 훅 함수로 전달됩니다. 훅 함수는 다른 런타임에서
   호출될 수 있어서, 이 포인터는 파이썬 상태를 직접 참조하면 안 됩니다
   .

   이 함수는 "Py_Initialize()" 이전에 호출해도 안전합니다. 런타임 초기
   화 후 호출되면, 기존 감사 훅에 알리고 "Exception"에서 서브 클래싱
   된 에러를 발생 시켜 조용히 연산을 중단할 수 있습니다 (다른 에러는
   억제되지(silenced) 않습니다).

   The hook function is of type "int (*)(const char *event, PyObject
   *args, void *userData)", where *args* is guaranteed to be a
   "PyTupleObject". The hook function is always called with the GIL
   held by the Python interpreter that raised the event.

   감사에 대한 자세한 설명은 **PEP 578**을 참조하십시오. 이벤트를 발생
   시키는 런타임과 표준 라이브러리의 함수는 감사 이벤트 표에 나열되어
   있습니다. 자세한 내용은 각 함수 설명서에 있습니다.

   If the interpreter is initialized, this function raises a auditing
   event "sys.addaudithook" with no arguments. If any existing hooks
   raise an exception derived from "Exception", the new hook will not
   be added and the exception is cleared. As a result, callers cannot
   assume that their hook has been added unless they control all
   existing hooks.

   버전 3.8에 추가.


프로세스 제어
*************

void Py_FatalError(const char *message)
    * Part of the Stable ABI.*

   Print a fatal error message and kill the process.  No cleanup is
   performed. This function should only be invoked when a condition is
   detected that would make it dangerous to continue using the Python
   interpreter; e.g., when the object administration appears to be
   corrupted.  On Unix, the standard C library function "abort()" is
   called which will attempt to produce a "core" file.

   "Py_LIMITED_API" 매크로가 정의되어 있지 않은 한, "Py_FatalError()"
   함수는 현재 함수의 이름을 자동으로 로그 하는 매크로로 대체됩니다.

   버전 3.9에서 변경: 함수 이름을 자동으로 로그 합니다.

void Py_Exit(int status)
    * Part of the Stable ABI.*

   현재 프로세스를 종료합니다. 이것은 "Py_FinalizeEx()"를 호출한 다음
   표준 C 라이브러리 함수 "exit(status)"를 호출합니다.
   "Py_FinalizeEx()"가 에러를 표시하면, 종료 상태는 120으로 설정됩니다
   .

   버전 3.6에서 변경: 파이널리제이션에서의 에러가 더는 무시되지 않습니
   다.

int Py_AtExit(void (*func)())
    * Part of the Stable ABI.*

   "Py_FinalizeEx()"가 호출할 정리 함수를 등록합니다. 정리 함수는 인자
   없이 호출되며 값을 반환하지 않아야 합니다. 최대 32개의 정리 함수를
   등록할 수 있습니다. 등록이 성공하면, "Py_AtExit()"는 "0"을 반환합니
   다; 실패하면 "-1"을 반환합니다. 마지막에 등록된 정리 함수가 먼저 호
   출됩니다. 각 정리 함수는 최대 한 번 호출됩니다. 정리 함수 전에 파이
   썬의 내부 파이널리제이션이 완료되기 때문에, *func*에서 파이썬 API를
   호출하면 안 됩니다.
