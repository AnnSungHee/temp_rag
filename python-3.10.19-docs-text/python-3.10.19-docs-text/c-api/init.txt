초기화, 파이널리제이션 및 스레드
********************************

See also Python Initialization Configuration.


파이썬 초기화 전
================

파이썬을 내장한 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기
전에 "Py_Initialize()" 함수를 호출해야 합니다; 몇 가지 함수와 전역 구
성 변수는 예외입니다.

파이썬이 초기화되기 전에 다음 함수를 안전하게 호출할 수 있습니다:

* 구성 함수:

  * "PyImport_AppendInittab()"

  * "PyImport_ExtendInittab()"

  * "PyInitFrozenExtensions()"

  * "PyMem_SetAllocator()"

  * "PyMem_SetupDebugHooks()"

  * "PyObject_SetArenaAllocator()"

  * "Py_SetPath()"

  * "Py_SetProgramName()"

  * "Py_SetPythonHome()"

  * "Py_SetStandardStreamEncoding()"

  * "PySys_AddWarnOption()"

  * "PySys_AddXOption()"

  * "PySys_ResetWarnOptions()"

* 정보 함수:

  * "Py_IsInitialized()"

  * "PyMem_GetAllocator()"

  * "PyObject_GetArenaAllocator()"

  * "Py_GetBuildInfo()"

  * "Py_GetCompiler()"

  * "Py_GetCopyright()"

  * "Py_GetPlatform()"

  * "Py_GetVersion()"

* 유틸리티:

  * "Py_DecodeLocale()"

* 메모리 할당자:

  * "PyMem_RawMalloc()"

  * "PyMem_RawRealloc()"

  * "PyMem_RawCalloc()"

  * "PyMem_RawFree()"

참고:

  The following functions **should not be called** before
  "Py_Initialize()": "Py_EncodeLocale()", "Py_GetPath()",
  "Py_GetPrefix()", "Py_GetExecPrefix()", "Py_GetProgramFullPath()",
  "Py_GetPythonHome()", "Py_GetProgramName()" and
  "PyEval_InitThreads()".


전역 구성 변수
==============

파이썬에는 다양한 기능과 옵션을 제어하기 위한 전역 구성 변수가 있습니
다. 기본적으로, 이러한 플래그는 명령 줄 옵션에 의해 제어됩니다.

옵션에 의해 플래그가 설정되면, 플래그 값은 옵션이 설정된 횟수입니다.
예를 들어, "-b"는 "Py_BytesWarningFlag" 를 1로 설정하고 "-bb"는
"Py_BytesWarningFlag" 를 2로 설정합니다.

int Py_BytesWarningFlag

   "bytes"나 "bytearray"와 "str"을, 또는 "bytes"를 "int"와 비교할 때
   경고를 발행합니다. "2"보다 크거나 같으면 에러를 발행합니다.

   "-b" 옵션으로 설정합니다.

int Py_DebugFlag

   구문 분석기 디버깅 출력을 켭니다 (전문가 전용, 컴파일 옵션에 의존합
   니다).

   "-d" 옵션과 "PYTHONDEBUG" 환경 변수로 설정됩니다.

int Py_DontWriteBytecodeFlag

   0이 아닌 값으로 설정하면, 파이썬은 소스 모듈을 임포트 할 때 ".pyc"
   파일을 쓰려고 하지 않습니다.

   "-B" 옵션과 "PYTHONDONTWRITEBYTECODE" 환경 변수로 설정됩니다.

int Py_FrozenFlag

   "Py_GetPath()"에서 모듈 검색 경로를 계산할 때 에러 메시지를 표시하
   지 않습니다.

   Private flag used by "_freeze_importlib" and "frozenmain" programs.

int Py_HashRandomizationFlag

   "PYTHONHASHSEED" 환경 변수가 비어 있지 않은 문자열로 설정되면 "1"로
   설정합니다.

   플래그가 0이 아니면, "PYTHONHASHSEED" 환경 변수를 읽어 비밀 해시 시
   드를 초기화합니다.

int Py_IgnoreEnvironmentFlag

   Ignore all "PYTHON*" environment variables, e.g. "PYTHONPATH" and
   "PYTHONHOME", that might be set.

   "-E"와 "-I" 옵션으로 설정됩니다.

int Py_InspectFlag

   스크립트가 첫 번째 인자로 전달되거나 "-c" 옵션을 사용할 때,
   "sys.stdin"가 터미널로 보이지 않더라도 스크립트나 명령을 실행한 후
   대화 형 모드로 들어갑니다.

   "-i" 옵션과 "PYTHONINSPECT" 환경 변수로 설정됩니다.

int Py_InteractiveFlag

   "-i" 옵션으로 설정됩니다.

int Py_IsolatedFlag

   격리 모드로 파이썬을 실행합니다. 격리 모드에서 "sys.path"는 스크립
   트의 디렉터리도 사용자의 site-packages 디렉터리도 포함하지 않습니다
   .

   "-I" 옵션으로 설정됩니다.

   버전 3.4에 추가.

int Py_LegacyWindowsFSEncodingFlag

   If the flag is non-zero, use the "mbcs" encoding with "replace"
   error handler, instead of the UTF-8 encoding with "surrogatepass"
   error handler, for the *filesystem encoding and error handler*.

   "PYTHONLEGACYWINDOWSFSENCODING" 환경 변수가 비어 있지 않은 문자열로
   설정되면 "1"로 설정합니다.

   자세한 내용은 **PEP 529**를 참조하십시오.

   Availability: Windows.

int Py_LegacyWindowsStdioFlag

   If the flag is non-zero, use "io.FileIO" instead of
   "WindowsConsoleIO" for "sys" standard streams.

   "PYTHONLEGACYWINDOWSSTDIO" 환경 변수가 비어 있지 않은 문자열로 설정
   되면 "1"로 설정합니다.

   자세한 내용은 **PEP 528**을 참조하십시오.

   Availability: Windows.

int Py_NoSiteFlag

   모듈 "site" 임포트와 이에 수반되는 "sys.path"의 사이트 종속적인 조
   작을 비활성화합니다. 또한 나중에 "site"를 명시적으로 임포트 할 때도
   이러한 조작을 비활성화합니다 (트리거 하려면 "site.main()"을 호출하
   십시오).

   "-S" 옵션으로 설정됩니다.

int Py_NoUserSiteDirectory

   "사용자 site-packages 디렉터리"를 "sys.path"에 추가하지 않습니다.

   "-s"와 "-I" 옵션, 그리고 "PYTHONNOUSERSITE" 환경 변수로 설정됩니다.

int Py_OptimizeFlag

   "-O" 옵션과 "PYTHONOPTIMIZE" 환경 변수로 설정됩니다.

int Py_QuietFlag

   대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다.

   "-q" 옵션으로 설정됩니다.

   버전 3.2에 추가.

int Py_UnbufferedStdioFlag

   stdout과 stderr 스트림을 버퍼링 해제하도록 강제합니다.

   "-u" 옵션과 "PYTHONUNBUFFERED" 환경 변수로 설정됩니다.

int Py_VerboseFlag

   모듈이 초기화될 때마다, 로드된 위치(파일명이나 내장 모듈)를 표시하
   는 메시지를 인쇄합니다. "2"보다 크거나 같으면, 모듈을 검색할 때 검
   사되는 각 파일에 대한 메시지를 인쇄합니다. 또한 종료 시 모듈 정리에
   대한 정보를 제공합니다.

   "-v" 옵션과 "PYTHONVERBOSE" 환경 변수로 설정됩니다.


인터프리터 초기화와 파이널리제이션
==================================

void Py_Initialize()
    * Part of the Stable ABI.*

   파이썬 인터프리터를 초기화합니다. 파이썬을 내장하는 응용 프로그램에
   서는, 다른 파이썬/C API 함수를 사용하기 전에 호출해야 합니다; 몇 가
   지 예외는 파이썬 초기화 전을 참조하십시오.

   This initializes the table of loaded modules ("sys.modules"), and
   creates the fundamental modules "builtins", "__main__" and "sys".
   It also initializes the module search path ("sys.path"). It does
   not set "sys.argv"; use "PySys_SetArgvEx()" for that.  This is a
   no-op when called for a second time (without calling
   "Py_FinalizeEx()" first).  There is no return value; it is a fatal
   error if the initialization fails.

   참고:

     윈도우에서, 콘솔 모드를 "O_TEXT"에서 "O_BINARY"로 변경합니다, C
     런타임을 사용하는 콘솔의 비 파이썬 사용에도 영향을 미칩니다.

void Py_InitializeEx(int initsigs)
    * Part of the Stable ABI.*

   This function works like "Py_Initialize()" if *initsigs* is "1". If
   *initsigs* is "0", it skips initialization registration of signal
   handlers, which might be useful when Python is embedded.

int Py_IsInitialized()
    * Part of the Stable ABI.*

   파이썬 인터프리터가 초기화되었으면 참(0이 아님)을 반환하고, 그렇지
   않으면 거짓(0)을 반환합니다. "Py_FinalizeEx()" 가 호출된 후,
   "Py_Initialize()"가 다시 호출될 때까지 거짓을 반환합니다.

int Py_FinalizeEx()
    * Part of the Stable ABI since version 3.6.*

   Undo all initializations made by "Py_Initialize()" and subsequent
   use of Python/C API functions, and destroy all sub-interpreters
   (see "Py_NewInterpreter()" below) that were created and not yet
   destroyed since the last call to "Py_Initialize()".  Ideally, this
   frees all memory allocated by the Python interpreter.  This is a
   no-op when called for a second time (without calling
   "Py_Initialize()" again first).  Normally the return value is "0".
   If there were errors during finalization (flushing buffered data),
   "-1" is returned.

   이 함수는 여러 가지 이유로 제공됩니다. 내장 응용 프로그램이 응용 프
   로그램 자체를 다시 시작하지 않고 파이썬을 다시 시작하고 싶을 수 있
   습니다. 동적으로 로드할 수 있는 라이브러리(또는 DLL)에서 파이썬 인
   터프리터를 로드한 응용 프로그램은 DLL을 언로드 하기 전에 파이썬이
   할당한 모든 메모리를 해제하고 싶을 수 있습니다. 응용 프로그램에서
   메모리 누수를 찾는 동안 개발자는 응용 프로그램을 종료하기 전에 파이
   썬에서 할당한 모든 메모리를 해제하고 싶을 것입니다.

   **Bugs and caveats:** The destruction of modules and objects in
   modules is done in random order; this may cause destructors
   ("__del__()" methods) to fail when they depend on other objects
   (even functions) or modules.  Dynamically loaded extension modules
   loaded by Python are not unloaded.  Small amounts of memory
   allocated by the Python interpreter may not be freed (if you find a
   leak, please report it).  Memory tied up in circular references
   between objects is not freed.  Some memory allocated by extension
   modules may not be freed.  Some extensions may not work properly if
   their initialization routine is called more than once; this can
   happen if an application calls "Py_Initialize()" and
   "Py_FinalizeEx()" more than once.

   인자 없이 감사 이벤트 "cpython._PySys_ClearAuditHooks" 를 발생시킵
   니다.

   버전 3.6에 추가.

void Py_Finalize()
    * Part of the Stable ABI.*

   이것은 "Py_FinalizeEx()"의 이전 버전과 호환되는 반환 값을 무시하는
   버전입니다.


프로세스 전체 매개 변수
=======================

int Py_SetStandardStreamEncoding(const char *encoding, const char *errors)

   This function should be called before "Py_Initialize()", if it is
   called at all. It specifies which encoding and error handling to
   use with standard IO, with the same meanings as in "str.encode()".

   It overrides "PYTHONIOENCODING" values, and allows embedding code
   to control IO encoding when the environment variable does not work.

   *encoding* and/or *errors* may be "NULL" to use "PYTHONIOENCODING"
   and/or default values (depending on other settings).

   Note that "sys.stderr" always uses the "backslashreplace" error
   handler, regardless of this (or any other) setting.

   If "Py_FinalizeEx()" is called, this function will need to be
   called again in order to affect subsequent calls to
   "Py_Initialize()".

   Returns "0" if successful, a nonzero value on error (e.g. calling
   after the interpreter has already been initialized).

   버전 3.4에 추가.

void Py_SetProgramName(const wchar_t *name)
    * Part of the Stable ABI.*

   (호출된다면) 이 함수는 "Py_Initialize()"가 처음으로 호출되기 전에
   호출되어야 합니다. 인터프리터에게 프로그램의 "main()" 함수에 대한
   "argv[0]" 인자의 값을 알려줍니다 (와이드 문자로 변환됩니다). 이것은
   "Py_GetPath()"와 아래의 다른 함수에서 인터프리터 실행 파일과 관련된
   파이썬 런타임 라이브러리를 찾는 데 사용됩니다. 기본값은 "'python'"
   입니다. 인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적
   저장소의 0으로 끝나는 와이드 문자열을 가리켜야 합니다. 파이썬 인터
   프리터의 코드는 이 저장소의 내용을 변경하지 않습니다.

   Use "Py_DecodeLocale()" to decode a bytes string to get a "wchar_*"
   string.

wchar *Py_GetProgramName()
    * Part of the Stable ABI.*

   Return the program name set with "Py_SetProgramName()", or the
   default. The returned string points into static storage; the caller
   should not modify its value.

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".

wchar_t *Py_GetPrefix()
    * Part of the Stable ABI.*

   Return the *prefix* for installed platform-independent files. This
   is derived through a number of complicated rules from the program
   name set with "Py_SetProgramName()" and some environment variables;
   for example, if the program name is "'/usr/local/bin/python'", the
   prefix is "'/usr/local'". The returned string points into static
   storage; the caller should not modify its value.  This corresponds
   to the **prefix** variable in the top-level "Makefile" and the "--
   prefix" argument to the **configure** script at build time.  The
   value is available to Python code as "sys.prefix". It is only
   useful on Unix.  See also the next function.

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".

wchar_t *Py_GetExecPrefix()
    * Part of the Stable ABI.*

   Return the *exec-prefix* for installed platform-*dependent* files.
   This is derived through a number of complicated rules from the
   program name set with "Py_SetProgramName()" and some environment
   variables; for example, if the program name is
   "'/usr/local/bin/python'", the exec-prefix is "'/usr/local'".  The
   returned string points into static storage; the caller should not
   modify its value.  This corresponds to the **exec_prefix** variable
   in the top-level "Makefile" and the "--exec-prefix" argument to the
   **configure** script at build  time.  The value is available to
   Python code as "sys.exec_prefix".  It is only useful on Unix.

   배경: exec-prefix는 플랫폼 종속적 파일(가령 실행 파일과 공유 라이브
   러리)이 다른 디렉터리 트리에 설치될 때 prefix와 다릅니다. 일반 설치
   에서, 플랫폼 종속적 파일은 "/usr/local/plat" 서브 트리에 설치되고
   플랫폼 독립적 파일은 "/usr/local"에 설치될 수 있습니다.

   일반적으로 말해서, 플랫폼은 하드웨어와 소프트웨어 제품군의 조합입니
   다, 예를 들어 Solaris 2.x 운영 체제를 실행하는 Sparc 기계들은 같은
   플랫폼으로 간주하지만, Solaris 2.x를 실행하는 Intel 기계는 다른 플
   랫폼이며, 리눅스를 실행하는 Intel 기계는 또 다른 플랫폼입니다. 같은
   운영 체제의 서로 다른 주 개정판도 일반적으로 다른 플랫폼을 형성합니
   다. 비 유닉스 운영 체제는 다른 이야기입니다; 이러한 시스템의 설치
   전략이 너무 다르기 때문에 prefix와 exec-prefix는 의미가 없으며, 빈
   문자열로 설정됩니다. 컴파일된 파이썬 바이트 코드 파일은 플랫폼 독립
   적임에 유의하십시오 (그러나 이들을 컴파일하는데 사용된 파이썬 버전
   에는 종속적입니다!).

   시스템 관리자는 "/usr/local/plat"을 각 플랫폼에 대해 다른 파일 시스
   템으로 사용하면서 플랫폼 간에 "/usr/local"을 공유하도록 **mount**나
   **automount** 프로그램을 구성하는 방법을 알 것입니다.

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".

wchar_t *Py_GetProgramFullPath()
    * Part of the Stable ABI.*

   Return the full program name of the Python executable; this is
   computed as a side-effect of deriving the default module search
   path  from the program name (set by "Py_SetProgramName()" above).
   The returned string points into static storage; the caller should
   not modify its value.  The value is available to Python code as
   "sys.executable".

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".

wchar_t *Py_GetPath()
    * Part of the Stable ABI.*

   Return the default module search path; this is computed from the
   program name (set by "Py_SetProgramName()" above) and some
   environment variables. The returned string consists of a series of
   directory names separated by a platform dependent delimiter
   character.  The delimiter character is "':'" on Unix and macOS,
   "';'" on Windows.  The returned string points into static storage;
   the caller should not modify its value.  The list "sys.path" is
   initialized with this value on interpreter startup; it can be (and
   usually is) modified later to change the search path for loading
   modules.

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".

void Py_SetPath(const wchar_t*)
    * Part of the Stable ABI since version 3.7.*

   Set the default module search path.  If this function is called
   before "Py_Initialize()", then "Py_GetPath()" won't attempt to
   compute a default search path but uses the one provided instead.
   This is useful if Python is embedded by an application that has
   full knowledge of the location of all modules.  The path components
   should be separated by the platform dependent delimiter character,
   which is "':'" on Unix and macOS, "';'" on Windows.

   This also causes "sys.executable" to be set to the program full
   path (see "Py_GetProgramFullPath()") and for "sys.prefix" and
   "sys.exec_prefix" to be empty.  It is up to the caller to modify
   these if required after calling "Py_Initialize()".

   Use "Py_DecodeLocale()" to decode a bytes string to get a "wchar_*"
   string.

   The path argument is copied internally, so the caller may free it
   after the call completes.

   버전 3.8에서 변경: The program full path is now used for
   "sys.executable", instead of the program name.

const char *Py_GetVersion()
    * Part of the Stable ABI.*

   이 파이썬 인터프리터의 버전을 반환합니다. 이것은 다음과 같은 문자열
   입니다

      "3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \n[GCC 4.2.3]"

   The first word (up to the first space character) is the current
   Python version; the first characters are the major and minor
   version separated by a period.  The returned string points into
   static storage; the caller should not modify its value.  The value
   is available to Python code as "sys.version".

const char *Py_GetPlatform()
    * Part of the Stable ABI.*

   Return the platform identifier for the current platform.  On Unix,
   this is formed from the "official" name of the operating system,
   converted to lower case, followed by the major revision number;
   e.g., for Solaris 2.x, which is also known as SunOS 5.x, the value
   is "'sunos5'".  On macOS, it is "'darwin'".  On Windows, it is
   "'win'".  The returned string points into static storage; the
   caller should not modify its value.  The value is available to
   Python code as "sys.platform".

const char *Py_GetCopyright()
    * Part of the Stable ABI.*

   현재 파이썬 버전에 대한 공식 저작권 문자열을 반환합니다, 예를 들어

   "'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'"

   반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는
   안 됩니다. 이 값은 파이썬 코드에서 "sys.copyright"로 사용할 수 있습
   니다.

const char *Py_GetCompiler()
    * Part of the Stable ABI.*

   현재 파이썬 버전을 빌드하는 데 사용된 컴파일러 표시를 대괄호 감싸서
   반환합니다, 예를 들면:

      "[GCC 2.7.2.2]"

   반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는
   안 됩니다. 이 값은 파이썬 코드에서 변수 "sys.version"의 일부로 제공
   됩니다.

const char *Py_GetBuildInfo()
    * Part of the Stable ABI.*

   현재 파이썬 인터프리터 인스턴스의 시퀀스 번호와 빌드 날짜 및 시간에
   대한 정보를 반환합니다, 예를 들어

      "#67, Aug  1 1997, 22:34:28"

   반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는
   안 됩니다. 이 값은 파이썬 코드에서 변수 "sys.version"의 일부로 제공
   됩니다.

void PySys_SetArgvEx(int argc, wchar_t **argv, int updatepath)
    * Part of the Stable ABI.*

   *argc* 및 *argv*에 기반해서 "sys.argv"를 설정합니다. 이 매개 변수는
   프로그램의 "main()" 함수에 전달된 것과 유사하지만, 첫 번째 항목이
   파이썬 인터프리터를 호스팅하는 실행 파일이 아니라 실행될 스크립트
   파일을 참조해야 한다는 차이점이 있습니다. 실행할 스크립트가 없으면,
   *argv*의 첫 번째 항목은 빈 문자열일 수 있습니다. 이 함수가
   "sys.argv" 초기화에 실패하면, "Py_FatalError()"를 사용하여 치명적인
   조건을 표시합니다.

   *updatepath*가 0이면, 여기까지가 이 함수가 하는 모든 일입니다.
   *updatepath*가 0이 아니면, 함수는 다음 알고리즘에 따라 "sys.path"도
   수정합니다:

   * 기존 스크립트의 이름이 "argv[0]"으로 전달되면, 스크립트가 있는 디
     렉터리의 절대 경로가 "sys.path" 앞에 추가됩니다.

   * 그렇지 않으면 (즉, *argc*가 "0"이거나 "argv[0]"이 기존 파일 이름
     을 가리키지 않으면), "sys.path" 앞에 빈 문자열이 추가됩니다, 이는
     현재 작업 디렉터리(""."")를 앞에 추가하는 것과 같습니다.

   Use "Py_DecodeLocale()" to decode a bytes string to get a "wchar_*"
   string.

   참고:

     It is recommended that applications embedding the Python
     interpreter for purposes other than executing a single script
     pass "0" as *updatepath*, and update "sys.path" themselves if
     desired. See CVE-2008-5983.3.1.3 이전 버전에서는,
     "PySys_SetArgv()"를 호출한 후 첫 번째 "sys.path" 요소를 수동으로
     제거하여 같은 효과를 얻을 수 있습니다, 예를 들어 다음을 사용하여:

        PyRun_SimpleString("import sys; sys.path.pop(0)\n");

   버전 3.1.3에 추가.

void PySys_SetArgv(int argc, wchar_t **argv)
    * Part of the Stable ABI.*

   이 함수는 **python** 인터프리터가 "-I"로 시작되지 않는 한
   *updatepath*가 "1"로 설정된 "PySys_SetArgvEx()"처럼 작동합니다.

   Use "Py_DecodeLocale()" to decode a bytes string to get a "wchar_*"
   string.

   버전 3.4에서 변경: *updatepath* 값은 "-I"에 따라 다릅니다.

void Py_SetPythonHome(const wchar_t *home)
    * Part of the Stable ABI.*

   기본 "홈" 디렉터리, 즉 표준 파이썬 라이브러리의 위치를 설정합니다.
   인자 문자열의 의미는 "PYTHONHOME" 을 참조하십시오.

   인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적 저장소에
   있는 0으로 끝나는 문자열을 가리켜야 합니다. 파이썬 인터프리터의 코
   드는 이 저장소의 내용을 변경하지 않습니다.

   Use "Py_DecodeLocale()" to decode a bytes string to get a "wchar_*"
   string.

wchar_t *Py_GetPythonHome()
    * Part of the Stable ABI.*

   Return the default "home", that is, the value set by a previous
   call to "Py_SetPythonHome()", or the value of the "PYTHONHOME"
   environment variable if it is set.

   This function should not be called before "Py_Initialize()",
   otherwise it returns "NULL".

   버전 3.10에서 변경: It now returns "NULL" if called before
   "Py_Initialize()".


스레드 상태와 전역 인터프리터 록
================================

파이썬 인터프리터는 완전히 스레드 안전하지 않습니다. 다중 스레드 파이
썬 프로그램을 지원하기 위해, 파이썬 객체에 안전하게 액세스하기 전에 현
재 스레드가 보유해야 하는 *전역 인터프리터 록* 혹은 *GIL*이라고 하는
전역 록이 있습니다. 록 없이는, 가장 간단한 연산조차도 다중 스레드 프로
그램에서 문제를 일으킬 수 있습니다: 예를 들어, 두 스레드가 동시에 같은
객체의 참조 횟수를 증가시키면, 참조 횟수가 두 번이 아닌 한 번만 증가할
수 있습니다.

따라서, *GIL*을 획득한 스레드만 파이썬 객체에서 작동하거나 파이썬/C
API 함수를 호출할 수 있다는 규칙이 있습니다. 동시 실행을 모방하기 위해
인터프리터는 정기적으로 스레드 전환을 시도합니다
("sys.setswitchinterval()"을 참조하십시오). 록은 파일 읽기나 쓰기와 같
은 잠재적인 블로킹 I/O 연산에 대해서도 해제되므로, 그동안 다른 파이썬
스레드가 실행될 수 있습니다.

파이썬 인터프리터는 "PyThreadState" 라는 데이터 구조체 내에 스레드 별
부기(bookkeeping) 정보를 보관합니다. 현재 "PyThreadState" 를 가리키는
하나의 전역 변수도 있습니다: "PyThreadState_Get()"을 사용하여 얻을 수
있습니다.


확장 코드에서 GIL 해제하기
--------------------------

*GIL*을 조작하는 대부분의 확장 코드는 다음과 같은 간단한 구조로 되어
있습니다:

   Save the thread state in a local variable.
   Release the global interpreter lock.
   ... Do some blocking I/O operation ...
   Reacquire the global interpreter lock.
   Restore the thread state from the local variable.

이것은 매우 일반적이어서 이를 단순화하기 위해 한 쌍의 매크로가 존재합
니다:

   Py_BEGIN_ALLOW_THREADS
   ... Do some blocking I/O operation ...
   Py_END_ALLOW_THREADS

"Py_BEGIN_ALLOW_THREADS" 매크로는 새 블록을 열고 숨겨진 지역 변수를 선
언합니다; "Py_END_ALLOW_THREADS" 매크로는 블록을 닫습니다.

위의 블록은 다음 코드로 확장됩니다:

   PyThreadState *_save;

   _save = PyEval_SaveThread();
   ... Do some blocking I/O operation ...
   PyEval_RestoreThread(_save);

이 함수들의 작동 방식은 다음과 같습니다: 전역 인터프리터 록이 현재 스
레드 상태에 대한 포인터를 보호하는 데 사용됩니다. 록을 해제하고 스레드
상태를 저장할 때, 록이 해제되기 전에 현재 스레드 상태 포인터를 가져와
야 합니다 (다른 스레드가 즉시 록을 획득하고 전역 변수에 자신의 스레드
상태를 저장할 수 있기 때문입니다). 반대로, 록을 획득하고 스레드 상태를
복원할 때, 스레드 상태 포인터를 저장하기 전에 록을 획득해야 합니다.

참고:

  시스템 I/O 함수 호출은 GIL을 릴리스하는 가장 일반적인 사용 사례이지
  만, 메모리 버퍼를 통해 작동하는 압축이나 암호화 함수와 같이, 파이썬
  객체에 액세스할 필요가 없는 장기 실행 계산을 호출하기 전에도 유용할
  수 있습니다. 예를 들어, 표준 "zlib"와 "hashlib" 모듈은 데이터를 압축
  하거나 해싱할 때 GIL을 해제합니다.


파이썬이 만들지 않은 스레드
---------------------------

전용 파이썬 API(가령 "threading" 모듈)를 사용하여 스레드를 만들면, 스
레드 상태가 자동으로 연결되므로 위에 표시된 코드가 올바릅니다. 그러나,
스레드가 C에서 만들어질 때 (예를 들어 자체 스레드 관리 기능이 있는 제
삼자 라이브러리에 의해), GIL을 보유하지 않고, 그들을 위한 스레드 상태
구조도 없습니다.

이러한 스레드에서 파이썬 코드를 호출해야 하면 (종종 앞서 언급한 제삼자
라이브러리에서 제공하는 콜백 API의 일부가 됩니다), 먼저 스레드 상태 자
료 구조를 만들어서 인터프리터에 이러한 스레드를 등록한 다음, GIL을 획
득하고, 마지막으로 파이썬/C API 사용을 시작하기 전에 스레드 상태 포인
터를 저장합니다. 완료되면, 스레드 상태 포인터를 재설정하고, GIL을 해제
한 다음, 마지막으로 스레드 상태 자료 구조를 해제해야 합니다.

"PyGILState_Ensure()"와 "PyGILState_Release()" 함수는 위의 모든 작업을
자동으로 수행합니다. C 스레드에서 파이썬을 호출하는 일반적인 관용구는
다음과 같습니다:

   PyGILState_STATE gstate;
   gstate = PyGILState_Ensure();

   /* Perform Python actions here. */
   result = CallSomeFunction();
   /* evaluate result or handle exception */

   /* Release the thread. No Python API allowed beyond this point. */
   PyGILState_Release(gstate);

Note that the "PyGILState_*" functions assume there is only one global
interpreter (created automatically by "Py_Initialize()").  Python
supports the creation of additional interpreters (using
"Py_NewInterpreter()"), but mixing multiple interpreters and the
"PyGILState_*" API is unsupported.


fork()에 대한 주의 사항
-----------------------

스레드에 대해 주목해야 할 또 다른 중요한 점은 C "fork()" 호출 시 스레
드의 동작입니다. "fork()"를 사용하는 대부분의 시스템에서는, 프로세스가
포크한 후에 포크를 발행한 스레드만 존재합니다. 이는 록을 처리해야 하는
방법과 CPython 런타임에 저장된 모든 상태 모두에 구체적인 영향을 미칩니
다.

The fact that only the "current" thread remains means any locks held
by other threads will never be released. Python solves this for
"os.fork()" by acquiring the locks it uses internally before the fork,
and releasing them afterwards. In addition, it resets any Lock 객체 in
the child. When extending or embedding Python, there is no way to
inform Python of additional (non-Python) locks that need to be
acquired before or reset after a fork. OS facilities such as
"pthread_atfork()" would need to be used to accomplish the same thing.
Additionally, when extending or embedding Python, calling "fork()"
directly rather than through "os.fork()" (and returning to or calling
into Python) may result in a deadlock by one of Python's internal
locks being held by a thread that is defunct after the fork.
"PyOS_AfterFork_Child()" tries to reset the necessary locks, but is
not always able to.

다른 모든 스레드가 사라진다는 사실은 또한 CPython의 런타임 상태가
"os.fork()"와 마찬가지로 적절하게 정리되어야 함을 의미합니다. 이것은
현재 인터프리터와 다른 모든 "PyInterpreterState" 객체에 속하는 다른 모
든 "PyThreadState" 객체를 파이널리제이션 하는 것을 의미합니다. 이것과
"메인" 인터프리터의 특수한 특성으로 인해, "fork()"는 CPython 전역 런타
임이 원래 초기화된 인터프리터의 "메인" 스레드에서만 호출되어야 합니다.
유일한 예외는 "exec()"가 그 후에 즉시 호출되는 경우입니다.


고수준 API
----------

다음은 C 확장 코드를 작성하거나 파이썬 인터프리터를 내장할 때 가장 일
반적으로 사용되는 형과 함수입니다:

type PyInterpreterState
    * Part of the Limited API (as an opaque struct).*

   이 자료 구조는 여러 협력 스레드가 공유하는 상태를 나타냅니다. 같은
   인터프리터에 속하는 스레드는 모듈 관리와 몇 가지 다른 내부 항목을
   공유합니다. 이 구조체에는 공개 멤버가 없습니다.

   다른 인터프리터에 속한 스레드는 사용 가능한 메모리, 열린 파일 기술
   자 등과 같은 프로세스 상태를 제외하고는, 처음에는 아무것도 공유하지
   않습니다. 전역 인터프리터 록은 어떤 인터프리터에 속해 있는지에 관계
   없이 모든 스레드에서 공유됩니다.

type PyThreadState
    * Part of the Limited API (as an opaque struct).*

   This data structure represents the state of a single thread.  The
   only public data member is "interp" ("PyInterpreterState*"), which
   points to this thread's interpreter state.

void PyEval_InitThreads()
    * Part of the Stable ABI.*

   아무것도 하지 않는 폐지된 함수.

   파이썬 3.6과 이전 버전에서는, 이 함수가 존재하지 않으면 GIL을 만들
   었습니다.

   버전 3.9에서 변경: 이제 이 함수는 아무 작업도 수행하지 않습니다.

   버전 3.7에서 변경: 이 함수는 이제 "Py_Initialize()"에 의해 호출되어
   서, 여러분은 더는 직접 호출할 필요가 없습니다.

   버전 3.2에서 변경: 이 함수는 더는 "Py_Initialize()" 전에 호출할 수
   없습니다.

   Deprecated since version 3.9, will be removed in version 3.11.

int PyEval_ThreadsInitialized()
    * Part of the Stable ABI.*

   Returns a non-zero value if "PyEval_InitThreads()" has been called.
   This function can be called without holding the GIL, and therefore
   can be used to avoid calls to the locking API when running single-
   threaded.

   버전 3.7에서 변경: The *GIL* is now initialized by
   "Py_Initialize()".

   Deprecated since version 3.9, will be removed in version 3.11.

PyThreadState *PyEval_SaveThread()
    * Part of the Stable ABI.*

   (만들었다면) 전역 인터프리터 록을 해제하고 스레드 상태를 "NULL"로
   재설정하고, 이전 스레드 상태("NULL"이 아닙니다)를 반환합니다. 록이
   만들어졌다면, 현재 스레드가 록을 획득했어야 합니다.

void PyEval_RestoreThread(PyThreadState *tstate)
    * Part of the Stable ABI.*

   (만들었다면) 전역 인터프리터 록을 획득하고 스레드 상태를 "NULL"이
   아니어야 하는 *tstate*로 설정합니다. 록이 만들어졌다면, 현재 스레드
   가 이를 획득하지 않았어야 합니다, 그렇지 않으면 교착 상태가 발생합
   니다.

   참고:

     Calling this function from a thread when the runtime is
     finalizing will terminate the thread, even if the thread was not
     created by Python. You can use "_Py_IsFinalizing()" or
     "sys.is_finalizing()" to check if the interpreter is in process
     of being finalized before calling this function to avoid unwanted
     termination.

PyThreadState *PyThreadState_Get()
    * Part of the Stable ABI.*

   현재 스레드 상태를 반환합니다. 전역 인터프리터 록을 보유해야 합니다
   . 현재 스레드 상태가 "NULL"이면 치명적인 에러가 발생합니다 (그래서
   호출자가 "NULL"을 확인할 필요가 없습니다).

PyThreadState *PyThreadState_Swap(PyThreadState *tstate)
    * Part of the Stable ABI.*

   현재 스레드 상태를 인자 *tstate*("NULL"일 수 있습니다)가 제공하는
   스레드 상태와 스와프합니다. 전역 인터프리터 록을 보유해야 하며 해제
   되지 않습니다.

다음 함수는 스레드 로컬 저장소를 사용하며, 서브 인터프리터와 호환되지
않습니다:

PyGILState_STATE PyGILState_Ensure()
    * Part of the Stable ABI.*

   현재 스레드가 파이썬의 현재 상태나 전역 인터프리터 록과 관계없이 파
   이썬 C API를 호출할 준비가 되었는지 확인합니다. 이것은 각 호출이
   "PyGILState_Release()"에 대한 호출과 쌍을 이루는 한 스레드에서 원하
   는 만큼 여러 번 호출될 수 있습니다. 일반적으로, 스레드 상태가
   Release() 전에 이전 상태로 복원되는 한 "PyGILState_Ensure()"와
   "PyGILState_Release()" 호출 간에 다른 스레드 관련 API를 사용할 수
   있습니다. 예를 들어, "Py_BEGIN_ALLOW_THREADS"와
   "Py_END_ALLOW_THREADS" 매크로의 정상적인 사용은 허용됩니다.

   반환 값은 "PyGILState_Ensure()"가 호출되었을 때의 스레드 상태에 대
   한 불투명한 "핸들"이며, 파이썬이 같은 상태에 있도록 하려면
   "PyGILState_Release()"로 전달되어야 합니다. 재귀 호출이 허용되더라
   도, 이 핸들들은 공유할 수 *없습니다* - "PyGILState_Ensure()"에 대한
   각 고유 호출은 자신의 "PyGILState_Release()"에 대한 호출을 위해 핸
   들을 저장해야 합니다.

   함수가 반환할 때, 현재 스레드는 GIL을 보유하고 임의의 파이썬 코드를
   호출할 수 있습니다. 실패는 치명적인 에러입니다.

   참고:

     Calling this function from a thread when the runtime is
     finalizing will terminate the thread, even if the thread was not
     created by Python. You can use "_Py_IsFinalizing()" or
     "sys.is_finalizing()" to check if the interpreter is in process
     of being finalized before calling this function to avoid unwanted
     termination.

void PyGILState_Release(PyGILState_STATE)
    * Part of the Stable ABI.*

   이전에 획득 한 모든 자원을 해제합니다. 이 호출 후에, 파이썬의 상태
   는 해당 "PyGILState_Ensure()" 호출 이전과 같습니다 (그러나 일반적으
   로 이 상태는 호출자에게 알려지지 않아서, GILState API를 사용합니다
   ).

   "PyGILState_Ensure()"에 대한 모든 호출은 같은 스레드에서
   "PyGILState_Release()"에 대한 호출과 쌍을 이뤄야 합니다.

PyThreadState *PyGILState_GetThisThreadState()
    * Part of the Stable ABI.*

   이 스레드의 현재 스레드 상태를 가져옵니다. 현재 스레드에서 GILState
   API가 사용되지 않았으면 "NULL"을 반환할 수 있습니다. 메인 스레드에
   서 자동 스레드 상태 호출(auto-thread-state call)이 수행되지 않은 경
   우에도, 메인 스레드에는 항상 이러한 스레드 상태가 있음에 유의하십시
   오. 이것은 주로 도우미/진단 함수입니다.

int PyGILState_Check()

   현재 스레드가 GIL을 보유하고 있으면 "1"을 반환하고 그렇지 않으면
   "0"을 반환합니다. 이 함수는 아무 때나 모든 스레드에서 호출할 수 있
   습니다. 파이썬 스레드 상태가 초기화되었고 현재 GIL을 보유하고 있을
   때만 "1"을 반환합니다. 이것은 주로 도우미/진단 함수입니다. 예를 들
   어 콜백 컨텍스트나 메모리 할당 함수에서 유용할 수 있는데, GIL이 잠
   겨 있다는 것을 알면 호출자가 민감한 작업을 수행하거나 그렇지 않으면
   다르게 동작하도록 할 수 있습니다.

   버전 3.4에 추가.

다음 매크로는 일반적으로 후행 세미콜론 없이 사용됩니다; 파이썬 소스 배
포에서 사용 예를 찾으십시오.

Py_BEGIN_ALLOW_THREADS
    * Part of the Stable ABI.*

   이 매크로는 "{ PyThreadState *_save; _save = PyEval_SaveThread();"
   로 확장됩니다. 여는 중괄호가 포함되어 있음에 유의하십시오; 뒤따르는
   "Py_END_ALLOW_THREADS" 매크로와 일치해야 합니다. 이 매크로에 대한
   자세한 내용은 위를 참조하십시오.

Py_END_ALLOW_THREADS
    * Part of the Stable ABI.*

   이 매크로는 "PyEval_RestoreThread(_save); }"로 확장됩니다. 닫는 중
   괄호가 포함되어 있음에 유의하십시오; 이전 "Py_BEGIN_ALLOW_THREADS"
   매크로와 일치해야 합니다. 이 매크로에 대한 자세한 내용은 위를 참조
   하십시오.

Py_BLOCK_THREADS
    * Part of the Stable ABI.*

   이 매크로는 "PyEval_RestoreThread(_save);" 로 확장됩니다: 닫는 중괄
   호가 없는 "Py_END_ALLOW_THREADS"와 동등합니다.

Py_UNBLOCK_THREADS
    * Part of the Stable ABI.*

   이 매크로는 "_save = PyEval_SaveThread();" 로 확장됩니다: 여는 중괄
   호와 변수 선언이 없는 "Py_BEGIN_ALLOW_THREADS"와 동등합니다.


저수준 API
----------

다음 함수는 모두 "Py_Initialize()" 이후에 호출되어야 합니다.

버전 3.7에서 변경: "Py_Initialize()"는 이제 *GIL*을 초기화합니다.

PyInterpreterState *PyInterpreterState_New()
    * Part of the Stable ABI.*

   새 인터프리터 상태 객체를 만듭니다. 전역 인터프리터 록을 보유할 필
   요는 없지만, 이 함수에 대한 호출을 직렬화해야 하면 보유할 수 있습니
   다.

   인자 없이 감사 이벤트 "cpython.PyInterpreterState_New"를 발생시킵니
   다.

void PyInterpreterState_Clear(PyInterpreterState *interp)
    * Part of the Stable ABI.*

   인터프리터 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록
   을 보유해야 합니다.

   인자 없이 감사 이벤트 "cpython.PyInterpreterState_Clear"를 발생시킵
   니다.

void PyInterpreterState_Delete(PyInterpreterState *interp)
    * Part of the Stable ABI.*

   인터프리터 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요
   없습니다. 인터프리터 상태는 "PyInterpreterState_Clear()"에 대한 이
   전 호출로 재설정되었어야 합니다.

PyThreadState *PyThreadState_New(PyInterpreterState *interp)
    * Part of the Stable ABI.*

   주어진 인터프리터 객체에 속하는 새 스레드 상태 객체를 만듭니다. 전
   역 인터프리터 록을 보유할 필요는 없지만, 이 함수에 대한 호출을 직렬
   화해야 하면 보유할 수 있습니다.

void PyThreadState_Clear(PyThreadState *tstate)
    * Part of the Stable ABI.*

   스레드 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록을
   보유해야 합니다.

   버전 3.9에서 변경: 이 함수는 이제 "PyThreadState.on_delete" 콜백을
   호출합니다. 이전에는, "PyThreadState_Delete()"에서 호출했습니다.

void PyThreadState_Delete(PyThreadState *tstate)
    * Part of the Stable ABI.*

   스레드 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요 없
   습니다. 스레드 상태는 "PyThreadState_Clear()"에 대한 이전 호출로 재
   설정되었어야 합니다.

void PyThreadState_DeleteCurrent(void)

   Destroy the current thread state and release the global interpreter
   lock. Like "PyThreadState_Delete()", the global interpreter lock
   need not be held. The thread state must have been reset with a
   previous call to "PyThreadState_Clear()".

PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
    * Part of the Stable ABI since version 3.10.*

   파이썬 스레드 상태 *tstate*의 현재 프레임을 가져옵니다.

   Return a *strong reference*. Return "NULL" if no frame is currently
   executing.

   "PyEval_GetFrame()"도 참조하십시오.

   *tstate*는 "NULL"이 아니어야 합니다.

   버전 3.9에 추가.

uint64_t PyThreadState_GetID(PyThreadState *tstate)
    * Part of the Stable ABI since version 3.10.*

   파이썬 스레드 상태 *tstate*의 고유한 스레드 상태 식별자를 가져옵니
   다.

   *tstate*는 "NULL"이 아니어야 합니다.

   버전 3.9에 추가.

PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
    * Part of the Stable ABI since version 3.10.*

   파이썬 스레드 상태 *tstate*의 인터프리터를 가져옵니다.

   *tstate*는 "NULL"이 아니어야 합니다.

   버전 3.9에 추가.

PyInterpreterState *PyInterpreterState_Get(void)
    * Part of the Stable ABI since version 3.9.*

   현재 인터프리터를 가져옵니다.

   현재 파이썬 스레드 상태가 없거나 현재 인터프리터가 없으면 치명적인
   에러를 발행합니다. NULL을 반환할 수 없습니다.

   호출자는 GIL을 보유해야 합니다.

   버전 3.9에 추가.

int64_t PyInterpreterState_GetID(PyInterpreterState *interp)
    * Part of the Stable ABI since version 3.7.*

   인터프리터의 고유 ID를 반환합니다. 그렇게 하는데 에러가 발생하면
   "-1"이 반환되고 에러가 설정됩니다.

   호출자는 GIL을 보유해야 합니다.

   버전 3.7에 추가.

PyObject *PyInterpreterState_GetDict(PyInterpreterState *interp)
    * Part of the Stable ABI since version 3.8.*

   인터프리터별 데이터가 저장될 수 있는 딕셔너리를 반환합니다. 이 함수
   가 "NULL"을 반환하면 예외는 발생하지 않았고 호출자는 인터프리터별
   딕셔너리를 사용할 수 없다고 가정해야 합니다.

   이것은 확장이 인터프리터별 상태 정보를 저장하는 데 사용해야 하는
   "PyModule_GetState()"를 대체하는 것이 아닙니다.

   버전 3.8에 추가.

typedef PyObject *(*_PyFrameEvalFunction)(PyThreadState *tstate, PyFrameObject *frame, int throwflag)

   프레임 평가 함수의 형.

   *throwflag* 매개 변수는 제너레이터의 "throw()" 메서드에서 사용됩니
   다: 0이 아니면, 현재 예외를 처리합니다.

   버전 3.9에서 변경: 이제 함수는 *tstate* 매개 변수를 취합니다.

_PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)

   프레임 평가 함수를 가져옵니다.

   **PEP 523** "CPython에 프레임 평가 API 추가"를 참조하십시오.

   버전 3.9에 추가.

void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)

   프레임 평가 함수를 설정합니다.

   **PEP 523** "CPython에 프레임 평가 API 추가"를 참조하십시오.

   버전 3.9에 추가.

PyObject *PyThreadState_GetDict()
    *반환값: 빌린 참조.** Part of the Stable ABI.*

   확장이 스레드별 상태 정보를 저장할 수 있는 딕셔너리를 반환합니다.
   각 확장은 딕셔너리에 상태를 저장하는 데 사용할 고유 키를 사용해야
   합니다. 현재 스레드 상태를 사용할 수 없을 때 이 함수를 호출해도 됩
   니다. 이 함수가 "NULL"을 반환하면, 예외는 발생하지 않았고 호출자는
   현재 스레드 상태를 사용할 수 없다고 가정해야 합니다.

int PyThreadState_SetAsyncExc(unsigned long id, PyObject *exc)
    * Part of the Stable ABI.*

   Asynchronously raise an exception in a thread. The *id* argument is
   the thread id of the target thread; *exc* is the exception object
   to be raised. This function does not steal any references to *exc*.
   To prevent naive misuse, you must write your own C extension to
   call this.  Must be called with the GIL held. Returns the number of
   thread states modified; this is normally one, but will be zero if
   the thread id isn't found.  If *exc* is "NULL", the pending
   exception (if any) for the thread is cleared. This raises no
   exceptions.

   버전 3.7에서 변경: The type of the *id* parameter changed from
   "long" to "unsigned long".

void PyEval_AcquireThread(PyThreadState *tstate)
    * Part of the Stable ABI.*

   전역 인터프리터 록을 획득하고 현재 스레드 상태를 *tstate*로 설정합
   니다. *tstate*는 "NULL"이 아니어야 합니다. 록은 이전에 만들어진 것
   이어야 합니다. 이 스레드에 이미 록이 있으면, 교착 상태가 발생합니다
   .

   참고:

     Calling this function from a thread when the runtime is
     finalizing will terminate the thread, even if the thread was not
     created by Python. You can use "_Py_IsFinalizing()" or
     "sys.is_finalizing()" to check if the interpreter is in process
     of being finalized before calling this function to avoid unwanted
     termination.

   버전 3.8에서 변경: "PyEval_RestoreThread()",
   "Py_END_ALLOW_THREADS()" 및 "PyGILState_Ensure()"와 일관되도록 갱신
   되었으며, 인터프리터가 파이널리제이션 하는 동안 호출되면 현재 스레
   드를 종료합니다.

   "PyEval_RestoreThread()"는 (스레드가 초기화되지 않았을 때조차) 항상
   사용할 수 있는 고수준 함수입니다.

void PyEval_ReleaseThread(PyThreadState *tstate)
    * Part of the Stable ABI.*

   현재 스레드 상태를 "NULL"로 재설정하고 전역 인터프리터 록을 해제합
   니다. 록은 이전에 만들어졌어야 하고 현재 스레드가 보유해야 합니다.
   "NULL"이 아니어야 하는 *tstate* 인자는 현재 스레드 상태를 나타내는
   지 확인하는 데만 사용됩니다 --- 그렇지 않으면, 치명적인 에러가 보고
   됩니다.

   "PyEval_SaveThread()"는 (스레드가 초기화되지 않은 경우에조차) 항상
   사용할 수 있는 고수준 함수입니다.

void PyEval_AcquireLock()
    * Part of the Stable ABI.*

   Acquire the global interpreter lock.  The lock must have been
   created earlier. If this thread already has the lock, a deadlock
   ensues.

   버전 3.2부터 폐지: This function does not update the current thread
   state.  Please use "PyEval_RestoreThread()" or
   "PyEval_AcquireThread()" instead.

   참고:

     Calling this function from a thread when the runtime is
     finalizing will terminate the thread, even if the thread was not
     created by Python. You can use "_Py_IsFinalizing()" or
     "sys.is_finalizing()" to check if the interpreter is in process
     of being finalized before calling this function to avoid unwanted
     termination.

   버전 3.8에서 변경: "PyEval_RestoreThread()",
   "Py_END_ALLOW_THREADS()" 및 "PyGILState_Ensure()"와 일관되도록 갱신
   되었으며, 인터프리터가 파이널리제이션 하는 동안 호출되면 현재 스레
   드를 종료합니다.

void PyEval_ReleaseLock()
    * Part of the Stable ABI.*

   Release the global interpreter lock.  The lock must have been
   created earlier.

   버전 3.2부터 폐지: This function does not update the current thread
   state.  Please use "PyEval_SaveThread()" or
   "PyEval_ReleaseThread()" instead.


서브 인터프리터 지원
====================

대부분의 경우, 단일 파이썬 인터프리터만 내장할 것입니다만, 같은 프로세
스, 어쩌면 같은 스레드에서 여러 독립 인터프리터를 만들어야 하는 경우가
있습니다. 서브 인터프리터는 그렇게 할 수 있도록 합니다.

"메인" 인터프리터는 런타임이 초기화될 때 만들어지는 첫 번째 인터프리터
입니다. 보통은 프로세스에서 유일한 파이썬 인터프리터입니다. 서브 인터
프리터와 달리, 메인 인터프리터는 시그널 처리와 같은 고유한 프로세스 전
역 책임을 갖습니다. 또한 런타임 초기화 동안 실행을 담당하며 일반적으로
런타임 파이널리제이션 동안 활성 인터프리터입니다.
"PyInterpreterState_Main()" 함수는 그것의 상태에 대한 포인터를 반환합
니다.

"PyThreadState_Swap()" 함수를 사용하여 서브 인터프리터 간에 전환할 수
있습니다. 다음 함수를 사용하여 만들고 파괴할 수 있습니다:

PyThreadState *Py_NewInterpreter()
    * Part of the Stable ABI.*

   새 서브 인터프리터를 만듭니다. 이것은 파이썬 코드 실행을 위한 (거의
   ) 완전히 분리된 환경입니다. 특히, 새 인터프리터에는 기본 모듈
   "builtins", "__main__" 및 "sys"를 포함하여, 모든 임포트 된 모듈의
   개별, 독립 버전을 갖습니다. 로드된 모듈 테이블("sys.modules")과 모
   듈 검색 경로("sys.path")도 별개입니다. 새 환경에는 "sys.argv" 변수
   가 없습니다. 새로운 표준 I/O 스트림 파일 객체 "sys.stdin",
   "sys.stdout" 및 "sys.stderr"을 갖습니다 (단, 같은 하부 파일 기술자
   를 참조합니다).

   The return value points to the first thread state created in the
   new sub-interpreter.  This thread state is made in the current
   thread state. Note that no actual thread is created; see the
   discussion of thread states below.  If creation of the new
   interpreter is unsuccessful, "NULL" is returned; no exception is
   set since the exception state is stored in the current thread state
   and there may not be a current thread state.  (Like all other
   Python/C API functions, the global interpreter lock must be held
   before calling this function and is still held when it returns;
   however, unlike most other Python/C API functions, there needn't be
   a current thread state on entry.)

   확장 모듈은 다음과 같이 (서브) 인터프리터 간에 공유됩니다:

   * 다단계 초기화를 사용하는 모듈의 경우, 예를 들어
     "PyModule_FromDefAndSpec()", 각 인터프리터에 대해 별도의 모듈 객
     체가 만들어지고 초기화됩니다. C 수준 정적과 전역 변수만 이러한 모
     듈 객체 간에 공유됩니다.

   * 단단계 초기화를 사용하는 모듈의 경우, 예를 들어
     "PyModule_Create()", 특정 확장이 처음 임포트 될 때, 정상적으로 초
     기화되고, 모듈 딕셔너리의 (얕은) 사본이 저장됩니다. 다른 (서브)
     인터프리터가 같은 확장을 임포트 할 때, 새 모듈이 초기화되고 이 복
     사본의 내용으로 채워집니다; 확장의 "init" 함수는 호출되지 않습니
     다. 따라서 모듈 딕셔너리의 객체는 (서브) 인터프리터 간에 공유되어
     , 원치 않는 동작을 일으킬 수 있습니다 (아래 버그와 주의 사항을 참
     조하십시오).

     이것은 인터프리터가 "Py_FinalizeEx()"와 "Py_Initialize()"를 호출
     하여 완전히 다시 초기화된 후 확장을 임포트 할 때 일어나는 것과 다
     름에 유의하십시오; 이 경우, 확장의 "initmodule" 함수가 다시 *호출
     됩니다*. 다단계 초기화와 마찬가지로, 이는 C 수준의 정적과 전역 변
     수만 이러한 모듈 간에 공유됨을 의미합니다.

void Py_EndInterpreter(PyThreadState *tstate)
    * Part of the Stable ABI.*

   Destroy the (sub-)interpreter represented by the given thread
   state. The given thread state must be the current thread state.
   See the discussion of thread states below.  When the call returns,
   the current thread state is "NULL".  All thread states associated
   with this interpreter are destroyed.  (The global interpreter lock
   must be held before calling this function and is still held when it
   returns.)  "Py_FinalizeEx()" will destroy all sub-interpreters that
   haven't been explicitly destroyed at that point.


버그와 주의 사항
----------------

서브 인터프리터(및 메인 인터프리터)는 같은 프로세스의 일부이기 때문에,
그들 간의 절연이 완벽하지 않습니다 --- 예를 들어, "os.close()"와 같은
저수준 파일 연산을 사용하면 서로의 열린 파일에 (실수로 혹은 악의적으로
) 영향을 미칠 수 있습니다. (서브) 인터프리터 간에 확장이 공유되는 방식
때문에, 일부 확장이 제대로 작동하지 않을 수 있습니다; 이것은 특히 단단
계 초기화나 (정적) 전역 변수를 사용할 때 특히 그렇습니다. 한 서브 인터
프리터에서 만든 객체를 다른 (서브) 인터프리터의 이름 공간에 삽입할 수
있습니다; 가능하면 피해야 합니다.

서브 인터프리터 간에 사용자 정의 함수, 메서드, 인스턴스 또는 클래스를
공유하지 않도록 특별한 주의를 기울여야 합니다. 이러한 객체에 의해 실행
되는 임포트 연산은 잘못된 (서브) 인터프리터의 로드된 모듈 딕셔너리에
영향을 미칠 수 있기 때문입니다. 위의 것들에서 접근할 수 있는 객체를 공
유하지 않는 것도 마찬가지로 중요합니다.

Also note that combining this functionality with "PyGILState_*" APIs
is delicate, because these APIs assume a bijection between Python
thread states and OS-level threads, an assumption broken by the
presence of sub-interpreters. It is highly recommended that you don't
switch sub-interpreters between a pair of matching
"PyGILState_Ensure()" and "PyGILState_Release()" calls. Furthermore,
extensions (such as "ctypes") using these APIs to allow calling of
Python code from non-Python created threads will probably be broken
when using sub-interpreters.


비동기 알림
===========

메인 인터프리터 스레드에 비동기 알림을 보내는 메커니즘이 제공됩니다.
이러한 알림은 함수 포인터와 void 포인터 인자의 형태를 취합니다.

int Py_AddPendingCall(int (*func)(void*), void *arg)
    * Part of the Stable ABI.*

   메인 인터프리터 스레드에서 호출할 함수를 예약합니다. 성공하면 "0"이
   반환되고 *func*는 메인 스레드에서 호출되기 위해 큐에 추가됩니다. 실
   패 시, 예외 설정 없이 "-1"이 반환됩니다.

   성공적으로 큐에 넣으면, *func*는 *arg* 인자를 사용하여 *결국* 메인
   인터프리터 스레드에서 호출됩니다. 정상적으로 실행되는 파이썬 코드와
   비교할 때 비동기적으로 호출되지만, 다음 두 조건이 모두 충족됩니다:

   * *바이트 코드* 경계에서;

   * 메인 스레드가 *전역 인터프리터 록*을 보유하면서 (따라서 *func*는
     전체 C API를 사용할 수 있습니다).

   *func*는 성공하면 "0"을, 실패하면 예외 설정과 함께 "-1"을 반환해야
   합니다. *func*는 다른 비동기 알림을 재귀적으로 수행하기 위해 중단되
   지 않지만, 전역 인터프리터 록이 해제되면 스레드를 전환하기 위해 여
   전히 중단될 수 있습니다.

   이 함수는 실행하는 데 현재 스레드 상태가 필요하지 않으며, 전역 인터
   프리터 록이 필요하지 않습니다.

   서브 인터프리터에서 이 함수를 호출하려면 호출자가 GIL을 보유해야 합
   니다. 그렇지 않으면, 함수 *func*가 잘못된 인터프리터에서 호출되도록
   예약될 수 있습니다.

   경고:

     이것은 매우 특별한 경우에만 유용한, 저수준 함수입니다. *func*가
     가능한 한 빨리 호출된다는 보장은 없습니다. 메인 스레드가 시스템
     호출을 실행 중이라 바쁘면, 시스템 호출이 반환되기 전에 *func*가
     호출되지 않습니다. 이 함수는 일반적으로 임의의 C 스레드에서 파이
     썬 코드를 호출하는 데 적합하지 **않습니다**. 대신, PyGILState API
     를 사용하십시오.

   버전 3.9에서 변경: 이 함수가 서브 인터프리터에서 호출되면, *func*
   함수는 이제 메인 인터프리터에서 호출되지 않고 서브 인터프리터에서
   호출되도록 예약됩니다. 이제 각 서브 인터프리터는 자체 예약된 호출
   목록을 갖습니다.

   버전 3.1에 추가.


프로파일링과 추적
=================

파이썬 인터프리터는 프로파일링과 실행 추적 기능을 연결하기 위한 몇 가
지 저수준 지원을 제공합니다. 프로파일링, 디버깅 및 커버리지 분석 도구
에 사용됩니다.

이 C 인터페이스를 사용하면 프로파일링이나 추적 코드가 파이썬 수준의 콜
러블 객체를 통해 호출하는 오버헤드를 피하고, 대신 직접 C 함수를 호출할
수 있습니다. 시설의 필수 어트리뷰트는 변경되지 않았습니다; 인터페이스
는 추적 함수를 스레드별로 설치할 수 있도록 하며, 추적 함수에 보고되는
기본 이벤트는 이전 버전의 파이썬 수준 추적 함수에 보고된 것과 같습니다
.

typedef int (*Py_tracefunc)(PyObject *obj, PyFrameObject *frame, int what, PyObject *arg)

   The type of the trace function registered using
   "PyEval_SetProfile()" and "PyEval_SetTrace()". The first parameter
   is the object passed to the registration function as *obj*, *frame*
   is the frame object to which the event pertains, *what* is one of
   the constants "PyTrace_CALL", "PyTrace_EXCEPTION", "PyTrace_LINE",
   "PyTrace_RETURN", "PyTrace_C_CALL", "PyTrace_C_EXCEPTION",
   "PyTrace_C_RETURN", or "PyTrace_OPCODE", and *arg* depends on the
   value of *what*:

   +--------------------------------+------------------------------------------+
   | *what*의 값                    | *arg*의 의미                             |
   |================================|==========================================|
   | "PyTrace_CALL"                 | 항상 "Py_None".                          |
   +--------------------------------+------------------------------------------+
   | "PyTrace_EXCEPTION"            | "sys.exc_info()"에서 반환된 예외 정보.   |
   +--------------------------------+------------------------------------------+
   | "PyTrace_LINE"                 | 항상 "Py_None".                          |
   +--------------------------------+------------------------------------------+
   | "PyTrace_RETURN"               | 호출자에게 반환되는 값, 또는 예외로 인한 |
   |                                | 것이면 "NULL".                           |
   +--------------------------------+------------------------------------------+
   | "PyTrace_C_CALL"               | 호출되는 함수 객체.                      |
   +--------------------------------+------------------------------------------+
   | "PyTrace_C_EXCEPTION"          | 호출되는 함수 객체.                      |
   +--------------------------------+------------------------------------------+
   | "PyTrace_C_RETURN"             | 호출되는 함수 객체.                      |
   +--------------------------------+------------------------------------------+
   | "PyTrace_OPCODE"               | 항상 "Py_None".                          |
   +--------------------------------+------------------------------------------+

int PyTrace_CALL

   함수나 메서드에 대한 새 호출이 보고되거나, 제너레이터에 대한 새 항
   목이 보고될 때 "Py_tracefunc" 함수에 대한 *what* 매개 변수의 값. 제
   너레이터 함수에 대한 이터레이터의 생성은 해당 프레임의 파이썬 바이
   트 코드로의 제어 전송이 없기 때문에 보고되지 않음에 유의하십시오.

int PyTrace_EXCEPTION

   예외가 발생했을 때 "Py_tracefunc" 함수에 대한 *what* 매개 변수의 값
   . 콜백 함수는 실행되는 프레임 내에서 바이트 코드가 처리된 후 예외가
   설정될 때 *what*에 대해 이 값으로 호출됩니다. 이것의 효과는 예외 전
   파로 인해 파이썬 스택이 되감기는 것입니다, 예외가 전파되어 각 프레
   임으로 반환할 때 콜백이 호출됩니다. 추적 함수만 이러한 이벤트를 수
   신합니다; 프로파일러에는 필요하지 않습니다.

int PyTrace_LINE

   The value passed as the *what* parameter to a "Py_tracefunc"
   function (but not a profiling function) when a line-number event is
   being reported. It may be disabled for a frame by setting
   "f_trace_lines" to *0* on that frame.

int PyTrace_RETURN

   호출이 반환되려고 할 때 "Py_tracefunc" 함수에 대한 *what* 매개 변수
   의 값.

int PyTrace_C_CALL

   C 함수가 호출되려고 할 때 "Py_tracefunc" 함수에 대한 *what* 매개 변
   수의 값.

int PyTrace_C_EXCEPTION

   C 함수에서 예외가 발생했을 때 "Py_tracefunc" 함수에 대한 *what* 매
   개 변수의 값.

int PyTrace_C_RETURN

   C 함수가 반환했을 때 "Py_tracefunc" 함수에 대한 *what* 매개 변수의
   값.

int PyTrace_OPCODE

   The value for the *what* parameter to "Py_tracefunc" functions (but
   not profiling functions) when a new opcode is about to be executed.
   This event is not emitted by default: it must be explicitly
   requested by setting "f_trace_opcodes" to *1* on the frame.

void PyEval_SetProfile(Py_tracefunc func, PyObject *obj)

   Set the profiler function to *func*.  The *obj* parameter is passed
   to the function as its first parameter, and may be any Python
   object, or "NULL".  If the profile function needs to maintain
   state, using a different value for *obj* for each thread provides a
   convenient and thread-safe place to store it.  The profile function
   is called for all monitored events except "PyTrace_LINE"
   "PyTrace_OPCODE" and "PyTrace_EXCEPTION".

   호출자는 *GIL*을 보유하고 있어야 합니다.

void PyEval_SetTrace(Py_tracefunc func, PyObject *obj)

   Set the tracing function to *func*.  This is similar to
   "PyEval_SetProfile()", except the tracing function does receive
   line-number events and per-opcode events, but does not receive any
   event related to C function objects being called.  Any trace
   function registered using "PyEval_SetTrace()" will not receive
   "PyTrace_C_CALL", "PyTrace_C_EXCEPTION" or "PyTrace_C_RETURN" as a
   value for the *what* parameter.

   호출자는 *GIL*을 보유하고 있어야 합니다.


고급 디버거 지원
================

이 함수들은 고급 디버깅 도구에서만 사용하기 위한 것입니다.

PyInterpreterState *PyInterpreterState_Head()

   인터프리터 상태 객체들의 리스트의 머리에 있는 객체를 반환합니다.

PyInterpreterState *PyInterpreterState_Main()

   메인 인터프리터 상태 객체를 반환합니다.

PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *interp)

   인터프리터 상태 객체들의 리스트에서 *interp* 이후의 다음 인터프리터
   상태 객체를 반환합니다.

PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *interp)

   인터프리터 *interp*와 관련된 스레드 리스트에서 첫 번째
   "PyThreadState" 객체에 대한 포인터를 반환합니다.

PyThreadState *PyThreadState_Next(PyThreadState *tstate)

   같은 "PyInterpreterState" 객체에 속하는 모든 스레드 객체 리스트에서
   *tstate* 이후의 다음 스레드 상태 객체를 반환합니다.


스레드 로컬 저장소 지원
=======================

The Python interpreter provides low-level support for thread-local
storage (TLS) which wraps the underlying native TLS implementation to
support the Python-level thread local storage API ("threading.local").
The CPython C level APIs are similar to those offered by pthreads and
Windows: use a thread key and functions to associate a "void*" value
per thread.

이러한 함수를 호출할 때 GIL을 보유할 필요는 *없습니다*; 그들은 자체 록
을 제공합니다.

"Python.h"에는 TLS API 선언이 포함되어 있지 않음에 유의하십시오, 스레
드 로컬 저장소를 사용하려면 "pythread.h"를 포함해야 합니다.

참고:

  None of these API functions handle memory management on behalf of
  the "void*" values.  You need to allocate and deallocate them
  yourself. If the "void*" values happen to be "PyObject*", these
  functions don't do refcount operations on them either.


스레드별 저장소 (TSS - Thread Specific Storage) API
---------------------------------------------------

TSS API is introduced to supersede the use of the existing TLS API
within the CPython interpreter.  This API uses a new type "Py_tss_t"
instead of "int" to represent thread keys.

버전 3.7에 추가.

더 보기: "CPython의 스레드-로컬 저장소를 위한 새로운 C-API" (**PEP 539**)

type Py_tss_t

   이 자료 구조는 스레드 키의 상태를 나타내며, 정의는 하부 TLS 구현에
   따라 달라질 수 있으며, 키의 초기화 상태를 나타내는 내부 필드가 있습
   니다. 이 구조체에는 공개 멤버가 없습니다.

   Py_LIMITED_API가 정의되지 않을 때, "Py_tss_NEEDS_INIT"로 이 형의 정
   적 할당이 허용됩니다.

Py_tss_NEEDS_INIT

   이 매크로는 "Py_tss_t" 변수의 초기화자(initializer)로 확장됩니다.
   이 매크로는 Py_LIMITED_API에서 정의되지 않음에 유의하십시오.


동적 할당
~~~~~~~~~

Py_LIMITED_API로 빌드된 확장 모듈에 필요한, 빌드 시점에 구현이 불투명
해서 형의 정적 할당이 불가능한 "Py_tss_t"의 동적 할당.

Py_tss_t *PyThread_tss_alloc()
    * Part of the Stable ABI since version 3.7.*

   "Py_tss_NEEDS_INIT"로 초기화된 값과 같은 상태의 값을 반환하거나, 동
   적 할당 실패 시 "NULL"을 반환합니다.

void PyThread_tss_free(Py_tss_t *key)
    * Part of the Stable ABI since version 3.7.*

   Free the given *key* allocated by "PyThread_tss_alloc()", after
   first calling "PyThread_tss_delete()" to ensure any associated
   thread locals have been unassigned. This is a no-op if the *key*
   argument is "NULL".

   참고:

     A freed key becomes a dangling pointer. You should reset the key
     to *NULL*.


메서드
~~~~~~

이 함수들의 매개 변수 *key*는 "NULL"이 아니어야 합니다. 또한, 주어진
"Py_tss_t"가 "PyThread_tss_create()"로 초기화되지 않았으면,
"PyThread_tss_set()"과 "PyThread_tss_get()"의 동작은 정의되지 않습니다
.

int PyThread_tss_is_created(Py_tss_t *key)
    * Part of the Stable ABI since version 3.7.*

   주어진 "Py_tss_t"가 "PyThread_tss_create()"로 초기화되었으면 0이 아
   닌 값을 반환합니다.

int PyThread_tss_create(Py_tss_t *key)
    * Part of the Stable ABI since version 3.7.*

   TSS 키 초기화에 성공하면 0 값을 반환합니다. *key* 인자가 가리키는
   값이 "Py_tss_NEEDS_INIT"로 초기화되지 않으면 동작이 정의되지 않습니
   다. 이 함수는 같은 키에서 반복적으로 호출될 수 있습니다 -- 이미 초
   기화된 키에 대해 호출하면 아무런 일도 하지 않으며 즉시 성공을 반환
   합니다.

void PyThread_tss_delete(Py_tss_t *key)
    * Part of the Stable ABI since version 3.7.*

   TSS 키를 삭제하여 모든 스레드에서 키와 관련된 값을 잊게 하고, 키의
   초기화 상태를 초기화되지 않음으로 변경합니다. 파괴된 키는
   "PyThread_tss_create()"로 다시 초기화할 수 있습니다. 이 함수는 같은
   키에서 반복적으로 호출될 수 있습니다 -- 이미 파괴된 키에 대해 호출
   하면 아무런 일도 하지 않습니다.

int PyThread_tss_set(Py_tss_t *key, void *value)
    * Part of the Stable ABI since version 3.7.*

   Return a zero value to indicate successfully associating a "void*"
   value with a TSS key in the current thread.  Each thread has a
   distinct mapping of the key to a "void*" value.

void *PyThread_tss_get(Py_tss_t *key)
    * Part of the Stable ABI since version 3.7.*

   Return the "void*" value associated with a TSS key in the current
   thread.  This returns "NULL" if no value is associated with the key
   in the current thread.


스레드 로컬 저장소 (TLS) API
----------------------------

버전 3.7부터 폐지: 이 API는 스레드별 저장소 (TSS) API로 대체됩니다.

참고:

  이 버전의 API는 "int"로 안전하게 캐스트 할 수 없는 방식으로 네이티브
  TLS 키가 정의된 플랫폼을 지원하지 않습니다. 이러한 플랫폼에서,
  "PyThread_create_key()"는 실패 상태로 즉시 반환되며, 다른 TLS 함수는
  이러한 플랫폼에서 모두 아무런 일도 하지 않습니다.

위에서 언급한 호환성 문제로 인해, 이 버전의 API를 새 코드에서 사용해서
는 안 됩니다.

int PyThread_create_key()
    * Part of the Stable ABI.*

void PyThread_delete_key(int key)
    * Part of the Stable ABI.*

int PyThread_set_key_value(int key, void *value)
    * Part of the Stable ABI.*

void *PyThread_get_key_value(int key)
    * Part of the Stable ABI.*

void PyThread_delete_key_value(int key)
    * Part of the Stable ABI.*

void PyThread_ReInitTLS()
    * Part of the Stable ABI.*
