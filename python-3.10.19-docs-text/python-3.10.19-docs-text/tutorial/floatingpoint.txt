15. Floating Point Arithmetic:  Issues and Limitations
******************************************************

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

   0.125

has value 1/10 + 2/100 + 5/1000, and in the same way the binary
fraction

   0.001

has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

불행히도, 대부분의 십진 소수는 정확하게 이진 소수로 표현될 수 없습니다
. 결과적으로, 일반적으로 입력하는 십진 부동 소수점 숫자가 실제로 기계
에 저장될 때는 이진 부동 소수점 수로 근사 될 뿐입니다.

이 문제는 먼저 밑 10에서 따져보는 것이 이해하기 쉽습니다. 분수 1/3을
생각해봅시다. 이 값을 십진 소수로 근사할 수 있습니다:

   0.3

또는, 더 정확하게,

   0.33

또는, 더 정확하게,

   0.333

등등. 아무리 많은 자릿수를 적어도 결과가 정확하게 1/3이 될 수 없지만,
점점 더 1/3에 가까운 근사치가 됩니다.

같은 방식으로, 아무리 많은 자릿수의 숫자를 사용해도, 십진수 0.1은 이진
소수로 정확하게 표현될 수 없습니다. 이진법에서, 1/10은 무한히 반복되는
소수입니다

   0.0001100110011001100110011001100110011001100110011...

유한 한 비트 수에서 멈추면, 근삿값을 얻게 됩니다. 오늘날 대부분 기계에
서, float는 이진 분수로 근사 되는 데, 최상위 비트로부터 시작하는 53비
트를 분자로 사용하고, 2의 거듭제곱 수를 분모로 사용합니다. 1/10의 경우
, 이진 분수는 "3602879701896397 / 2 ** 55" 인데, 실제 값 1/10과 거의
같지만 정확히 같지는 않습니다.

Many users are not aware of the approximation because of the way
values are displayed.  Python only prints a decimal approximation to
the true decimal value of the binary approximation stored by the
machine.  On most machines, if Python were to print the true decimal
value of the binary approximation stored for 0.1, it would have to
display

   >>> 0.1
   0.1000000000000000055511151231257827021181583404541015625

That is more digits than most people find useful, so Python keeps the
number of digits manageable by displaying a rounded value instead

   >>> 1 / 10
   0.1

인쇄된 결과가 정확히 1/10인 것처럼 보여도, 실제 저장된 값은 가장 가까
운 표현 가능한 이진 소수임을 기억하세요.

흥미롭게도, 가장 가까운 근사 이진 소수를 공유하는 여러 다른 십진수가
있습니다. 예를 들어, "0.1" 과 "0.10000000000000001" 및
"0.1000000000000000055511151231257827021181583404541015625" 는 모두
"3602879701896397 / 2 ** 55" 로 근사 됩니다. 이 십진 값들이 모두 같은
근삿값을 공유하기 때문에 "eval(repr(x)) == x" 불변을 그대로 유지하면서
그중 하나를 표시할 수 있습니다.

역사적으로, 파이썬 프롬프트와 내장 "repr()" 함수는 유효 숫자 17개의 숫
자인 "0.10000000000000001" 을 선택합니다. 파이썬 3.1부터, 이제 파이썬(
대부분 시스템에서)이 가장 짧은 것을 선택할 수 있으며, 단순히 "0.1" 만
표시합니다.

Note that this is in the very nature of binary floating-point: this is
not a bug in Python, and it is not a bug in your code either.  You'll
see the same kind of thing in all languages that support your
hardware's floating-point arithmetic (although some languages may not
*display* the difference by default, or in all output modes).

For more pleasant output, you may wish to use string formatting to
produce a limited number of significant digits:

   >>> format(math.pi, '.12g')  # give 12 significant digits
   '3.14159265359'

   >>> format(math.pi, '.2f')   # give 2 digits after the point
   '3.14'

   >>> repr(math.pi)
   '3.141592653589793'

이것이, 진정한 의미에서, 환영임을 깨닫는 것이 중요합니다: 여러분은 단
순히 진짜 기곗값의 *표시* 를 반올림하고 있습니다.

One illusion may beget another.  For example, since 0.1 is not exactly
1/10, summing three values of 0.1 may not yield exactly 0.3, either:

   >>> .1 + .1 + .1 == .3
   False

Also, since the 0.1 cannot get any closer to the exact value of 1/10
and 0.3 cannot get any closer to the exact value of 3/10, then pre-
rounding with "round()" function cannot help:

   >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
   False

Though the numbers cannot be made closer to their intended exact
values, the "round()" function can be useful for post-rounding so that
results with inexact values become comparable to one another:

   >>> round(.1 + .1 + .1, 10) == round(.3, 10)
   True

Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See The Perils of Floating Point for
a more complete account of other common surprises.

As that says near the end, "there are no easy answers."  Still, don't
be unduly wary of floating-point!  The errors in Python float
operations are inherited from the floating-point hardware, and on most
machines are on the order of no more than 1 part in 2**53 per
operation.  That's more than adequate for most tasks, but you do need
to keep in mind that it's not decimal arithmetic and that every float
operation can suffer a new rounding error.

병리학적 경우가 존재하지만, 무심히 부동 소수점 산술을 사용하는 대부분
은, 단순히 최종 결과를 기대하는 자릿수로 반올림해서 표시하면 기대하는
결과를 보게 될 것입니다. 보통 "str()" 만으로도 충분하며, 더 세밀하게
제어하려면 포맷 문자열 문법 에서 "str.format()" 메서드의 포맷 지정자를
보세요.

정확한 십진 표현이 필요한 사용 사례의 경우, 회계 응용 프로그램 및 고정
밀 응용 프로그램에 적합한 십진 산술을 구현하는 "decimal" 모듈을 사용해
보세요.

정확한 산술의 또 다른 형태는 유리수를 기반으로 산술을 구현하는
"fractions" 모듈에 의해 지원됩니다 (따라서 1/3과 같은 숫자는 정확하게
나타낼 수 있습니다).

If you are a heavy user of floating point operations you should take a
look at the NumPy package and many other packages for mathematical and
statistical operations supplied by the SciPy project. See
<https://scipy.org>.

Python provides tools that may help on those rare occasions when you
really *do* want to know the exact value of a float.  The
"float.as_integer_ratio()" method expresses the value of a float as a
fraction:

   >>> x = 3.14159
   >>> x.as_integer_ratio()
   (3537115888337719, 1125899906842624)

Since the ratio is exact, it can be used to losslessly recreate the
original value:

   >>> x == 3537115888337719 / 1125899906842624
   True

The "float.hex()" method expresses a float in hexadecimal (base 16),
again giving the exact value stored by your computer:

   >>> x.hex()
   '0x1.921f9f01b866ep+1'

This precise hexadecimal representation can be used to reconstruct the
float value exactly:

   >>> x == float.fromhex('0x1.921f9f01b866ep+1')
   True

표현이 정확하므로, 파이썬의 다른 버전 에 걸쳐 값을 신뢰성 있게 이식하
고 (플랫폼 독립성), 같은 형식을 지원하는 다른 언어(자바나 C99 같은)와
데이터를 교환하는 데 유용합니다.

Another helpful tool is the "math.fsum()" function which helps
mitigate loss-of-precision during summation.  It tracks "lost digits"
as values are added onto a running total.  That can make a difference
in overall accuracy so that the errors do not accumulate to the point
where they affect the final total:

>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True


15.1. 표현 오류
===============

이 섹션에서는 "0.1" 예제를 자세히 설명하고, 이러한 사례에 대한 정확한
분석을 여러분이 직접 수행하는 방법을 보여줍니다. 이진 부동 소수점 표현
에 대한 기본 지식이 있다고 가정합니다.

*표현 오류 (Representation error)* 는 일부 (실제로는, 대부분의) 십진
소수가 이진(밑 2) 소수로 정확하게 표현될 수 없다는 사실을 나타냅니다.
이것이 파이썬(또는 펄, C, C++, 자바, 포트란 및 기타 여러 언어)이 종종
여러분이 기대하는 정확한 십진수를 표시하지 않는 주된 이유입니다.

Why is that?  1/10 is not exactly representable as a binary fraction.
Almost all machines today (November 2000) use IEEE-754 floating point
arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it
can of the form *J*/2***N* where *J* is an integer containing exactly
53 bits.  Rewriting

   1 / 10 ~= J / (2**N)

를

   J ~= 2**N / 10

and recalling that *J* has exactly 53 bits (is ">= 2**52" but "<
2**53"), the best value for *N* is 56:

   >>> 2**52 <=  2**56 // 10  < 2**53
   True

That is, 56 is the only value for *N* that leaves *J* with exactly 53
bits.  The best possible value for *J* is then that quotient rounded:

   >>> q, r = divmod(2**56, 10)
   >>> r
   6

Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

   >>> q+1
   7205759403792794

Therefore the best possible approximation to 1/10 in 754 double
precision is:

   7205759403792794 / 2 ** 56

분자와 분모를 둘로 나누면 다음과 같이 약분됩니다:

   3602879701896397 / 2 ** 55

올림을 했기 때문에, 이것은 실제로 1/10 보다 약간 크다는 것에 유의하세
요; 내림을 했다면, 몫이 1/10 보다 약간 작아졌을 것입니다. 그러나 어떤
경우에도 *정확하게* 1/10일 수는 없습니다!

So the computer never "sees" 1/10:  what it sees is the exact fraction
given above, the best 754 double approximation it can get:

   >>> 0.1 * 2 ** 55
   3602879701896397.0

If we multiply that fraction by 10**55, we can see the value out to 55
decimal digits:

   >>> 3602879701896397 * 10 ** 55 // 2 ** 55
   1000000000000000055511151231257827021181583404541015625

meaning that the exact number stored in the computer is equal to the
decimal value
0.1000000000000000055511151231257827021181583404541015625. Instead of
displaying the full decimal value, many languages (including older
versions of Python), round the result to 17 significant digits:

   >>> format(0.1, '.17f')
   '0.10000000000000001'

The "fractions" and "decimal" modules make these calculations easy:

   >>> from decimal import Decimal
   >>> from fractions import Fraction

   >>> Fraction.from_float(0.1)
   Fraction(3602879701896397, 36028797018963968)

   >>> (0.1).as_integer_ratio()
   (3602879701896397, 36028797018963968)

   >>> Decimal.from_float(0.1)
   Decimal('0.1000000000000000055511151231257827021181583404541015625')

   >>> format(Decimal.from_float(0.1), '.17')
   '0.10000000000000001'
