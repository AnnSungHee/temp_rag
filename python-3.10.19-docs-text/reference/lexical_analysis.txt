2. 어휘 분석
************

A Python program is read by a *parser*.  Input to the parser is a
stream of *tokens*, generated by the *lexical analyzer*.  This chapter
describes how the lexical analyzer breaks a file into tokens.

파이썬은 프로그램 텍스트를 유니코드 코드값으로 읽습니다; 소스 파일의
인코딩은 인코딩 선언을 통해 지정될 수 있고, 기본값은 UTF-8입니다. 자세
한 내용은 **PEP 3120** 에 나옵니다. 소스 파일을 디코딩할 수 없을 때는
"SyntaxError" 가 발생합니다.


2.1. 줄 구조(Line structure)
============================

파이썬 프로그램은 여러 개의 *논리적인 줄(logical lines)* 들로 나뉩니다
.


2.1.1. 논리적인 줄
------------------

논리적인 줄의 끝은 NEWLINE 토큰으로 표현됩니다. 문법이 허락하지 않는
이상 (예를 들어 복합문에서 문장들 사이) 문장은 논리적인 줄 간의 경계를
가로지를 수 없습니다. 논리적인 줄은 명시적이거나 묵시적인 *줄 결합
(line joining)* 규칙에 따라 하나 이상의 *물리적인 줄(physical lines)*
들로 구성됩니다.


2.1.2. 물리적인 줄
------------------

물리적인 줄은 줄의 끝을 나타내는 시퀀스로 끝나는 문자들의 시퀀스입니다
. 소스 파일과 문자열에는 플랫폼들의 표준 줄 종료 시퀀스들이 모두 사용
될 수 있습니다 - ASCII LF (개행문자)를 사용하는 유닉스 형, ASCII 시퀀
스 CR LF(캐리지 리턴 다음에 오는 개행 문자)를 사용하는 윈도우 형,
ASCII CR(캐리지 리턴)을 사용하는 예전의 매킨토시 형. 이 형태들은 플랫
폼의 종류와 관계없이 동등하게 사용할 수 있습니다. 입력의 끝은 마지막
물리적인 줄의 묵시적 종결자 역할을 합니다.

파이썬을 내장할 때는, 소스 코드 문자열은 반드시 줄 종료 문자에 표준 C
관행(ASCII LF를 표현하는 "\n" 문자로 줄이 종료됩니다)을 적용해서 파이
썬 API로 전달되어야 합니다.


2.1.3. 주석
-----------

주석은 문자열 리터럴에 포함되지 않는 해시 문자("#")로 시작하고 물리적
인 줄의 끝에서 끝납니다. 묵시적인 줄 결합 규칙이 유효하지 않은 이상,
주석은 논리적인 줄을 종료시킵니다. 주석은 문법이 무시합니다.


2.1.4. 인코딩 선언
------------------

파이썬 스크립트의 첫 번 째나 두 번째 줄에 있는 주석이 정규식
"coding[=:]\s*([-\w.]+)" 과 매치되면, 이 주석은 인코딩 선언으로 처리됩
니다. 이 정규식의 첫 번째 그룹은 소스 코드 파일의 인코딩 이름을 지정합
니다. 인코딩 선언은 줄 전체에 홀로 나와야 합니다. 만약 두 번째 줄이라
면, 첫 번째 줄 역시 주석만 있어야 합니다. 인코딩 선언의 권장 형태는 두
개입니다. 하나는

   # -*- coding: <encoding-name> -*-

인데 GNU Emacs에서도 인식됩니다. 다른 하나는

   # vim:fileencoding=<encoding-name>

인데 Bram Moolenaar 의 VIM에서 인식됩니다.

If no encoding declaration is found, the default encoding is UTF-8.
In addition, if the first bytes of the file are the UTF-8 byte-order
mark ("b'\xef\xbb\xbf'"), the declared file encoding is UTF-8 (this is
supported, among others, by Microsoft's **notepad**).

인코딩이 선언되면, 인코딩 이름은 파이썬이 인식할 수 있어야 합니다 (표
준 인코딩를 참조하세요). 인코딩은 문자열 리터럴, 주석, 식별자를 포함한
모든 어휘 분석에서 모두 사용됩니다.


2.1.5. 명시적인 줄 결합
-----------------------

둘 이상의 물리적인 줄은 역 슬래시 문자("\")를 사용해서 논리적인 줄로
결합할 수 있습니다: 물리적인 줄이 문자열 리터럴이나 주석의 일부가 아닌
역 슬래시 문자로 끝나면, 역 슬래시와 뒤따르는 개행 문자가 제거된 채로,
현재 만들어지고 있는 논리적인 줄에 합쳐집니다. 예를 들어:

   if 1900 < year < 2100 and 1 <= month <= 12 \
      and 1 <= day <= 31 and 0 <= hour < 24 \
      and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
           return 1

역 슬래시로 끝나는 줄은 주석이 포함될 수 없습니다. 역 슬래시는 주석을
결합하지 못합니다. 역 슬래시는 문자열 리터럴을 제외한 어떤 토큰도 결합
하지 못합니다 (즉, 문자열 리터럴 이외의 어떤 토큰도 역 슬래시를 사용해
서 두 줄에 나누어 기록할 수 없습니다.). 문자열 리터럴 밖에 있는 역 슬
래시가 앞에서 언급한 장소 이외의 곳에 등장하는 것은 문법에 어긋납니다.


2.1.6. 묵시적인 줄 결합
-----------------------

괄호("()"), 대괄호("[]"), 중괄호("{}")가 사용되는 표현은 역 슬래시 없
이도 여러 개의 물리적인 줄로 나눌 수 있습니다. 예를 들어:

   month_names = ['Januari', 'Februari', 'Maart',      # These are the
                  'April',   'Mei',      'Juni',       # Dutch names
                  'Juli',    'Augustus', 'September',  # for the months
                  'Oktober', 'November', 'December']   # of the year

묵시적으로 이어지는 줄들은 주석을 포함할 수 있습니다. 이어지는 줄들의
들여쓰기는 중요하지 않습니다. 중간에 빈 줄이 들어가도 됩니다. 묵시적으
로 줄 결합하는 줄 들 간에는 NEWLINE 토큰이 만들어지지 않습니다. 묵시적
으로 이어지는 줄들은 삼중 따옴표 된 문자열들에서도 등장할 수 있는데 (
아래를 보라), 이 경우는 주석이 포함될 수 없습니다.


2.1.7. 빈 줄
------------

스페이스, 탭, 폼 피드(formfeed) 와 주석만으로 구성된 논리적인 줄은 무
시됩니다. (즉 NEWLINE 토큰이 만들어지지 않습니다.) 대화형으로 문장이
입력되는 도중에는 빈 줄의 처리가 REPL 구현에 따라 달라질 수 있습니다.
표준 대화형 인터프리터에서는, 완전히 빈 줄(즉 공백이나 주석조차 없는
것)은 다중 행 문장을 종료시킵니다.


2.1.8. 들여쓰기
---------------

논리적인 줄의 제일 앞에 오는 공백(스페이스와 탭)은 줄의 들여쓰기 수준
을 계산하는 데 사용되고, 이는 다시 문장들의 묶음을 결정하는 데 사용되
게 됩니다.

탭은 (왼쪽에서 오른쪽으로) 1~8개의 스페이스로 변환되는데, 치환된 후의
총 스페이스 문자 수가 8의 배수가 되도록 맞춥니다. (유닉스에서 사용되는
규칙에 맞추려는 것입니다.) 첫 번째 비 공백 문자 앞에 나오는 공백의 총
수가 줄의 들여쓰기를 결정합니다. 들여쓰기는 역 슬래시를 사용해서 여러
개의 물리적인 줄로 나눠질 수 없습니다; 첫 번째 역 슬래시 이전의 공백이
들여쓰기를 결정합니다.

소스 파일이 탭과 스페이스를 섞어 쓰는 경우, 탭이 몇 개의 스페이스에 해
당하는지에 따라 다르게 해석될 수 있으면 "TabError" 를 일으킵니다.

**크로스-플랫폼 호환성 유의 사항:** UNIX 이외의 플랫폼에서 편집기들이
동작하는 방식 때문에, 하나의 파일 내에서 들여쓰기를 위해 탭과 스페이스
를 섞어 쓰는 것은 현명한 선택이 아닙니다. 다른 플랫폼들에서는 최대 들
여쓰기 수준에 제한이 있을 수도 있다는 점도 주의해야 합니다.

폼 피드 문자는 줄의 처음에 나올 수 있습니다; 앞서 설명한 들여쓰기 수준
계산에서는 무시됩니다. 선행 공백의 다른 곳에 등장하는 폼 피드 문자는
정의되지 않은 효과를 줍니다 (가령, 스페이스 수가 0으로 초기화될 수 있
습니다).

연속된 줄의 들여쓰기 수준은, 스택을 사용해서, 다음과 같은 방법으로
INDENT와 DEDENT 토큰을 만드는 데 사용됩니다.

파일의 첫 줄을 읽기 전에 0하나를 스택에 넣습니다(push); 이 값은 다시
꺼내는(pop) 일이 없습니다. 스택에 넣는 값은 항상 스택의 아래에서 위로
올라갈 때 단조 증가합니다. 각 논리적인 줄의 처음에서 줄의 들여쓰기 수
준이 스택의 가장 위에 있는 값과 비교됩니다. 같다면 아무런 일도 일어나
지 않습니다. 더 크다면 그 값을 스택에 넣고 하나의 INDENT 토큰을 만듭니
다. 더 작다면 이 값은 스택에 있는 값 중 하나여야만 합니다. 이 값보다
큰 모든 스택의 값들을 꺼내고(pop), 꺼낸 횟수만큼의 DEDENT 토큰을 만듭
니다. 파일의 끝에서, 스택에 남아있는 0보다 큰 값의 개수만큼 DEDENT 토
큰을 만듭니다.

여기에 (혼란스럽다 할지라도) 올바르게 들여쓰기 된 파이썬 코드 조각이
있습니다:

   def perm(l):
           # Compute the list of all permutations of l
       if len(l) <= 1:
                     return [l]
       r = []
       for i in range(len(l)):
                s = l[:i] + l[i+1:]
                p = perm(s)
                for x in p:
                 r.append(l[i:i+1] + x)
       return r

다음 예는 여러 가지 들여쓰기 에러를 보여줍니다:

    def perm(l):                       # error: first line indented
   for i in range(len(l)):             # error: not indented
       s = l[:i] + l[i+1:]
           p = perm(l[:i] + l[i+1:])   # error: unexpected indent
           for x in p:
                   r.append(l[i:i+1] + x)
               return r                # error: inconsistent dedent

(사실, 처음 세 개의 에러는 파서가 감지합니다. 단지 마지막 에러만 어휘
분석기가 감지합니다. --- "return r" 의 들여쓰기가 스택에 있는 값과 일
치하지 않습니다.)


2.1.9. 토큰 사이의 공백
-----------------------

논리적인 줄의 처음과 문자열 리터럴을 제외하고, 공백 문자인 스페이스,
탭, 폼 피드는 토큰을 분리하기 위해 섞어 쓸 수 있습니다. 두 토큰을 붙여
쓸 때 다른 토큰으로 해석될 수 있는 경우만 토큰 사이에 공백이 필요합니
다. (예를 들어, ab 는 하나의 토큰이지만, a b 는 두 개의 토큰입니다.)


2.2. 다른 토큰들
================

NEWLINE, INDENT, DEDENT 와는 별도로, 다음과 같은 유형의 토큰들이 존재
합니다: *식별자(identifier)*, *키워드(keyword)*, *리터럴(literal)*, *
연산자(operator)*, *구분자(delimiter)*. (앞에서 살펴본 줄 종료 이외의)
공백 문자들은 토큰이 아니지만, 토큰을 분리하는 역할을 담당합니다. 모호
할 경우, 왼쪽에서 오른쪽으로 읽을 때, 하나의 토큰은 올바르고 가능한 한
최대 길이의 문자열로 구성되는 것을 선호합니다.


2.3. 식별자와 키워드
====================

식별자 (*이름(name)* 이라고도 합니다) 은 다음과 같은 어휘 정의로 기술
됩니다.

파이썬에서 식별자의 문법은 유니코드 표준 부속서 UAX-31 에 기반을 두는
데, 여기에 덧붙이거나 바꾼 내용은 아래에서 정의합니다. 좀 더 상세한 내
용은 **PEP 3131** 에서 찾을 수 있습니다.

Within the ASCII range (U+0001..U+007F), the valid characters for
identifiers are the same as in Python 2.x: the uppercase and lowercase
letters "A" through "Z", the underscore "_" and, except for the first
character, the digits "0" through "9".

Python 3.0 introduces additional characters from outside the ASCII
range (see **PEP 3131**).  For these characters, the classification
uses the version of the Unicode Character Database as included in the
"unicodedata" module.

식별자는 길이에 제한이 없고, 케이스(case)는 구분됩니다.

   identifier   ::= xid_start xid_continue*
   id_start     ::= <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>
   id_continue  ::= <all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>
   xid_start    ::= <all characters in id_start whose NFKC normalization is in "id_start xid_continue*">
   xid_continue ::= <all characters in id_continue whose NFKC normalization is in "id_continue*">

위에서 언급한 유니코드 카테고리 코드들의 의미는 이렇습니다:

* *Lu* - uppercase letters

* *Ll* - lowercase letters

* *Lt* - titlecase letters

* *Lm* - modifier letters

* *Lo* - other letters

* *Nl* - letter numbers

* *Mn* - nonspacing marks

* *Mc* - spacing combining marks

* *Nd* - decimal numbers

* *Pc* - connector punctuations

* *Other_ID_Start* - explicit list of characters in PropList.txt to
  support backwards compatibility

* *Other_ID_Continue* - 마찬가지

모든 식별자는 파서에 의해 NFKC 정규화 형식으로 변환되고, 식별자의 비교
는 NFKC 에 기반을 둡니다.

A non-normative HTML file listing all valid identifier characters for
Unicode 4.1 can be found at
https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt


2.3.1. 키워드
-------------

다음 식별자들은 예약어, 또는 언어의 키워드, 로 사용되고, 일반적인 식별
자로 사용될 수 없습니다. 여기 쓰여 있는 것과 정확히 같게 사용되어야 합
니다:

   False      await      else       import     pass
   None       break      except     in         raise
   True       class      finally    is         return
   and        continue   for        lambda     try
   as         def        from       nonlocal   while
   assert     del        global     not        with
   async      elif       if         or         yield


2.3.2. 소프트 키워드
--------------------

버전 3.10에 추가.

Some identifiers are only reserved under specific contexts. These are
known as *soft keywords*.  The identifiers "match", "case" and "_" can
syntactically act as keywords in contexts related to the pattern
matching statement, but this distinction is done at the parser level,
not when tokenizing.

As soft keywords, their use with pattern matching is possible while
still preserving compatibility with existing code that uses "match",
"case" and "_" as identifier names.


2.3.3. 식별자의 예약 영역
-------------------------

(키워드와는 별개로) 어떤 부류의 식별자들은 특별한 의미가 있습니다. 이
부류의 식별자들은 시작과 끝의 밑줄 문자 패턴으로 구분됩니다:

"_*"
   "from module import *" 에 의해 임포트되지 않습니다.

"_"
   In a "case" pattern within a "match" statement, "_" is a soft
   keyword that denotes a wildcard.

   한편, 대화형 인터프리터는 마지막 평가 결과물을 변수 "_"에 저장합니
   다. ("print" 와 같은 내장 함수와 함께, "builtins" 모듈에 저장됩니다
   .)

   Elsewhere, "_" is a regular identifier. It is often used to name
   "special" items, but it is not special to Python itself.

   참고:

     이름 "_" 은 종종 국제화(internationalization)와 관련되어 사용됩니
     다. 이 관례에 관해서는 "gettext" 모듈의 문서를 참조하십시오.It is
     also commonly used for unused variables.

"__*__"
   시스템 정의 이름, 비공식적으로 "던더(dunder)" 이름이라고 알려졌습니
   다. 이 이름들은 인터프리터와 그 구현(표준 라이브러리를 포함합니다)
   이 정의합니다. 현재 정의된 시스템 이름은 특수 메서드 이름들 섹션과
   그 외의 곳에서 논의됩니다. 파이썬의 미래 버전에서는 더 많은 것들이
   정의될 가능성이 큽니다. 어떤 문맥에서건, 명시적으로 문서로 만들어진
   사용법을 벗어나는 "__*__" 이름의 *모든* 사용은, 경고 없이 손상될 수
   있습니다.

"__*"
   클래스-비공개 이름. 이 부류의 이름들을 클래스 정의 문맥에서 사용하
   면 뒤섞인 형태로 변형됩니다. 부모 클래스와 자식 클래스의 "비공개
   (private)" 어트리뷰트 간의 이름 충돌을 피하기 위함입니다. 식별자 (
   이름) 섹션을 보세요.


2.4. 리터럴
===========

리터럴(literal)은 몇몇 내장형들의 상숫값을 위한 표기법입니다.


2.4.1. 문자열과 바이트열 리터럴
-------------------------------

문자열 리터럴은 다음과 같은 어휘 정의로 기술됩니다:

   stringliteral   ::= [stringprefix](shortstring | longstring)
   stringprefix    ::= "r" | "u" | "R" | "U" | "f" | "F"
                    | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
   shortstring     ::= "'" shortstringitem* "'" | '"' shortstringitem* '"'
   longstring      ::= "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
   shortstringitem ::= shortstringchar | stringescapeseq
   longstringitem  ::= longstringchar | stringescapeseq
   shortstringchar ::= <any source character except "\" or newline or the quote>
   longstringchar  ::= <any source character except "\">
   stringescapeseq ::= "\" <any source character>

   bytesliteral   ::= bytesprefix(shortbytes | longbytes)
   bytesprefix    ::= "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
   shortbytes     ::= "'" shortbytesitem* "'" | '"' shortbytesitem* '"'
   longbytes      ::= "'''" longbytesitem* "'''" | '"""' longbytesitem* '"""'
   shortbytesitem ::= shortbyteschar | bytesescapeseq
   longbytesitem  ::= longbyteschar | bytesescapeseq
   shortbyteschar ::= <any ASCII character except "\" or newline or the quote>
   longbyteschar  ::= <any ASCII character except "\">
   bytesescapeseq ::= "\" <any ASCII character>

이 생성 규칙이 보여주지 못하는 한 가지 문법적 제약은 "stringprefix" 나
"bytesprefix" 와 리터럴의 나머지 부분 사이에 공백이 허락되지 않는다는
것입니다. 소스 문자 집합은 인코딩 선언으로 정의됩니다; 소스 파일에 인
코딩 선언이 없으면 UTF-8입니다. 인코딩 선언 섹션을 보세요.

쉬운 말로 하자면, 두 가지 리터럴은 한 쌍의 작은따옴표("'") 나 큰따옴표
(""")로 둘러싸일 수 있습니다. 또한, 둘 다 한 쌍의 삼중 작은따옴표나 큰
따옴표로 둘러싸일 수도 있습니다 (이것들은 보통 *삼중 따옴표 된 문자열*
이라고 불립니다). 역 슬래시("\") 문자는 "n"과 같은 일반적인 문자에 특
별한 의미를 부여하는데 사용됩니다. 이 문자는 이스케이프 처리될 때
("\n") '개행문자'를 뜻합니다. 또한 홀로 쓰이면 특별한 의미가 있는 문자
들을 이스케이핑할 때 사용되는데, 개행문자, 역 슬래시 자신, 따옴표 문자
가 그것입니다. 예제는 아래의 이스케이프 시퀀스를 참조하세요.

바이트열(bytes) 리터럴은 항상 "'b'" 나 "'B'" 를 앞에 붙입니다; "str"
형의 인스턴스 대신 "bytes" 형의 인스턴스를 만듭니다. 오직 ASCII 문자들
만 포함할 수 있습니다. 코드값이 128보다 크거나 같은 값들은 반드시 이스
케이핑으로 표현되어야 합니다.

Both string and bytes literals may optionally be prefixed with a
letter "'r'" or "'R'"; such strings are called *raw strings* and treat
backslashes as literal characters.  As a result, in string literals,
"'\U'" and "'\u'" escapes in raw strings are not treated specially.
Given that Python 2.x's raw unicode literals behave differently than
Python 3.x's the "'ur'" syntax is not supported.

버전 3.3에 추가: 날 바이트열 리터럴의 "'br'" 와 같은 의미가 있는
"'rb'" 접두어가 추가되었습니다.

버전 3.3에 추가: 파이썬 2.x 와 3.x 에서 동시에 지원하는 코드들의 유지
보수를 단순화하기 위해 예전에 사용되던 유니코드 리터럴 ("u'value'")이
다시 도입되었습니다. 자세한 정보는 **PEP 414** 에 나옵니다.

"'f'" 나 "'F'" 를 접두어로 갖는 문자열 리터럴은 포맷 문자열 리터럴
(*formatted string literal*)입니다; Formatted string literals 을 보세
요. "'f'" 는 "'r'" 과 결합할 수 있습니다, 하지만, "'b'" 나 "'u'" 와는
결합할 수 없습니다. 따라서 날 포맷 문자열은 가능하지만, 포맷 바이트열
리터럴은 불가능합니다.

삼중 따옴표 된 리터럴에서, 세 개의 이스케이핑 되지 않은 개행 문자와 따
옴표가 허락됩니다 (그리고 유지됩니다). 예외는 한 줄에 세 개의 이스케이
핑 되지 않은 따옴표가 나오는 것인데, 리터럴을 종료시킵니다. ("따옴표"
는 리터럴을 시작하는데 사용한 문자입니다. 즉, "'" 나 """)

"'r'" 나 "'R'" 접두어가 붙지 않은 이상, 문자열과 바이트열 리터럴에 포
함된 이스케이프 시퀀스는 표준 C에서 사용된 것과 비슷한 규칙으로 해석됩
니다. 인식되는 이스케이프 시퀀스는 이렇습니다:

+-------------------+-----------------------------------+---------+
| 이스케이프 시퀀스 | 의미                              | 유의 사 |
|                   |                                   | 항      |
|===================|===================================|=========|
| "\"<newline>      | 역 슬래시와 개행 문자가 무시됩니  | (1)     |
|                   | 다                                |         |
+-------------------+-----------------------------------+---------+
| "\\"              | 역 슬래시 ("\")                   |         |
+-------------------+-----------------------------------+---------+
| "\'"              | 작은따옴표 ("'")                  |         |
+-------------------+-----------------------------------+---------+
| "\""              | 큰따옴표 (""")                    |         |
+-------------------+-----------------------------------+---------+
| "\a"              | ASCII 벨 (BEL)                    |         |
+-------------------+-----------------------------------+---------+
| "\b"              | ASCII 백스페이스 (BS)             |         |
+-------------------+-----------------------------------+---------+
| "\f"              | ASCII 폼 피드 (FF)                |         |
+-------------------+-----------------------------------+---------+
| "\n"              | ASCII 라인 피드 (LF)              |         |
+-------------------+-----------------------------------+---------+
| "\r"              | ASCII 캐리지 리턴 (CR)            |         |
+-------------------+-----------------------------------+---------+
| "\t"              | ASCII 가로 탭 (TAB)               |         |
+-------------------+-----------------------------------+---------+
| "\v"              | ASCII 세로 탭 (VT)                |         |
+-------------------+-----------------------------------+---------+
| "\ooo"            | 8진수 *ooo* 로 지정된 문자        | (2,4)   |
+-------------------+-----------------------------------+---------+
| "\xhh"            | 16진수 *hh* 로 지정된 문자        | (3,4)   |
+-------------------+-----------------------------------+---------+

문자열 리터럴에서만 인식되는 이스케이프 시퀀스는:

+-------------------+-----------------------------------+---------+
| 이스케이프 시퀀스 | 의미                              | 유의 사 |
|                   |                                   | 항      |
|===================|===================================|=========|
| "\N{name}"        | 유니코드 데이터베이스에서 *name*  | (5)     |
|                   | 이라고 이름 붙여진 문자           |         |
+-------------------+-----------------------------------+---------+
| "\uxxxx"          | 16-bit 16진수 *xxxx* 로 지정된 문 | (6)     |
|                   | 자                                |         |
+-------------------+-----------------------------------+---------+
| "\Uxxxxxxxx"      | 32-bit 16진수 *xxxxxxxx* 로 지정  | (7)     |
|                   | 된 문자                           |         |
+-------------------+-----------------------------------+---------+

유의 사항:

1. A backslash can be added at the end of a line to ignore the
   newline:

      >>> 'This string will not include \
      ... backslashes or newline characters.'
      'This string will not include backslashes or newline characters.'

   The same result can be achieved using triple-quoted strings, or
   parentheses and string literal concatenation.

2. 표준 C와 마찬가지로, 최대 세 개의 8진수가 허용됩니다.

3. 표준 C와는 달리, 정확히 두 개의 16진수가 제공되어야 합니다.

4. 바이트열 리터럴에서, 16진수와 8진수 이스케이프는 지정된 값의 바이트
   를 표현합니다. 문자열 리터럴에서는, 이 이스케이프는 지정된 값의 유
   니코드 문자를 표현합니다.

5. 버전 3.3에서 변경: 별칭 [1] 지원이 추가되었습니다

6. 정확히 4개의 16진수를 필요로 합니다.

7. 이 방법으로 모든 유니코드를 인코딩할 수 있습니다. 정확히 8개의 16진
   수가 필요합니다.

표준 C와는 달리, 인식되지 않는 모든 이스케이프 시퀀스는 문자열에 변경
되지 않은 상태로 남게 됩니다. 즉, *역 슬래시가 결과에 남게 됩니다*. (
이 동작은 디버깅할 때 쓸모가 있습니다. 이스케이프 시퀀스가 잘못 입력되
었을 때, 최종 결과에서 잘못된 부분을 쉽게 인지할 수 있습니다.) 문자열
리터럴에서만 인식되는 이스케이프 시퀀스가, 바이트열 리터럴에서는 인식
되지 않는 부류임에 주목하십시오.

   버전 3.6에서 변경: Unrecognized escape sequences produce a
   "DeprecationWarning".  In a future Python version they will be a
   "SyntaxWarning" and eventually a "SyntaxError".

날 리터럴에서 조차, 따옴표는 역 슬래시로 이스케이프 됩니다. 하지만 역
슬래시가 결과에 남게 됩니다; 예를 들어, "r"\""" 는 올바른 문자열 리터
럴인데, 두 개의 문자가 들어있습니다: 역 슬래시와 큰따옴표; "r"\"" 는
올바른 문자열 리터럴이 아닙니다 (날 문자열조차 홀수개의 역 슬래시로 끝
날 수 없습니다.). 좀 더 명확하게 말하자면, 날 리터럴은 하나의 역 슬래
시로 끝날 수 없습니다(역 슬래시가 뒤에 오는 따옴표를 이스케이프 시키기
때문입니다). 역 슬래시와 바로 뒤에 오는 개행문자는 줄 결합이 *아니라*
리터럴에 포함되는 두 개의 문자로 인식됨에 주의해야 합니다.


2.4.2. 문자열 리터럴 이어붙이기
-------------------------------

여러 개의 문자열이나 바이트열 리터럴을 (공백으로 분리해서) 여러 개 인
접해서 나열하는 것이 허락되고, 그 의미는 이어붙인 것과 같습니다. 각 리
터럴이 서로 다른 따옴표를 사용해도 됩니다. 그래서, ""hello" 'world'"
는 ""helloworld"" 와 동등합니다. 이 기능은 긴 문자열을 편의상 여러 줄
로 나눌 때 필요한 역 슬래시를 줄여줍니다. 각 문자열 단위마다 주석을 붙
이는 것도 가능합니다. 예를 들어:

   re.compile("[A-Za-z_]"       # letter or underscore
              "[A-Za-z0-9_]*"   # letter, digit or underscore
             )

이 기능이 문법 수준에서 정의되고는 있지만, 컴파일 시점에 구현됨에 주의
해야 합니다. 실행 시간에 문자열 표현을 이어붙이기 위해서는 '+' 연산자
를 사용해야 합니다. 리터럴 이어붙이기가 요소별로 다른 따옴표를 사용할
수 있고 (날 문자열과 삼중 따옴표 문자열을 이어붙이는 것조차 가능합니다
), 포맷 문자열 리터럴을 보통 문자열 리터럴과 이어붙일 수 있음에 유의해
야 합니다.


2.4.3. Formatted string literals
--------------------------------

버전 3.6에 추가.

포맷 문자열 리터럴(*formatted string literal*) 또는 *f-문자열
(f-string)* 은 "'f'" 나 "'F'" 를 앞에 붙인 문자열 리터럴입니다. 이 문
자열은 치환 필드를 포함할 수 있는데, 중괄호 "{}" 로 구분되는 표현식입
니다. 다른 문자열 리터럴이 항상 상숫값을 갖지만, 포맷 문자열 리터럴은
실행시간에 계산되는 표현식입니다.

이스케이프 시퀀스는 일반 문자열 리터럴처럼 디코딩됩니다 (동시에 날 문
자열인 경우는 예외입니다). 디코딩 후에 문자열의 내용은 다음과 같은 문
법을 따릅니다:

   f_string          ::= (literal_char | "{{" | "}}" | replacement_field)*
   replacement_field ::= "{" f_expression ["="] ["!" conversion] [":" format_spec] "}"
   f_expression      ::= (conditional_expression | "*" or_expr)
                      ("," conditional_expression | "," "*" or_expr)* [","]
                    | yield_expression
   conversion        ::= "s" | "r" | "a"
   format_spec       ::= (literal_char | NULL | replacement_field)*
   literal_char      ::= <any code point except "{", "}" or NULL>

중괄호 바깥 부분은 일반 리터럴처럼 취급되는데, 이중 중괄호 "'{{'" 나
"'}}'" 가 대응하는 단일 중괄호로 치환된다는 점만 예외입니다. 하나의 여
는 중괄호 "'{'" 는 치환 필드를 시작시키는데, 파이썬 표현식이 뒤따릅니
다. 평가 후 표현식 텍스트와 해당 값을 모두 표시하려면 (디버깅에 유용합
니다), 표현식 뒤에 등호 "'='"를 추가할 수 있습니다. 느낌표 "'!'" 로 시
작하는, 변환(conversion) 필드가 뒤따를 수 있습니다. 포맷 지정자(format
specifier)도 덧붙일 수 있는데, 콜론 "':'" 으로 시작합니다. 치환 필드는
닫는 중괄호 "'}'" 로 끝납니다.

Expressions in formatted string literals are treated like regular
Python expressions surrounded by parentheses, with a few exceptions.
An empty expression is not allowed, and both "lambda"  and assignment
expressions ":=" must be surrounded by explicit parentheses.
Replacement expressions can contain line breaks (e.g. in triple-quoted
strings), but they cannot contain comments.  Each expression is
evaluated in the context where the formatted string literal appears,
in order from left to right.

버전 3.7에서 변경: 파이썬 3.7 이전에는, 구현 문제로 인해 포맷 문자열
리터럴의 표현식에서 "await" 표현식과 "async for" 절을 포함하는 컴프리
헨션은 유효하지 않았습니다.

등호 기호 "'='"이 제공되면, 출력에는 표현식 텍스트, "'='" 및 평가된 값
이 포함됩니다. 여는 중괄호 "'{'" 뒤, 표현식 내, "'='" 뒤의 스페이스는
모두 출력에 유지됩니다. 기본적으로, "'='"은 포맷 지정자가 없는 한 표현
식의 "repr()"을 제공합니다. 포맷이 지정되면 변환 "'!r'"이 선언되지 않
는 한 기본적으로 표현식의 "str()"이 사용됩니다.

버전 3.8에 추가: 등호 기호 "'='".

변환(conversion)이 지정되면, 표현식의 결과가 포매팅 전에 변환됩니다.
변환 "'!s'" 는 결과에 "str()" 을 호출하고, "'!r'" 은 "repr()" 을 호출
하고, "'!a'" 은 "ascii()" 를 호출합니다.

The result is then formatted using the "format()" protocol.  The
format specifier is passed to the "__format__()" method of the
expression or conversion result.  An empty string is passed when the
format specifier is omitted.  The formatted result is then included in
the final value of the whole string.

최상위 포맷 지정자는 중첩된 치환 필드들을 포함할 수 있습니다. 이 중첩
된 필드들은 그들 자신의 변환 필드와 포맷 지정자를 포함할 수 있지만, 깊
이 중첩된 치환 필드들을 포함할 수는 없습니다. 포맷 지정자 간이 언어는
"str.format()" 메서드에서 사용되는 것과 같습니다.

포맷 문자열 리터럴을 이어붙일 수는 있지만, 치환 필드가 여러 리터럴로
쪼개질 수는 없습니다.

포맷 문자열 리터럴의 예를 들면:

   >>> name = "Fred"
   >>> f"He said his name is {name!r}."
   "He said his name is 'Fred'."
   >>> f"He said his name is {repr(name)}."  # repr() is equivalent to !r
   "He said his name is 'Fred'."
   >>> width = 10
   >>> precision = 4
   >>> value = decimal.Decimal("12.34567")
   >>> f"result: {value:{width}.{precision}}"  # nested fields
   'result:      12.35'
   >>> today = datetime(year=2017, month=1, day=27)
   >>> f"{today:%B %d, %Y}"  # using date format specifier
   'January 27, 2017'
   >>> f"{today=:%B %d, %Y}" # using date format specifier and debugging
   'today=January 27, 2017'
   >>> number = 1024
   >>> f"{number:#0x}"  # using integer format specifier
   '0x400'
   >>> foo = "bar"
   >>> f"{ foo = }" # preserves whitespace
   " foo = 'bar'"
   >>> line = "The mill's closed"
   >>> f"{line = }"
   'line = "The mill\'s closed"'
   >>> f"{line = :20}"
   "line = The mill's closed   "
   >>> f"{line = !r:20}"
   'line = "The mill\'s closed" '

A consequence of sharing the same syntax as regular string literals is
that characters in the replacement fields must not conflict with the
quoting used in the outer formatted string literal:

   f"abc {a["x"]} def"    # error: outer string literal ended prematurely
   f"abc {a['x']} def"    # workaround: use different quoting

Backslashes are not allowed in format expressions and will raise an
error:

   f"newline: {ord('\n')}"  # raises SyntaxError

To include a value in which a backslash escape is required, create a
temporary variable.

>>> newline = ord('\n')
>>> f"newline: {newline}"
'newline: 10'

포맷 문자열 리터럴은 독스트링(docstring)으로 사용될 수 없습니다. 표현
식이 전혀 없더라도 마찬가집니다.

   >>> def foo():
   ...     f"Not a docstring"
   ...
   >>> foo.__doc__ is None
   True

포맷 문자열 리터럴 추가에 대한 제안은 **PEP 498** 을 참조하고, 관련된
포맷 문자열 메커니즘을 사용하는 "str.format()" 도 살펴보는 것이 좋습니
다.


2.4.4. 숫자 리터럴
------------------

There are three types of numeric literals: integers, floating point
numbers, and imaginary numbers.  There are no complex literals
(complex numbers can be formed by adding a real number and an
imaginary number).

숫자 리터럴이 부호를 포함하지 않는 것에 주의해야 합니다; "-1" 과 같은
구문은 일 항 연산자 '"-"' 과 리터럴 "1" 로 구성된 표현식입니다.


2.4.5. 정수 리터럴
------------------

정수 리터럴은 다음과 같은 어휘 정의로 표현됩니다:

   integer      ::= decinteger | bininteger | octinteger | hexinteger
   decinteger   ::= nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
   bininteger   ::= "0" ("b" | "B") (["_"] bindigit)+
   octinteger   ::= "0" ("o" | "O") (["_"] octdigit)+
   hexinteger   ::= "0" ("x" | "X") (["_"] hexdigit)+
   nonzerodigit ::= "1"..."9"
   digit        ::= "0"..."9"
   bindigit     ::= "0" | "1"
   octdigit     ::= "0"..."7"
   hexdigit     ::= digit | "a"..."f" | "A"..."F"

가용한 메모리에 저장될 수 있는지와는 별개로 정수 리터럴의 길이에 제한
은 없습니다.

밑줄은 리터럴의 숫자 값을 결정할 때 고려되지 않습니다. 가독성을 높이기
위해 숫자들을 무리 지을 때 쓸모가 있습니다. 밑줄은 숫자 사이나 "0x" 와
같은 진수 지정자(base specifier) 다음에 나올 수 있는데, 한 번에 하나만
사용될 수 있습니다.

0 이 아닌 10진수가 0으로 시작할 수 없음에 주의해야 합니다. 3.0 버전 이
전의 파이썬에서 사용한 C 스타일의 8진수 리터럴과 혼동되는 것을 막기 위
함입니다.

정수 리터럴의 예를 들면:

   7     2147483647                        0o177    0b100110111
   3     79228162514264337593543950336     0o377    0xdeadbeef
         100_000_000_000                   0b_1110_0101

버전 3.6에서 변경: 리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을
허락합니다.


2.4.6. Floating point literals
------------------------------

Floating point literals are described by the following lexical
definitions:

   floatnumber   ::= pointfloat | exponentfloat
   pointfloat    ::= [digitpart] fraction | digitpart "."
   exponentfloat ::= (digitpart | pointfloat) exponent
   digitpart     ::= digit (["_"] digit)*
   fraction      ::= "." digitpart
   exponent      ::= ("e" | "E") ["+" | "-"] digitpart

Note that the integer and exponent parts are always interpreted using
radix 10. For example, "077e010" is legal, and denotes the same number
as "77e10". The allowed range of floating point literals is
implementation-dependent.  As in integer literals, underscores are
supported for digit grouping.

Some examples of floating point literals:

   3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93

버전 3.6에서 변경: 리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을
허락합니다.


2.4.7. 허수 리터럴
------------------

허수 리터럴은 다음과 같은 어휘 정의로 표현됩니다:

   imagnumber ::= (floatnumber | digitpart) ("j" | "J")

An imaginary literal yields a complex number with a real part of 0.0.
Complex numbers are represented as a pair of floating point numbers
and have the same restrictions on their range.  To create a complex
number with a nonzero real part, add a floating point number to it,
e.g., "(3+4j)".  Some examples of imaginary literals:

   3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j


2.5. 연산자
===========

다음과 같은 토큰들은 연산자입니다:

   +       -       *       **      /       //      %      @
   <<      >>      &       |       ^       ~       :=
   <       >       <=      >=      ==      !=


2.6. 구분자
===========

다음 토큰들은 문법에서 구분자(delimiter)로 기능합니다:

   (       )       [       ]       {       }
   ,       :       .       ;       @       =       ->
   +=      -=      *=      /=      //=     %=      @=
   &=      |=      ^=      >>=     <<=     **=

마침표는 실수와 허수 리터럴에서도 등장할 수 있습니다. 연속된 마침표 세
개는 생략부호 리터럴(ellipsis literal)이라는 특별한 의미가 있습니다.
목록 후반의 증분 대입 연산자(augmented assignment operator)들은 어휘적
으로는 구분자로 기능하지만, 동시에 연산을 수행합니다.

다음의 인쇄되는 ASCII 문자들은 다른 토큰들 일부로서 특별한 의미가 있거
나, 그렇지 않으면 어휘 분석기에 유의미합니다:

   '       "       #       \

다음의 인쇄되는 ASCII 문자들은 파이썬에서 사용되지 않습니다. 문자열 리
터럴과 주석 이외의 곳에서 사용되는 것은 조건 없는 에러입니다:

   $       ?       `

-[ 각주 ]-

[1] https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt
