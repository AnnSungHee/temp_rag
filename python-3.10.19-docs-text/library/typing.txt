"typing" --- 형 힌트 지원
*************************

버전 3.5에 추가.

**소스 코드:** Lib/typing.py

참고:

  The Python runtime does not enforce function and variable type
  annotations. They can be used by third party tools such as type
  checkers, IDEs, linters, etc.

======================================================================

This module provides runtime support for type hints. The most
fundamental support consists of the types "Any", "Union", "Callable",
"TypeVar", and "Generic". For a full specification, please see **PEP
484**. For a simplified introduction to type hints, see **PEP 483**.

The function below takes and returns a string and is annotated as
follows:

   def greeting(name: str) -> str:
       return 'Hello ' + name

In the function "greeting", the argument "name" is expected to be of
type "str" and the return type "str". Subtypes are accepted as
arguments.

New features are frequently added to the "typing" module. The
typing_extensions package provides backports of these new features to
older versions of Python.

더 보기:

  For a quick overview of type hints, refer to this cheat sheet.

  The "Type System Reference" section of https://mypy.readthedocs.io/
  -- since the Python typing system is standardised via PEPs, this
  reference should broadly apply to most Python type checkers,
  although some parts may still be specific to mypy.

  The documentation at https://typing.readthedocs.io/ serves as useful
  reference for type system features, useful typing related tools and
  typing best practices.


Relevant PEPs
=============

Since the initial introduction of type hints in **PEP 484** and **PEP
483**, a number of PEPs have modified and enhanced Python's framework
for type annotations. These include:

* **PEP 526**: Syntax for Variable Annotations
     *Introducing* syntax for annotating variables outside of function
     definitions, and "ClassVar"

* **PEP 544**: Protocols: Structural subtyping (static duck typing)
     *Introducing* "Protocol" and the "@runtime_checkable" decorator

* **PEP 585**: Type Hinting Generics In Standard Collections
     *Introducing* "types.GenericAlias" and the ability to use
     standard library classes as generic types

* **PEP 586**: Literal Types
     *Introducing* "Literal"

* **PEP 589**: TypedDict: Type Hints for Dictionaries with a Fixed Set
  of Keys
     *Introducing* "TypedDict"

* **PEP 591**: Adding a final qualifier to typing
     *Introducing* "Final" and the "@final" decorator

* **PEP 593**: Flexible function and variable annotations
     *Introducing* "Annotated"

* **PEP 604**: Allow writing union types as "X | Y"
     *Introducing* "types.UnionType" and the ability to use the
     binary-or operator "|" to signify a union of types

* **PEP 612**: Parameter Specification Variables
     *Introducing* "ParamSpec" and "Concatenate"

* **PEP 613**: Explicit Type Aliases
     *Introducing* "TypeAlias"

* **PEP 647**: User-Defined Type Guards
     *Introducing* "TypeGuard"


형 에일리어스
=============

A type alias is defined by assigning the type to the alias. In this
example, "Vector" and "list[float]" will be treated as interchangeable
synonyms:

   Vector = list[float]

   def scale(scalar: float, vector: Vector) -> Vector:
       return [scalar * num for num in vector]

   # passes type checking; a list of floats qualifies as a Vector.
   new_vector = scale(2.0, [1.0, -4.2, 5.4])

형 에일리어스는 복잡한 형 서명을 단순화하는 데 유용합니다. 예를 들면:

   from collections.abc import Sequence

   ConnectionOptions = dict[str, str]
   Address = tuple[str, int]
   Server = tuple[Address, ConnectionOptions]

   def broadcast_message(message: str, servers: Sequence[Server]) -> None:
       ...

   # The static type checker will treat the previous type signature as
   # being exactly equivalent to this one.
   def broadcast_message(
           message: str,
           servers: Sequence[tuple[tuple[str, int], dict[str, str]]]) -> None:
       ...

Note that "None" as a type hint is a special case and is replaced by
"type(None)".


NewType
=======

Use the "NewType" helper to create distinct types:

   from typing import NewType

   UserId = NewType('UserId', int)
   some_id = UserId(524313)

정적 형 검사기는 새 형을 원래 형의 서브 클래스인 것처럼 다룹니다. 논리
에러를 잡는 데 유용합니다:

   def get_user_name(user_id: UserId) -> str:
       ...

   # passes type checking
   user_a = get_user_name(UserId(42351))

   # fails type checking; an int is not a UserId
   user_b = get_user_name(-1)

"UserId" 형의 변수에 대해 모든 "int" 연산을 여전히 수행할 수 있지만,
결과는 항상 "int" 형이 됩니다. 이것은 "int"가 기대되는 모든 곳에
"UserId"를 전달할 수 있지만, 잘못된 방식으로 의도하지 않게 "UserId"를
만들지 않도록 합니다:

   # 'output' is of type 'int', not 'UserId'
   output = UserId(23413) + UserId(54341)

Note that these checks are enforced only by the static type checker.
At runtime, the statement "Derived = NewType('Derived', Base)" will
make "Derived" a callable that immediately returns whatever parameter
you pass it. That means the expression "Derived(some_value)" does not
create a new class or introduce much overhead beyond that of a regular
function call.

더욱 정확하게, 표현식 "some_value is Derived(some_value)"는 실행 시간
에 항상 참입니다.

It is invalid to create a subtype of "Derived":

   from typing import NewType

   UserId = NewType('UserId', int)

   # Fails at runtime and does not pass type checking
   class AdminUserId(UserId): pass

However, it is possible to create a "NewType" based on a 'derived'
"NewType":

   from typing import NewType

   UserId = NewType('UserId', int)

   ProUserId = NewType('ProUserId', UserId)

그리고 "ProUserId"에 대한 형 검사는 예상대로 작동합니다.

자세한 내용은 **PEP 484**를 참조하십시오.

참고:

  Recall that the use of a type alias declares two types to be
  *equivalent* to one another. Doing "Alias = Original" will make the
  static type checker treat "Alias" as being *exactly equivalent* to
  "Original" in all cases. This is useful when you want to simplify
  complex type signatures.반면에, "NewType"은 한 형을 다른 형의 *서브
  형*으로 선언합니다. "Derived = NewType('Derived', Original)"은 정적
  형 검사기가 "Derived"를 "Original"의 *서브 클래스*로 취급하게 합니다
  . 이는 "Original" 형의 값이 "Derived" 형의 값이 예상되는 위치에서 사
  용될 수 없음을 의미합니다. 실행 시간 비용을 최소화하면서 논리 에러를
  방지하려는 경우에 유용합니다.

버전 3.5.2에 추가.

버전 3.10에서 변경: "NewType" is now a class rather than a function.
There is some additional runtime cost when calling "NewType" over a
regular function.  However, this cost will be reduced in 3.11.0.


Callable
========

Frameworks expecting callback functions of specific signatures might
be type hinted using "Callable[[Arg1Type, Arg2Type], ReturnType]".

예를 들면:

   from collections.abc import Callable

   def feeder(get_next_item: Callable[[], str]) -> None:
       # Body

   def async_query(on_success: Callable[[int], None],
                   on_error: Callable[[int, Exception], None]) -> None:
       # Body

   async def on_update(value: str) -> None:
       # Body
   callback: Callable[[str], Awaitable[None]] = on_update

It is possible to declare the return type of a callable without
specifying the call signature by substituting a literal ellipsis for
the list of arguments in the type hint: "Callable[..., ReturnType]".

Callables which take other callables as arguments may indicate that
their parameter types are dependent on each other using "ParamSpec".
Additionally, if that callable adds or removes arguments from other
callables, the "Concatenate" operator may be used.  They take the form
"Callable[ParamSpecVariable, ReturnType]" and
"Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable],
ReturnType]" respectively.

버전 3.10에서 변경: "Callable" now supports "ParamSpec" and
"Concatenate". See **PEP 612** for more details.

더 보기:

  The documentation for "ParamSpec" and "Concatenate" provides
  examples of usage in "Callable".


제네릭
======

Since type information about objects kept in containers cannot be
statically inferred in a generic way, abstract base classes have been
extended to support subscription to denote expected types for
container elements.

   from collections.abc import Mapping, Sequence

   def notify_by_email(employees: Sequence[Employee],
                       overrides: Mapping[str, str]) -> None: ...

Generics can be parameterized by using a factory available in typing
called "TypeVar".

   from collections.abc import Sequence
   from typing import TypeVar

   T = TypeVar('T')      # Declare type variable

   def first(l: Sequence[T]) -> T:   # Generic function
       return l[0]


사용자 정의 제네릭 형
=====================

사용자 정의 클래스는 제네릭 클래스로 정의 할 수 있습니다.

   from typing import TypeVar, Generic
   from logging import Logger

   T = TypeVar('T')

   class LoggedVar(Generic[T]):
       def __init__(self, value: T, name: str, logger: Logger) -> None:
           self.name = name
           self.logger = logger
           self.value = value

       def set(self, new: T) -> None:
           self.log('Set ' + repr(self.value))
           self.value = new

       def get(self) -> T:
           self.log('Get ' + repr(self.value))
           return self.value

       def log(self, message: str) -> None:
           self.logger.info('%s: %s', self.name, message)

"Generic[T]" as a base class defines that the class "LoggedVar" takes
a single type parameter "T" . This also makes "T" valid as a type
within the class body.

The "Generic" base class defines "__class_getitem__()" so that
"LoggedVar[T]" is valid as a type:

   from collections.abc import Iterable

   def zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:
       for var in vars:
           var.set(0)

A generic type can have any number of type variables. All varieties of
"TypeVar" are permissible as parameters for a generic type:

   from typing import TypeVar, Generic, Sequence

   T = TypeVar('T', contravariant=True)
   B = TypeVar('B', bound=Sequence[bytes], covariant=True)
   S = TypeVar('S', int, str)

   class WeirdTrio(Generic[T, B, S]):
       ...

"Generic"에 대한 각 형 변수 인자는 달라야 합니다. 그래서 이것은 잘못되
었습니다:

   from typing import TypeVar, Generic
   ...

   T = TypeVar('T')

   class Pair(Generic[T, T]):   # INVALID
       ...

You can use multiple inheritance with "Generic":

   from collections.abc import Sized
   from typing import TypeVar, Generic

   T = TypeVar('T')

   class LinkedList(Sized, Generic[T]):
       ...

When inheriting from generic classes, some type variables could be
fixed:

   from collections.abc import Mapping
   from typing import TypeVar

   T = TypeVar('T')

   class MyDict(Mapping[str, T]):
       ...

이 경우 "MyDict"는 단일 매개 변수 "T"를 갖습니다.

Using a generic class without specifying type parameters assumes "Any"
for each position. In the following example, "MyIterable" is not
generic but implicitly inherits from "Iterable[Any]":

   from collections.abc import Iterable

   class MyIterable(Iterable): # Same as Iterable[Any]

User defined generic type aliases are also supported. Examples:

   from collections.abc import Iterable
   from typing import TypeVar
   S = TypeVar('S')
   Response = Iterable[S] | int

   # Return type here is same as Iterable[str] | int
   def response(query: str) -> Response[str]:
       ...

   T = TypeVar('T', int, float, complex)
   Vec = Iterable[tuple[T, T]]

   def inproduct(v: Vec[T]) -> T: # Same as Iterable[tuple[T, T]]
       return sum(x*y for x, y in v)

버전 3.7에서 변경: "Generic"에는 더는 사용자 정의 메타 클래스가 없습니
다.

User-defined generics for parameter expressions are also supported via
parameter specification variables in the form "Generic[P]".  The
behavior is consistent with type variables' described above as
parameter specification variables are treated by the typing module as
a specialized type variable.  The one exception to this is that a list
of types can be used to substitute a "ParamSpec":

   >>> from typing import Generic, ParamSpec, TypeVar

   >>> T = TypeVar('T')
   >>> P = ParamSpec('P')

   >>> class Z(Generic[T, P]): ...
   ...
   >>> Z[int, [dict, float]]
   __main__.Z[int, (<class 'dict'>, <class 'float'>)]

Furthermore, a generic with only one parameter specification variable
will accept parameter lists in the forms "X[[Type1, Type2, ...]]" and
also "X[Type1, Type2, ...]" for aesthetic reasons.  Internally, the
latter is converted to the former, so the following are equivalent:

   >>> class X(Generic[P]): ...
   ...
   >>> X[int, str]
   __main__.X[(<class 'int'>, <class 'str'>)]
   >>> X[[int, str]]
   __main__.X[(<class 'int'>, <class 'str'>)]

Do note that generics with "ParamSpec" may not have correct
"__parameters__" after substitution in some cases because they are
intended primarily for static type checking.

버전 3.10에서 변경: "Generic" can now be parameterized over parameter
expressions. See "ParamSpec" and **PEP 612** for more details.

A user-defined generic class can have ABCs as base classes without a
metaclass conflict. Generic metaclasses are not supported. The outcome
of parameterizing generics is cached, and most types in the typing
module are *hashable* and comparable for equality.


"Any" 형
========

특수한 종류의 형은 "Any"입니다. 정적 형 검사기는 모든 형을 "Any"와 호
환되는 것으로, "Any"를 모든 형과 호환되는 것으로 취급합니다.

이것은 "Any" 형의 값에 대해 어떤 연산이나 메서드 호출을 수행하고, 그것
을 임의의 변수에 대입할 수 있다는 것을 의미합니다:

   from typing import Any

   a: Any = None
   a = []          # OK
   a = 2           # OK

   s: str = ''
   s = a           # OK

   def foo(item: Any) -> int:
       # Passes type checking; 'item' could be any type,
       # and that type might have a 'bar' method
       item.bar()
       ...

Notice that no type checking is performed when assigning a value of
type "Any" to a more precise type. For example, the static type
checker did not report an error when assigning "a" to "s" even though
"s" was declared to be of type "str" and receives an "int" value at
runtime!

또한, 반환형이나 매개 변수 형이 없는 모든 함수는 묵시적으로 "Any" 기본
값을 사용합니다:

   def legacy_parser(text):
       ...
       return data

   # A static type checker will treat the above
   # as having the same signature as:
   def legacy_parser(text: Any) -> Any:
       ...
       return data

이 동작은 여러분이 동적으로 형이 지정되는 코드와 정적으로 형이 지정되
는 코드를 혼합해야 할 때 "Any"를 *탈출구*로 사용할 수 있도록 합니다.

"Any"의 동작과 "object"의 동작을 대조하십시오. "Any"와 유사하게, 모든
형은 "object"의 서브 형입니다. 그러나, "Any"와는 달리, 그 반대는 사실
이 아닙니다: "object"는 다른 모든 형의 서브 형이 *아닙*니다.

이것은 값의 형이 "object"일 때, 형 검사기가 그것에 대한 거의 모든 연산
을 거부하고, 그것을 더 특수한 형의 변수에 대입(또는 그것을 반환 값으로
사용)하는 것이 형 에러임을 의미합니다. 예를 들면:

   def hash_a(item: object) -> int:
       # Fails type checking; an object does not have a 'magic' method.
       item.magic()
       ...

   def hash_b(item: Any) -> int:
       # Passes type checking
       item.magic()
       ...

   # Passes type checking, since ints and strs are subclasses of object
   hash_a(42)
   hash_a("foo")

   # Passes type checking, since Any is compatible with all types
   hash_b(42)
   hash_b("foo")

값이 형 안전한 방식으로 모든 형이 될 수 있음을 표시하려면 "object"를
사용하십시오. 값이 동적으로 형이 지정됨을 표시하려면 "Any"를 사용하십
시오.


명목적 대 구조적 서브 타이핑
============================

Initially **PEP 484** defined the Python static type system as using
*nominal subtyping*. This means that a class "A" is allowed where a
class "B" is expected if and only if "A" is a subclass of "B".

이 요구 사항은 이전에 "Iterable"과 같은 추상 베이스 클래스에도 적용되
었습니다. 이 접근 방식의 문제점은 이것을 지원하려면 클래스를 명시적으
로 표시해야만 한다는 점입니다. 이는 파이썬답지 않고 관용적인 동적으로
형이 지정된 파이썬 코드에서 일반적으로 수행하는 것과는 다릅니다. 예를
들어, 이것은 **PEP 484**를 만족합니다:

   from collections.abc import Sized, Iterable, Iterator

   class Bucket(Sized, Iterable[int]):
       ...
       def __len__(self) -> int: ...
       def __iter__(self) -> Iterator[int]: ...

**PEP 544**는 사용자가 클래스 정의에서 명시적인 베이스 클래스 없이 위
의 코드를 작성할 수 있게 함으로써 이 문제를 풀도록 합니다. 정적 형 검
사기가 "Bucket"을 "Sized"와 "Iterable[int]"의 서브 형으로 묵시적으로
취급하도록 합니다. 이것은 *구조적 서브 타이핑(structural subtyping)*(
또는 정적 덕 타이핑)으로 알려져 있습니다:

   from collections.abc import Iterator, Iterable

   class Bucket:  # Note: no base classes
       ...
       def __len__(self) -> int: ...
       def __iter__(self) -> Iterator[int]: ...

   def collect(items: Iterable[int]) -> int: ...
   result = collect(Bucket())  # Passes type check

또한, 특별한 클래스 "Protocol"을 서브 클래싱 함으로써, 사용자는 새로운
사용자 정의 프로토콜을 정의하여 구조적 서브 타이핑을 완전히 누릴 수 있
습니다 (아래 예를 참조하십시오).


모듈 내용
=========

The module defines the following classes, functions and decorators.

참고:

  This module defines several types that are subclasses of pre-
  existing standard library classes which also extend "Generic" to
  support type variables inside "[]". These types became redundant in
  Python 3.9 when the corresponding pre-existing classes were enhanced
  to support "[]".The redundant types are deprecated as of Python 3.9
  but no deprecation warnings will be issued by the interpreter. It is
  expected that type checkers will flag the deprecated types when the
  checked program targets Python 3.9 or newer.The deprecated types
  will be removed from the "typing" module in the first Python version
  released 5 years after the release of Python 3.9.0. See details in
  **PEP 585**—*Type Hinting Generics In Standard Collections*.


특수 타이핑 프리미티브
----------------------


특수형
~~~~~~

These can be used as types in annotations and do not support "[]".

typing.Any

   제한되지 않는 형을 나타내는 특수형.

   * 모든 형은 "Any"와 호환됩니다.

   * "Any"는 모든 형과 호환됩니다.

typing.NoReturn

   Special type indicating that a function never returns. For example:

      from typing import NoReturn

      def stop() -> NoReturn:
          raise RuntimeError('no way')

   버전 3.5.4에 추가.

   버전 3.6.2에 추가.

typing.TypeAlias

   Special annotation for explicitly declaring a type alias. For
   example:

      from typing import TypeAlias

      Factors: TypeAlias = list[int]

   See **PEP 613** for more details about explicit type aliases.

   버전 3.10에 추가.


특수 형태
~~~~~~~~~

These can be used as types in annotations using "[]", each having a
unique syntax.

typing.Tuple

   Tuple type; "Tuple[X, Y]" is the type of a tuple of two items with
   the first item of type X and the second of type Y. The type of the
   empty tuple can be written as "Tuple[()]".

   Example: "Tuple[T1, T2]" is a tuple of two elements corresponding
   to type variables T1 and T2.  "Tuple[int, float, str]" is a tuple
   of an int, a float and a string.

   To specify a variable-length tuple of homogeneous type, use literal
   ellipsis, e.g. "Tuple[int, ...]". A plain "Tuple" is equivalent to
   "Tuple[Any, ...]", and in turn to "tuple".

   버전 3.9부터 폐지: "builtins.tuple" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

typing.Union

   Union type; "Union[X, Y]" is equivalent to "X | Y" and means either
   X or Y.

   To define a union, use e.g. "Union[int, str]" or the shorthand "int
   | str". Using that shorthand is recommended. Details:

   * 인자는 형이어야 하며 적어도 하나 있어야 합니다.

   * 공용체의 공용체는 펼쳐집니다, 예를 들어:

        Union[Union[int, str], float] == Union[int, str, float]

   * 단일 인자의 공용체는 사라집니다. 예를 들어:

        Union[int] == int  # The constructor actually returns int

   * 중복 인자는 건너뜁니다. 예를 들어:

        Union[int, str, int] == Union[int, str] == int | str

   * 공용체를 비교할 때, 인자 순서가 무시됩니다, 예를 들어:

        Union[int, str] == Union[str, int]

   * You cannot subclass or instantiate a "Union".

   * "Union[X][Y]"라고 쓸 수 없습니다.

   버전 3.7에서 변경: 실행 시간에 공용체의 명시적 서브 클래스를 제거하
   지 않습니다.

   버전 3.10에서 변경: Unions can now be written as "X | Y". See union
   type expressions.

typing.Optional

   Optional type.

   "Optional[X]" is equivalent to "X | None" (or "Union[X, None]").

   이는 기본값을 갖는 선택적 인자와 같은 개념이 아님에 유의하십시오.
   단지 선택적이기 때문에 기본값을 갖는 선택적 인자가 형 어노테이션에
   "Optional" 한정자가 필요하지는 않습니다. 예를 들면:

      def foo(arg: int = 0) -> None:
          ...

   한편, 명시적인 "None" 값이 허용되면, 인자가 선택적인지와 관계없이
   "Optional"을 사용하는 것이 적합합니다. 예를 들면:

      def foo(arg: Optional[int] = None) -> None:
          ...

   버전 3.10에서 변경: Optional can now be written as "X | None". See
   union type expressions.

typing.Callable

   Callable type; "Callable[[int], str]" is a function of (int) ->
   str.

   The subscription syntax must always be used with exactly two
   values: the argument list and the return type.  The argument list
   must be a list of types or an ellipsis; the return type must be a
   single type.

   There is no syntax to indicate optional or keyword arguments; such
   function types are rarely used as callback types. "Callable[...,
   ReturnType]" (literal ellipsis) can be used to type hint a callable
   taking any number of arguments and returning "ReturnType".  A plain
   "Callable" is equivalent to "Callable[..., Any]", and in turn to
   "collections.abc.Callable".

   Callables which take other callables as arguments may indicate that
   their parameter types are dependent on each other using
   "ParamSpec". Additionally, if that callable adds or removes
   arguments from other callables, the "Concatenate" operator may be
   used.  They take the form "Callable[ParamSpecVariable, ReturnType]"
   and "Callable[Concatenate[Arg1Type, Arg2Type, ...,
   ParamSpecVariable], ReturnType]" respectively.

   버전 3.9부터 폐지: "collections.abc.Callable" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

   버전 3.10에서 변경: "Callable" now supports "ParamSpec" and
   "Concatenate". See **PEP 612** for more details.

   더 보기:

     The documentation for "ParamSpec" and "Concatenate" provide
     examples of usage with "Callable".

typing.Concatenate

   Used with "Callable" and "ParamSpec" to type annotate a higher
   order callable which adds, removes, or transforms parameters of
   another callable.  Usage is in the form "Concatenate[Arg1Type,
   Arg2Type, ..., ParamSpecVariable]". "Concatenate" is currently only
   valid when used as the first argument to a "Callable". The last
   parameter to "Concatenate" must be a "ParamSpec".

   For example, to annotate a decorator "with_lock" which provides a
   "threading.Lock" to the decorated function,  "Concatenate" can be
   used to indicate that "with_lock" expects a callable which takes in
   a "Lock" as the first argument, and returns a callable with a
   different type signature.  In this case, the "ParamSpec" indicates
   that the returned callable's parameter types are dependent on the
   parameter types of the callable being passed in:

      from collections.abc import Callable
      from threading import Lock
      from typing import Concatenate, ParamSpec, TypeVar

      P = ParamSpec('P')
      R = TypeVar('R')

      # Use this lock to ensure that only one thread is executing a function
      # at any time.
      my_lock = Lock()

      def with_lock(f: Callable[Concatenate[Lock, P], R]) -> Callable[P, R]:
          '''A type-safe decorator which provides a lock.'''
          def inner(*args: P.args, **kwargs: P.kwargs) -> R:
              # Provide the lock as the first argument.
              return f(my_lock, *args, **kwargs)
          return inner

      @with_lock
      def sum_threadsafe(lock: Lock, numbers: list[float]) -> float:
          '''Add a list of numbers together in a thread-safe manner.'''
          with lock:
              return sum(numbers)

      # We don't need to pass in the lock ourselves thanks to the decorator.
      sum_threadsafe([1.1, 2.2, 3.3])

버전 3.10에 추가.

더 보기:

  * **PEP 612** -- Parameter Specification Variables (the PEP which
    introduced "ParamSpec" and "Concatenate").

  * "ParamSpec" and "Callable".

class typing.Type(Generic[CT_co])

   A variable annotated with "C" may accept a value of type "C". In
   contrast, a variable annotated with "Type[C]" may accept values
   that are classes themselves -- specifically, it will accept the
   *class object* of "C". For example:

      a = 3         # Has type 'int'
      b = int       # Has type 'Type[int]'
      c = type(a)   # Also has type 'Type[int]'

   Note that "Type[C]" is covariant:

      class User: ...
      class BasicUser(User): ...
      class ProUser(User): ...
      class TeamUser(User): ...

      # Accepts User, BasicUser, ProUser, TeamUser, ...
      def make_new_user(user_class: Type[User]) -> User:
          # ...
          return user_class()

   The fact that "Type[C]" is covariant implies that all subclasses of
   "C" should implement the same constructor signature and class
   method signatures as "C". The type checker should flag violations
   of this, but should also allow constructor calls in subclasses that
   match the constructor calls in the indicated base class. How the
   type checker is required to handle this particular case may change
   in future revisions of **PEP 484**.

   The only legal parameters for "Type" are classes, "Any", type
   variables, and unions of any of these types. For example:

      def new_non_team_user(user_class: Type[BasicUser | ProUser]): ...

   "Type[Any]" is equivalent to "Type" which in turn is equivalent to
   "type", which is the root of Python's metaclass hierarchy.

   버전 3.5.2에 추가.

   버전 3.9부터 폐지: "builtins.type" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

typing.Literal

   A type that can be used to indicate to type checkers that the
   corresponding variable or function parameter has a value equivalent
   to the provided literal (or one of several literals). For example:

      def validate_simple(data: Any) -> Literal[True]:  # always returns True
          ...

      MODE = Literal['r', 'rb', 'w', 'wb']
      def open_helper(file: str, mode: MODE) -> str:
          ...

      open_helper('/some/path', 'r')  # Passes type check
      open_helper('/other/path', 'typo')  # Error in type checker

   "Literal[...]"은 서브 클래싱 될 수 없습니다. 실행 시간에는, 임의의
   값이 "Literal[...]"에 대한 형 인자로 허용되지만, 형 검사기는 제한을
   부과할 수 있습니다. 리터럴 형에 대한 자세한 내용은 **PEP 586**을 참
   조하십시오.

   버전 3.8에 추가.

   버전 3.9.1에서 변경: "Literal" now de-duplicates parameters.
   Equality comparisons of "Literal" objects are no longer order
   dependent. "Literal" objects will now raise a "TypeError" exception
   during equality comparisons if one of their parameters are not
   *hashable*.

typing.ClassVar

   클래스 변수를 표시하기 위한 특수 형 구조물.

   **PEP 526**에서 소개된 것처럼, ClassVar로 감싼 변수 어노테이션은 주
   어진 어트리뷰트가 클래스 변수로 사용되도록 의도되었으며 해당 클래스
   의 인스턴스에 설정되어서는 안 됨을 나타냅니다. 용법:

      class Starship:
          stats: ClassVar[dict[str, int]] = {} # class variable
          damage: int = 10                     # instance variable

   "ClassVar"는 형만 받아들이며 더는 서브 스크립트 할 수 없습니다.

   "ClassVar"는 클래스 자체가 아니므로, "isinstance()"나
   "issubclass()"와 함께 사용하면 안 됩니다. "ClassVar"는 파이썬 실행
   시간 동작을 변경하지 않지만, 제삼자 형 검사기에서 사용할 수 있습니
   다. 예를 들어, 형 검사기는 다음 코드를 에러로 표시 할 수 있습니다:

      enterprise_d = Starship(3000)
      enterprise_d.stats = {} # Error, setting class variable on instance
      Starship.stats = {}     # This is OK

   버전 3.5.3에 추가.

typing.Final

   A special typing construct to indicate to type checkers that a name
   cannot be re-assigned or overridden in a subclass. For example:

      MAX_SIZE: Final = 9000
      MAX_SIZE += 1  # Error reported by type checker

      class Connection:
          TIMEOUT: Final[int] = 10

      class FastConnector(Connection):
          TIMEOUT = 1  # Error reported by type checker

   이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 **PEP
   591**을 참조하십시오.

   버전 3.8에 추가.

typing.Annotated

   A type, introduced in **PEP 593** ("Flexible function and variable
   annotations"), to decorate existing types with context-specific
   metadata (possibly multiple pieces of it, as "Annotated" is
   variadic). Specifically, a type "T" can be annotated with metadata
   "x" via the typehint "Annotated[T, x]". This metadata can be used
   for either static analysis or at runtime. If a library (or tool)
   encounters a typehint "Annotated[T, x]" and has no special logic
   for metadata "x", it should ignore it and simply treat the type as
   "T". Unlike the "no_type_check" functionality that currently exists
   in the "typing" module which completely disables typechecking
   annotations on a function or a class, the "Annotated" type allows
   for both static typechecking of "T" (which can safely ignore "x")
   together with runtime access to "x" within a specific application.

   Ultimately, the responsibility of how to interpret the annotations
   (if at all) is the responsibility of the tool or library
   encountering the "Annotated" type. A tool or library encountering
   an "Annotated" type can scan through the annotations to determine
   if they are of interest (e.g., using "isinstance()").

   When a tool or a library does not support annotations or encounters
   an unknown annotation it should just ignore it and treat annotated
   type as the underlying type.

   It's up to the tool consuming the annotations to decide whether the
   client is allowed to have several annotations on one type and how
   to merge those annotations.

   Since the "Annotated" type allows you to put several annotations of
   the same (or different) type(s) on any node, the tools or libraries
   consuming those annotations are in charge of dealing with potential
   duplicates. For example, if you are doing value range analysis you
   might allow this:

      T1 = Annotated[int, ValueRange(-10, 5)]
      T2 = Annotated[T1, ValueRange(-20, 3)]

   Passing "include_extras=True" to "get_type_hints()" lets one access
   the extra annotations at runtime.

   The details of the syntax:

   * The first argument to "Annotated" must be a valid type

   * Multiple type annotations are supported ("Annotated" supports
     variadic arguments):

        Annotated[int, ValueRange(3, 10), ctype("char")]

   * "Annotated" must be called with at least two arguments (
     "Annotated[int]" is not valid)

   * The order of the annotations is preserved and matters for
     equality checks:

        Annotated[int, ValueRange(3, 10), ctype("char")] != Annotated[
            int, ctype("char"), ValueRange(3, 10)
        ]

   * Nested "Annotated" types are flattened, with metadata ordered
     starting with the innermost annotation:

        Annotated[Annotated[int, ValueRange(3, 10)], ctype("char")] == Annotated[
            int, ValueRange(3, 10), ctype("char")
        ]

   * Duplicated annotations are not removed:

        Annotated[int, ValueRange(3, 10)] != Annotated[
            int, ValueRange(3, 10), ValueRange(3, 10)
        ]

   * "Annotated" can be used with nested and generic aliases:

        T = TypeVar('T')
        Vec = Annotated[list[tuple[T, T]], MaxLen(10)]
        V = Vec[int]

        V == Annotated[list[tuple[int, int]], MaxLen(10)]

   버전 3.9에 추가.

typing.TypeGuard

   Special typing form used to annotate the return type of a user-
   defined type guard function.  "TypeGuard" only accepts a single
   type argument. At runtime, functions marked this way should return
   a boolean.

   "TypeGuard" aims to benefit *type narrowing* -- a technique used by
   static type checkers to determine a more precise type of an
   expression within a program's code flow.  Usually type narrowing is
   done by analyzing conditional code flow and applying the narrowing
   to a block of code.  The conditional expression here is sometimes
   referred to as a "type guard":

      def is_str(val: str | float):
          # "isinstance" type guard
          if isinstance(val, str):
              # Type of ``val`` is narrowed to ``str``
              ...
          else:
              # Else, type of ``val`` is narrowed to ``float``.
              ...

   Sometimes it would be convenient to use a user-defined boolean
   function as a type guard.  Such a function should use
   "TypeGuard[...]" as its return type to alert static type checkers
   to this intention.

   Using  "-> TypeGuard" tells the static type checker that for a
   given function:

   1. The return value is a boolean.

   2. If the return value is "True", the type of its argument is the
      type inside "TypeGuard".

   예를 들면:

      def is_str_list(val: List[object]) -> TypeGuard[List[str]]:
          '''Determines whether all objects in the list are strings'''
          return all(isinstance(x, str) for x in val)

      def func1(val: List[object]):
          if is_str_list(val):
              # Type of ``val`` is narrowed to ``List[str]``.
              print(" ".join(val))
          else:
              # Type of ``val`` remains as ``List[object]``.
              print("Not a list of strings!")

   If "is_str_list" is a class or instance method, then the type in
   "TypeGuard" maps to the type of the second parameter after "cls" or
   "self".

   In short, the form "def foo(arg: TypeA) -> TypeGuard[TypeB]: ...",
   means that if "foo(arg)" returns "True", then "arg" narrows from
   "TypeA" to "TypeB".

   참고:

     "TypeB" need not be a narrower form of "TypeA" -- it can even be
     a wider form. The main reason is to allow for things like
     narrowing "List[object]" to "List[str]" even though the latter is
     not a subtype of the former, since "List" is invariant. The
     responsibility of writing type-safe type guards is left to the
     user.

   "TypeGuard" also works with type variables.  See **PEP 647** for
   more details.

   버전 3.10에 추가.


Building generic types
~~~~~~~~~~~~~~~~~~~~~~

These are not used in annotations. They are building blocks for
creating generic types.

class typing.Generic

   제네릭 형을 위한 추상 베이스 클래스.

   A generic type is typically declared by inheriting from an
   instantiation of this class with one or more type variables. For
   example, a generic mapping type might be defined as:

      class Mapping(Generic[KT, VT]):
          def __getitem__(self, key: KT) -> VT:
              ...
              # Etc.

   이 클래스는 다음과 같이 사용할 수 있습니다:

      X = TypeVar('X')
      Y = TypeVar('Y')

      def lookup_name(mapping: Mapping[X, Y], key: X, default: Y) -> Y:
          try:
              return mapping[key]
          except KeyError:
              return default

class typing.TypeVar

   형 변수.

   용법:

      T = TypeVar('T')  # Can be anything
      S = TypeVar('S', bound=str)  # Can be any subtype of str
      A = TypeVar('A', str, bytes)  # Must be exactly str or bytes

   Type variables exist primarily for the benefit of static type
   checkers.  They serve as the parameters for generic types as well
   as for generic function definitions.  See "Generic" for more
   information on generic types.  Generic functions work as follows:

      def repeat(x: T, n: int) -> Sequence[T]:
          """Return a list containing n references to x."""
          return [x]*n


      def print_capitalized(x: S) -> S:
          """Print x capitalized, and return x."""
          print(x.capitalize())
          return x


      def concatenate(x: A, y: A) -> A:
          """Add two strings or bytes objects together."""
          return x + y

   Note that type variables can be *bound*, *constrained*, or neither,
   but cannot be both bound *and* constrained.

   Constrained type variables and bound type variables have different
   semantics in several important ways. Using a *constrained* type
   variable means that the "TypeVar" can only ever be solved as being
   exactly one of the constraints given:

      a = concatenate('one', 'two')  # Ok, variable 'a' has type 'str'
      b = concatenate(StringSubclass('one'), StringSubclass('two'))  # Inferred type of variable 'b' is 'str',
                                                                     # despite 'StringSubclass' being passed in
      c = concatenate('one', b'two')  # error: type variable 'A' can be either 'str' or 'bytes' in a function call, but not both

   Using a *bound* type variable, however, means that the "TypeVar"
   will be solved using the most specific type possible:

      print_capitalized('a string')  # Ok, output has type 'str'

      class StringSubclass(str):
          pass

      print_capitalized(StringSubclass('another string'))  # Ok, output has type 'StringSubclass'
      print_capitalized(45)  # error: int is not a subtype of str

   Type variables can be bound to concrete types, abstract types (ABCs
   or protocols), and even unions of types:

      U = TypeVar('U', bound=str|bytes)  # Can be any subtype of the union str|bytes
      V = TypeVar('V', bound=SupportsAbs)  # Can be anything with an __abs__ method

   Bound type variables are particularly useful for annotating
   "classmethods" that serve as alternative constructors. In the
   following example (by Raymond Hettinger), the type variable "C" is
   bound to the "Circle" class through the use of a forward reference.
   Using this type variable to annotate the "with_circumference"
   classmethod, rather than hardcoding the return type as "Circle",
   means that a type checker can correctly infer the return type even
   if the method is called on a subclass:

      import math

      C = TypeVar('C', bound='Circle')

      class Circle:
          """An abstract circle"""

          def __init__(self, radius: float) -> None:
              self.radius = radius

          # Use a type variable to show that the return type
          # will always be an instance of whatever ``cls`` is
          @classmethod
          def with_circumference(cls: type[C], circumference: float) -> C:
              """Create a circle with the specified circumference"""
              radius = circumference / (math.pi * 2)
              return cls(radius)


      class Tire(Circle):
          """A specialised circle (made out of rubber)"""

          MATERIAL = 'rubber'


      c = Circle.with_circumference(3)  # Ok, variable 'c' has type 'Circle'
      t = Tire.with_circumference(4)  # Ok, variable 't' has type 'Tire' (not 'Circle')

   At runtime, "isinstance(x, T)" will raise "TypeError".  In general,
   "isinstance()" and "issubclass()" should not be used with types.

   Type variables may be marked covariant or contravariant by passing
   "covariant=True" or "contravariant=True".  See **PEP 484** for more
   details.  By default, type variables are invariant.

class typing.ParamSpec(name, *, bound=None, covariant=False, contravariant=False)

   Parameter specification variable.  A specialized version of "type
   variables".

   용법:

      P = ParamSpec('P')

   Parameter specification variables exist primarily for the benefit
   of static type checkers.  They are used to forward the parameter
   types of one callable to another callable -- a pattern commonly
   found in higher order functions and decorators.  They are only
   valid when used in "Concatenate", or as the first argument to
   "Callable", or as parameters for user-defined Generics.  See
   "Generic" for more information on generic types.

   For example, to add basic logging to a function, one can create a
   decorator "add_logging" to log function calls.  The parameter
   specification variable tells the type checker that the callable
   passed into the decorator and the new callable returned by it have
   inter-dependent type parameters:

      from collections.abc import Callable
      from typing import TypeVar, ParamSpec
      import logging

      T = TypeVar('T')
      P = ParamSpec('P')

      def add_logging(f: Callable[P, T]) -> Callable[P, T]:
          '''A type-safe decorator to add logging to a function.'''
          def inner(*args: P.args, **kwargs: P.kwargs) -> T:
              logging.info(f'{f.__name__} was called')
              return f(*args, **kwargs)
          return inner

      @add_logging
      def add_two(x: float, y: float) -> float:
          '''Add two numbers together.'''
          return x + y

   Without "ParamSpec", the simplest way to annotate this previously
   was to use a "TypeVar" with bound "Callable[..., Any]".  However
   this causes two problems:

   1. The type checker can't type check the "inner" function because
      "*args" and "**kwargs" have to be typed "Any".

   2. "cast()" may be required in the body of the "add_logging"
      decorator when returning the "inner" function, or the static
      type checker must be told to ignore the "return inner".

   args

   kwargs

      Since "ParamSpec" captures both positional and keyword
      parameters, "P.args" and "P.kwargs" can be used to split a
      "ParamSpec" into its components.  "P.args" represents the tuple
      of positional parameters in a given call and should only be used
      to annotate "*args".  "P.kwargs" represents the mapping of
      keyword parameters to their values in a given call, and should
      be only be used to annotate "**kwargs".  Both attributes require
      the annotated parameter to be in scope. At runtime, "P.args" and
      "P.kwargs" are instances respectively of "ParamSpecArgs" and
      "ParamSpecKwargs".

   Parameter specification variables created with "covariant=True" or
   "contravariant=True" can be used to declare covariant or
   contravariant generic types.  The "bound" argument is also
   accepted, similar to "TypeVar".  However the actual semantics of
   these keywords are yet to be decided.

   버전 3.10에 추가.

   참고:

     Only parameter specification variables defined in global scope
     can be pickled.

   더 보기:

     * **PEP 612** -- Parameter Specification Variables (the PEP which
       introduced "ParamSpec" and "Concatenate").

     * "Callable" and "Concatenate".

typing.ParamSpecArgs

typing.ParamSpecKwargs

   Arguments and keyword arguments attributes of a "ParamSpec". The
   "P.args" attribute of a "ParamSpec" is an instance of
   "ParamSpecArgs", and "P.kwargs" is an instance of
   "ParamSpecKwargs". They are intended for runtime introspection and
   have no special meaning to static type checkers.

   Calling "get_origin()" on either of these objects will return the
   original "ParamSpec":

      P = ParamSpec("P")
      get_origin(P.args)  # returns P
      get_origin(P.kwargs)  # returns P

   버전 3.10에 추가.

typing.AnyStr

   "AnyStr" is a "constrained type variable" defined as "AnyStr =
   TypeVar('AnyStr', str, bytes)".

   It is meant to be used for functions that may accept any kind of
   string without allowing different kinds of strings to mix. For
   example:

      def concat(a: AnyStr, b: AnyStr) -> AnyStr:
          return a + b

      concat(u"foo", u"bar")  # Ok, output has type 'unicode'
      concat(b"foo", b"bar")  # Ok, output has type 'bytes'
      concat(u"foo", b"bar")  # Error, cannot mix unicode and bytes

class typing.Protocol(Generic)

   Base class for protocol classes. Protocol classes are defined like
   this:

      class Proto(Protocol):
          def meth(self) -> int:
              ...

   이러한 클래스는 주로 구조적 서브 타이핑(정적 덕 타이핑)을 인식하는
   정적 형 검사기와 함께 사용됩니다, 예를 들어:

      class C:
          def meth(self) -> int:
              return 0

      def func(x: Proto) -> int:
          return x.meth()

      func(C())  # Passes static type check

   See **PEP 544** for more details. Protocol classes decorated with
   "runtime_checkable()" (described later) act as simple-minded
   runtime protocols that check only the presence of given attributes,
   ignoring their type signatures.

   프로토콜 클래스는 제네릭일 수 있습니다, 예를 들어:

      class GenProto(Protocol[T]):
          def meth(self) -> T:
              ...

   버전 3.8에 추가.

@typing.runtime_checkable

   프로토콜 클래스를 실행 시간 프로토콜로 표시합니다.

   Such a protocol can be used with "isinstance()" and "issubclass()".
   This raises "TypeError" when applied to a non-protocol class.  This
   allows a simple-minded structural check, very similar to "one trick
   ponies" in "collections.abc" such as "Iterable".  For example:

      @runtime_checkable
      class Closable(Protocol):
          def close(self): ...

      assert isinstance(open('/some/file'), Closable)

      @runtime_checkable
      class Named(Protocol):
          name: str

      import threading
      assert isinstance(threading.Thread(name='Bob'), Named)

   참고:

     "runtime_checkable()" will check only the presence of the
     required methods or attributes, not their type signatures or
     types. For example, "ssl.SSLObject" is a class, therefore it
     passes an "issubclass()" check against "Callable".  However, the
     "ssl.SSLObject.__init__" method exists only to raise a
     "TypeError" with a more informative message, therefore making it
     impossible to call (instantiate) "ssl.SSLObject".

   참고:

     An "isinstance()" check against a runtime-checkable protocol can
     be surprisingly slow compared to an "isinstance()" check against
     a non-protocol class. Consider using alternative idioms such as
     "hasattr()" calls for structural checks in performance-sensitive
     code.

   버전 3.8에 추가.


기타 특수 지시자
~~~~~~~~~~~~~~~~

These are not used in annotations. They are building blocks for
declaring types.

class typing.NamedTuple

   형 지정된(typed) "collections.namedtuple()" 버전.

   용법:

      class Employee(NamedTuple):
          name: str
          id: int

   이것은 다음과 동등합니다:

      Employee = collections.namedtuple('Employee', ['name', 'id'])

   필드에 기본값을 부여하려면, 클래스 바디에서 그 값을 대입할 수 있습
   니다:

      class Employee(NamedTuple):
          name: str
          id: int = 3

      employee = Employee('Guido')
      assert employee.id == 3

   기본값이 있는 필드는 기본값이 없는 모든 필드 뒤에 와야 합니다.

   The resulting class has an extra attribute "__annotations__" giving
   a dict that maps the field names to the field types.  (The field
   names are in the "_fields" attribute and the default values are in
   the "_field_defaults" attribute, both of which are part of the
   "namedtuple()" API.)

   "NamedTuple" 서브 클래스는 독스트링과 메서드도 가질 수 있습니다:

      class Employee(NamedTuple):
          """Represents an employee."""
          name: str
          id: int = 3

          def __repr__(self) -> str:
              return f'<Employee {self.name}, id={self.id}>'

   이전 버전과 호환되는 사용법:

      Employee = NamedTuple('Employee', [('name', str), ('id', int)])

   버전 3.6에서 변경: **PEP 526** 변수 어노테이션 문법 지원을 추가했습
   니다.

   버전 3.6.1에서 변경: 기본값, 메서드 및 독스트링에 대한 지원을 추가
   했습니다.

   버전 3.8에서 변경: "_field_types"와 "__annotations__" 어트리뷰트는
   이제 "OrderedDict" 인스턴스가 아닌 일반 딕셔너리입니다.

   버전 3.9에서 변경: "_field_types" 어트리뷰트를 제거하고, 같은 정보
   를 가지는 더 표준적인 "__annotations__" 어트리뷰트로 대체했습니다.

class typing.NewType(name, tp)

   A helper class to indicate a distinct type to a typechecker, see
   NewType. At runtime it returns an object that returns its argument
   when called. Usage:

      UserId = NewType('UserId', int)
      first_user = UserId(1)

   버전 3.5.2에 추가.

   버전 3.10에서 변경: "NewType" is now a class rather than a
   function.

class typing.TypedDict(dict)

   딕셔너리에 형 힌트를 추가하는 특수 구조. 실행 시간에 일반 "dict"입
   니다.

   "TypedDict"는 모든 인스턴스가 각 키가 일관된 형의 값에 연관되는, 특
   정한 키 집합을 갖도록 기대되는 딕셔너리 형을 선언합니다. 이 기대는
   실행 시간에는 검사되지 않고, 형 검사기에서만 강제됩니다. 사용법:

      class Point2D(TypedDict):
          x: int
          y: int
          label: str

      a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
      b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check

      assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')

   To allow using this feature with older versions of Python that do
   not support **PEP 526**, "TypedDict" supports two additional
   equivalent syntactic forms:

      Point2D = TypedDict('Point2D', x=int, y=int, label=str)
      Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})

   The functional syntax should also be used when any of the keys are
   not valid identifiers, for example because they are keywords or
   contain hyphens. Example:

      # raises SyntaxError
      class Point2D(TypedDict):
          in: int  # 'in' is a keyword
          x-y: int  # name with hyphens

      # OK, functional syntax
      Point2D = TypedDict('Point2D', {'in': int, 'x-y': int})

   By default, all keys must be present in a "TypedDict". It is
   possible to override this by specifying totality. Usage:

      class Point2D(TypedDict, total=False):
          x: int
          y: int

   This means that a "Point2D" "TypedDict" can have any of the keys
   omitted. A type checker is only expected to support a literal
   "False" or "True" as the value of the "total" argument. "True" is
   the default, and makes all items defined in the class body
   required.

   It is possible for a "TypedDict" type to inherit from one or more
   other "TypedDict" types using the class-based syntax. Usage:

      class Point3D(Point2D):
          z: int

   "Point3D" has three items: "x", "y" and "z". It is equivalent to
   this definition:

      class Point3D(TypedDict):
          x: int
          y: int
          z: int

   A "TypedDict" cannot inherit from a non-"TypedDict" class, notably
   including "Generic". For example:

      class X(TypedDict):
          x: int

      class Y(TypedDict):
          y: int

      class Z(object): pass  # A non-TypedDict class

      class XY(X, Y): pass  # OK

      class XZ(X, Z): pass  # raises TypeError

      T = TypeVar('T')
      class XT(X, Generic[T]): pass  # raises TypeError

   A "TypedDict" can be introspected via annotations dicts (see
   Annotations Best Practices for more information on annotations best
   practices), "__total__", "__required_keys__", and
   "__optional_keys__".

   __total__

      "Point2D.__total__" gives the value of the "total" argument.
      Example:

         >>> from typing import TypedDict
         >>> class Point2D(TypedDict): pass
         >>> Point2D.__total__
         True
         >>> class Point2D(TypedDict, total=False): pass
         >>> Point2D.__total__
         False
         >>> class Point3D(Point2D): pass
         >>> Point3D.__total__
         True

   __required_keys__

      버전 3.9에 추가.

   __optional_keys__

      "Point2D.__required_keys__" and "Point2D.__optional_keys__"
      return "frozenset" objects containing required and non-required
      keys, respectively. Currently the only way to declare both
      required and non-required keys in the same "TypedDict" is mixed
      inheritance, declaring a "TypedDict" with one value for the
      "total" argument and then inheriting it from another "TypedDict"
      with a different value for "total". Usage:

         >>> class Point2D(TypedDict, total=False):
         ...     x: int
         ...     y: int
         ...
         >>> class Point3D(Point2D):
         ...     z: int
         ...
         >>> Point3D.__required_keys__ == frozenset({'z'})
         True
         >>> Point3D.__optional_keys__ == frozenset({'x', 'y'})
         True

      버전 3.9에 추가.

   추가 예제와 "TypedDict"를 사용하는 자세한 규칙은 **PEP 589**를 참조
   하십시오.

   버전 3.8에 추가.


Generic concrete collections
----------------------------


Corresponding to built-in types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class typing.Dict(dict, MutableMapping[KT, VT])

   A generic version of "dict". Useful for annotating return types. To
   annotate arguments it is preferred to use an abstract collection
   type such as "Mapping".

   This type can be used as follows:

      def count_words(text: str) -> Dict[str, int]:
          ...

   버전 3.9부터 폐지: "builtins.dict" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.List(list, MutableSequence[T])

   Generic version of "list". Useful for annotating return types. To
   annotate arguments it is preferred to use an abstract collection
   type such as "Sequence" or "Iterable".

   This type may be used as follows:

      T = TypeVar('T', int, float)

      def vec2(x: T, y: T) -> List[T]:
          return [x, y]

      def keep_positives(vector: Sequence[T]) -> List[T]:
          return [item for item in vector if item > 0]

   버전 3.9부터 폐지: "builtins.list" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Set(set, MutableSet[T])

   A generic version of "builtins.set". Useful for annotating return
   types. To annotate arguments it is preferred to use an abstract
   collection type such as "AbstractSet".

   버전 3.9부터 폐지: "builtins.set" now supports subscripting ("[]").
   See **PEP 585** and 제네릭 에일리어스 형.

class typing.FrozenSet(frozenset, AbstractSet[T_co])

   A generic version of "builtins.frozenset".

   버전 3.9부터 폐지: "builtins.frozenset" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

참고:

  "Tuple" is a special form.


Corresponding to types in "collections"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class typing.DefaultDict(collections.defaultdict, MutableMapping[KT, VT])

   A generic version of "collections.defaultdict".

   버전 3.5.2에 추가.

   버전 3.9부터 폐지: "collections.defaultdict" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.OrderedDict(collections.OrderedDict, MutableMapping[KT, VT])

   A generic version of "collections.OrderedDict".

   버전 3.7.2에 추가.

   버전 3.9부터 폐지: "collections.OrderedDict" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.ChainMap(collections.ChainMap, MutableMapping[KT, VT])

   A generic version of "collections.ChainMap".

   버전 3.5.4에 추가.

   버전 3.6.1에 추가.

   버전 3.9부터 폐지: "collections.ChainMap" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Counter(collections.Counter, Dict[T, int])

   A generic version of "collections.Counter".

   버전 3.5.4에 추가.

   버전 3.6.1에 추가.

   버전 3.9부터 폐지: "collections.Counter" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Deque(deque, MutableSequence[T])

   A generic version of "collections.deque".

   버전 3.5.4에 추가.

   버전 3.6.1에 추가.

   버전 3.9부터 폐지: "collections.deque" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.


Other concrete types
~~~~~~~~~~~~~~~~~~~~

class typing.IO
class typing.TextIO
class typing.BinaryIO

   Generic type "IO[AnyStr]" and its subclasses "TextIO(IO[str])" and
   "BinaryIO(IO[bytes])" represent the types of I/O streams such as
   returned by "open()".

   Deprecated since version 3.8, will be removed in version 3.13: The
   "typing.io" namespace is deprecated and will be removed. These
   types should be directly imported from "typing" instead.

class typing.Pattern
class typing.Match

   These type aliases correspond to the return types from
   "re.compile()" and "re.match()".  These types (and the
   corresponding functions) are generic in "AnyStr" and can be made
   specific by writing "Pattern[str]", "Pattern[bytes]", "Match[str]",
   or "Match[bytes]".

   Deprecated since version 3.8, will be removed in version 3.13: The
   "typing.re" namespace is deprecated and will be removed. These
   types should be directly imported from "typing" instead.

   버전 3.9부터 폐지: "re"의 클래스 "Pattern"과 "Match"는 이제 "[]"를
   지원합니다. **PEP 585**와 제네릭 에일리어스 형을 참조하십시오.

class typing.Text

   "Text" is an alias for "str". It is provided to supply a forward
   compatible path for Python 2 code: in Python 2, "Text" is an alias
   for "unicode".

   "Text"를 사용하여 값이 파이썬 2와 파이썬 3 모두와 호환되는 방식으로
   유니코드 문자열을 포함해야 함을 나타내십시오:

      def add_unicode_checkmark(text: Text) -> Text:
          return text + u' \u2713'

   버전 3.5.2에 추가.


Abstract Base Classes
---------------------


Corresponding to collections in "collections.abc"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class typing.AbstractSet(Collection[T_co])

   A generic version of "collections.abc.Set".

   버전 3.9부터 폐지: "collections.abc.Set" now supports subscripting
   ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.ByteString(Sequence[int])

   A generic version of "collections.abc.ByteString".

   이 형은 "bytes", "bytearray" 및 바이트 시퀀스의 "memoryview" 형을
   나타냅니다.

   As a shorthand for this type, "bytes" can be used to annotate
   arguments of any of the types mentioned above.

   버전 3.9부터 폐지: "collections.abc.ByteString" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Collection(Sized, Iterable[T_co], Container[T_co])

   A generic version of "collections.abc.Collection"

   버전 3.6.0에 추가.

   버전 3.9부터 폐지: "collections.abc.Collection" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Container(Generic[T_co])

   A generic version of "collections.abc.Container".

   버전 3.9부터 폐지: "collections.abc.Container" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.ItemsView(MappingView, AbstractSet[tuple[KT_co, VT_co]])

   A generic version of "collections.abc.ItemsView".

   버전 3.9부터 폐지: "collections.abc.ItemsView" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.KeysView(MappingView, AbstractSet[KT_co])

   A generic version of "collections.abc.KeysView".

   버전 3.9부터 폐지: "collections.abc.KeysView" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Mapping(Collection[KT], Generic[KT, VT_co])

   A generic version of "collections.abc.Mapping". This type can be
   used as follows:

      def get_position_in_index(word_list: Mapping[str, int], word: str) -> int:
          return word_list[word]

   버전 3.9부터 폐지: "collections.abc.Mapping" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.MappingView(Sized)

   A generic version of "collections.abc.MappingView".

   버전 3.9부터 폐지: "collections.abc.MappingView" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.MutableMapping(Mapping[KT, VT])

   A generic version of "collections.abc.MutableMapping".

   버전 3.9부터 폐지: "collections.abc.MutableMapping" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.MutableSequence(Sequence[T])

   A generic version of "collections.abc.MutableSequence".

   버전 3.9부터 폐지: "collections.abc.MutableSequence" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.MutableSet(AbstractSet[T])

   A generic version of "collections.abc.MutableSet".

   버전 3.9부터 폐지: "collections.abc.MutableSet" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Sequence(Reversible[T_co], Collection[T_co])

   A generic version of "collections.abc.Sequence".

   버전 3.9부터 폐지: "collections.abc.Sequence" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.ValuesView(MappingView, Collection[_VT_co])

   A generic version of "collections.abc.ValuesView".

   버전 3.9부터 폐지: "collections.abc.ValuesView" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.


Corresponding to other types in "collections.abc"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class typing.Iterable(Generic[T_co])

   A generic version of "collections.abc.Iterable".

   버전 3.9부터 폐지: "collections.abc.Iterable" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Iterator(Iterable[T_co])

   A generic version of "collections.abc.Iterator".

   버전 3.9부터 폐지: "collections.abc.Iterator" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Generator(Iterator[T_co], Generic[T_co, T_contra, V_co])

   A generator can be annotated by the generic type
   "Generator[YieldType, SendType, ReturnType]". For example:

      def echo_round() -> Generator[int, float, str]:
          sent = yield 0
          while sent >= 0:
              sent = yield round(sent)
          return 'Done'

   Note that unlike many other generics in the typing module, the
   "SendType" of "Generator" behaves contravariantly, not covariantly
   or invariantly.

   If your generator will only yield values, set the "SendType" and
   "ReturnType" to "None":

      def infinite_stream(start: int) -> Generator[int, None, None]:
          while True:
              yield start
              start += 1

   Alternatively, annotate your generator as having a return type of
   either "Iterable[YieldType]" or "Iterator[YieldType]":

      def infinite_stream(start: int) -> Iterator[int]:
          while True:
              yield start
              start += 1

   버전 3.9부터 폐지: "collections.abc.Generator" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Hashable

   An alias to "collections.abc.Hashable".

class typing.Reversible(Iterable[T_co])

   A generic version of "collections.abc.Reversible".

   버전 3.9부터 폐지: "collections.abc.Reversible" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Sized

   An alias to "collections.abc.Sized".


Asynchronous programming
~~~~~~~~~~~~~~~~~~~~~~~~

class typing.Coroutine(Awaitable[V_co], Generic[T_co, T_contra, V_co])

   A generic version of "collections.abc.Coroutine". The variance and
   order of type variables correspond to those of "Generator", for
   example:

      from collections.abc import Coroutine
      c: Coroutine[list[str], str, int]  # Some coroutine defined elsewhere
      x = c.send('hi')                   # Inferred type of 'x' is list[str]
      async def bar() -> None:
          y = await c                    # Inferred type of 'y' is int

   버전 3.5.3에 추가.

   버전 3.9부터 폐지: "collections.abc.Coroutine" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.AsyncGenerator(AsyncIterator[T_co], Generic[T_co, T_contra])

   An async generator can be annotated by the generic type
   "AsyncGenerator[YieldType, SendType]". For example:

      async def echo_round() -> AsyncGenerator[int, float]:
          sent = yield 0
          while sent >= 0.0:
              rounded = await round(sent)
              sent = yield rounded

   Unlike normal generators, async generators cannot return a value,
   so there is no "ReturnType" type parameter. As with "Generator",
   the "SendType" behaves contravariantly.

   If your generator will only yield values, set the "SendType" to
   "None":

      async def infinite_stream(start: int) -> AsyncGenerator[int, None]:
          while True:
              yield start
              start = await increment(start)

   Alternatively, annotate your generator as having a return type of
   either "AsyncIterable[YieldType]" or "AsyncIterator[YieldType]":

      async def infinite_stream(start: int) -> AsyncIterator[int]:
          while True:
              yield start
              start = await increment(start)

   버전 3.6.1에 추가.

   버전 3.9부터 폐지: "collections.abc.AsyncGenerator" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.AsyncIterable(Generic[T_co])

   A generic version of "collections.abc.AsyncIterable".

   버전 3.5.2에 추가.

   버전 3.9부터 폐지: "collections.abc.AsyncIterable" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.AsyncIterator(AsyncIterable[T_co])

   A generic version of "collections.abc.AsyncIterator".

   버전 3.5.2에 추가.

   버전 3.9부터 폐지: "collections.abc.AsyncIterator" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.Awaitable(Generic[T_co])

   A generic version of "collections.abc.Awaitable".

   버전 3.5.2에 추가.

   버전 3.9부터 폐지: "collections.abc.Awaitable" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.


Context manager types
~~~~~~~~~~~~~~~~~~~~~

class typing.ContextManager(Generic[T_co])

   A generic version of "contextlib.AbstractContextManager".

   버전 3.5.4에 추가.

   버전 3.6.0에 추가.

   버전 3.9부터 폐지: "contextlib.AbstractContextManager" now supports
   subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스 형.

class typing.AsyncContextManager(Generic[T_co])

   A generic version of "contextlib.AbstractAsyncContextManager".

   버전 3.5.4에 추가.

   버전 3.6.2에 추가.

   버전 3.9부터 폐지: "contextlib.AbstractAsyncContextManager" now
   supports subscripting ("[]"). See **PEP 585** and 제네릭 에일리어스
   형.


프로토콜
--------

These protocols are decorated with "runtime_checkable()".

class typing.SupportsAbs

   반환형이 공변적(covariant)인 하나의 추상 메서드 "__abs__"를 가진
   ABC.

class typing.SupportsBytes

   하나의 추상 메서드 "__bytes__"를 가진 ABC.

class typing.SupportsComplex

   하나의 추상 메서드 "__complex__"를 가진 ABC.

class typing.SupportsFloat

   하나의 추상 메서드 "__float__"를 가진 ABC.

class typing.SupportsIndex

   하나의 추상 메서드 "__index__"를 가진 ABC.

   버전 3.8에 추가.

class typing.SupportsInt

   하나의 추상 메서드 "__int__"를 가진 ABC.

class typing.SupportsRound

   반환형이 공변적(covariant)인 하나의 추상 메서드 "__round__"를 가진
   ABC.


함수와 데코레이터
-----------------

typing.cast(typ, val)

   값을 형으로 변환합니다.

   값을 변경하지 않고 반환합니다. 형 검사기에서는 반환 값이 지정된 형
   임을 나타내지만, 실행 시간에는 의도적으로 아무것도 확인하지 않습니
   다 (우리는 이것이 가능한 한 빠르기를 원합니다).

@typing.overload

   The "@overload" decorator allows describing functions and methods
   that support multiple different combinations of argument types. A
   series of "@overload"-decorated definitions must be followed by
   exactly one non-"@overload"-decorated definition (for the same
   function/method). The "@overload"-decorated definitions are for the
   benefit of the type checker only, since they will be overwritten by
   the non-"@overload"-decorated definition, while the latter is used
   at runtime but should be ignored by a type checker.  At runtime,
   calling a "@overload"-decorated function directly will raise
   "NotImplementedError". An example of overload that gives a more
   precise type than can be expressed using a union or a type
   variable:

      @overload
      def process(response: None) -> None:
          ...
      @overload
      def process(response: int) -> tuple[int, str]:
          ...
      @overload
      def process(response: bytes) -> str:
          ...
      def process(response):
          <actual implementation>

   See **PEP 484** for more details and comparison with other typing
   semantics.

@typing.final

   A decorator to indicate to type checkers that the decorated method
   cannot be overridden, and the decorated class cannot be subclassed.
   For example:

      class Base:
          @final
          def done(self) -> None:
              ...
      class Sub(Base):
          def done(self) -> None:  # Error reported by type checker
              ...

      @final
      class Leaf:
          ...
      class Other(Leaf):  # Error reported by type checker
          ...

   이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 **PEP
   591**을 참조하십시오.

   버전 3.8에 추가.

@typing.no_type_check

   어노테이션이 형 힌트가 아님을 나타내는 데코레이터.

   This works as class or function *decorator*.  With a class, it
   applies recursively to all methods defined in that class (but not
   to methods defined in its superclasses or subclasses).

   This mutates the function(s) in place.

@typing.no_type_check_decorator

   다른 데코레이터에 "no_type_check()" 효과를 주는 데코레이터.

   이것은 데코레이트 된 함수를 "no_type_check()"로 감싸는 무언가로 데
   코레이터를 감쌉니다.

@typing.type_check_only

   Decorator to mark a class or function to be unavailable at runtime.

   이 데코레이터 자체는 실행 시간에 사용할 수 없습니다. 주로, 구현이
   비공개 클래스의 인스턴스를 반환할 때, 형 스텁 파일에 정의된 클래스
   를 표시하기 위한 용도입니다:

      @type_check_only
      class Response:  # private or not available at runtime
          code: int
          def get_header(self, name: str) -> str: ...

      def fetch_response() -> Response: ...

   비공개 클래스의 인스턴스를 반환하는 것은 좋지 않음에 유의하십시오.
   일반적으로 그러한 클래스를 공개로 만드는 것이 바람직합니다.


인트로스펙션 도우미
-------------------

typing.get_type_hints(obj, globalns=None, localns=None, include_extras=False)

   함수, 메서드, 모듈 또는 클래스 객체에 대한 형 힌트가 포함된 딕셔너
   리를 반환합니다.

   This is often the same as "obj.__annotations__". In addition,
   forward references encoded as string literals are handled by
   evaluating them in "globals" and "locals" namespaces. If necessary,
   "Optional[t]" is added for function and method annotations if a
   default value equal to "None" is set. For a class "C", return a
   dictionary constructed by merging all the "__annotations__" along
   "C.__mro__" in reverse order.

   The function recursively replaces all "Annotated[T, ...]" with "T",
   unless "include_extras" is set to "True" (see "Annotated" for more
   information). For example:

      class Student(NamedTuple):
          name: Annotated[str, 'some marker']

      get_type_hints(Student) == {'name': str}
      get_type_hints(Student, include_extras=False) == {'name': str}
      get_type_hints(Student, include_extras=True) == {
          'name': Annotated[str, 'some marker']
      }

   참고:

     "get_type_hints()" does not work with imported type aliases that
     include forward references. Enabling postponed evaluation of
     annotations (**PEP 563**) may remove the need for most forward
     references.

   버전 3.9에서 변경: Added "include_extras" parameter as part of
   **PEP 593**.

typing.get_args(tp)

typing.get_origin(tp)

   Provide basic introspection for generic types and special typing
   forms.

   For a typing object of the form "X[Y, Z, ...]" these functions
   return "X" and "(Y, Z, ...)". If "X" is a generic alias for a
   builtin or "collections" class, it gets normalized to the original
   class. If "X" is a union or "Literal" contained in another generic
   type, the order of "(Y, Z, ...)" may be different from the order of
   the original arguments "[Y, Z, ...]" due to type caching. For
   unsupported objects return "None" and "()" correspondingly.
   Examples:

      assert get_origin(Dict[str, int]) is dict
      assert get_args(Dict[int, str]) == (int, str)

      assert get_origin(Union[int, str]) is Union
      assert get_args(Union[int, str]) == (int, str)

   버전 3.8에 추가.

typing.is_typeddict(tp)

   Check if a type is a "TypedDict".

   예를 들면:

      class Film(TypedDict):
          title: str
          year: int

      is_typeddict(Film)  # => True
      is_typeddict(list | str)  # => False

   버전 3.10에 추가.

class typing.ForwardRef

   A class used for internal typing representation of string forward
   references. For example, "List["SomeClass"]" is implicitly
   transformed into "List[ForwardRef("SomeClass")]".  This class
   should not be instantiated by a user, but may be used by
   introspection tools.

   참고:

     **PEP 585** generic types such as "list["SomeClass"]" will not be
     implicitly transformed into "list[ForwardRef("SomeClass")]" and
     thus will not automatically resolve to "list[SomeClass]".

   버전 3.7.4에 추가.


상수
----

typing.TYPE_CHECKING

   A special constant that is assumed to be "True" by 3rd party static
   type checkers. It is "False" at runtime. Usage:

      if TYPE_CHECKING:
          import expensive_mod

      def fun(arg: 'expensive_mod.SomeType') -> None:
          local_var: expensive_mod.AnotherType = other_fun()

   첫 번째 어노테이션은 따옴표로 묶여야 합니다, "전방 참조"로 만들어서
   인터프리터 실행 시간에 "expensive_mod" 참조를 숨깁니다. 지역 변수에
   대한 형 어노테이션은 평가되지 않기 때문에, 두 번째 어노테이션을 따
   옴표로 묶을 필요는 없습니다.

   참고:

     If "from __future__ import annotations" is used, annotations are
     not evaluated at function definition time. Instead, they are
     stored as strings in "__annotations__". This makes it unnecessary
     to use quotes around the annotation (see **PEP 563**).

   버전 3.5.2에 추가.
