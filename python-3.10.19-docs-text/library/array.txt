"array" --- Efficient arrays of numeric values
**********************************************

======================================================================

This module defines an object type which can compactly represent an
array of basic values: characters, integers, floating point numbers.
Arrays are sequence types and behave very much like lists, except that
the type of objects stored in them is constrained.  The type is
specified at object creation time by using a *type code*, which is a
single character.  The following type codes are defined:

+-------------+----------------------+---------------------+-------------------------+---------+
| 형 코드     | C 형                 | 파이썬 형           | 최소 크기(바이트)       | 노트    |
|=============|======================|=====================|=========================|=========|
| "'b'"       | signed char          | int                 | 1                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'B'"       | unsigned char        | int                 | 1                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'u'"       | wchar_t              | 유니코드 문자       | 2                       | (1)     |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'h'"       | signed short         | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'H'"       | unsigned short       | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'i'"       | signed int           | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'I'"       | unsigned int         | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'l'"       | signed long          | int                 | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'L'"       | unsigned long        | int                 | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'q'"       | signed long long     | int                 | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'Q'"       | unsigned long long   | int                 | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'f'"       | float                | float               | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'d'"       | double               | float               | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+

노트:

1. 플랫폼에 따라 16비트 또는 32비트 일 수 있습니다.

   버전 3.9에서 변경: "array('u')" now uses "wchar_t" as C type
   instead of deprecated "Py_UNICODE". This change doesn't affect its
   behavior because "Py_UNICODE" is alias of "wchar_t" since Python
   3.3.

   Deprecated since version 3.3, will be removed in version 4.0.

값의 실제 표현은 기계 아키텍처에 의해(엄격히 말하자면 C 구현에 의해)
결정됩니다. 실제 크기는 "array.itemsize" 어트리뷰트를 통해 액세스할 수
있습니다.

모듈은 다음 항목을 정의합니다:

array.typecodes

   사용 가능한 모든 형 코드가 있는 문자열.

모듈은 다음 형을 정의합니다:

class array.array(typecode[, initializer])

   A new array whose items are restricted by *typecode*, and
   initialized from the optional *initializer* value, which must be a
   list, a *bytes-like object*, or iterable over elements of the
   appropriate type.

   If given a list or string, the initializer is passed to the new
   array's "fromlist()", "frombytes()", or "fromunicode()" method (see
   below) to add initial items to the array.  Otherwise, the iterable
   initializer is passed to the "extend()" method.

   배열 객체는 인덱싱, 슬라이싱, 이어붙이기 및 곱셈과 같은 일반적인 시
   퀀스 연산을 지원합니다. 슬라이스 대입을 사용할 때, 대입되는 값은 같
   은 형 코드의 배열 객체여야 합니다; 다른 모든 경우에는, "TypeError"
   가 발생합니다. 배열 객체는 버퍼 인터페이스도 구현하며, *바이트열류
   객체*가 지원되는 곳이면 어디에서나 사용될 수 있습니다.

   "typecode", "initializer" 인자로 감사 이벤트(auditing event)
   "array.__new__"를 발생시킵니다.

   typecode

      배열을 만드는 데 사용된 typecode 문자.

   itemsize

      내부 표현에서 하나의 배열 항목의 길이 (바이트).

   append(x)

      배열의 끝에 값 *x*로 새 항목을 추가합니다.

   buffer_info()

      배열의 내용을 담는 데 사용된 버퍼의 현재 메모리 주소와 요소의 수
      로 표현한 길이를 제공하는 튜플 "(address, length)"를 반환합니다.
      바이트 단위의 메모리 버퍼 크기는 "array.buffer_info()[1] *
      array.itemsize"로 계산할 수 있습니다. 이것은 특정 "ioctl()" 연산
      과 같은 메모리 주소가 필요한 저수준(그리고 근본적으로 안전하지
      않은) I/O 인터페이스로 작업할 때 간혹 유용합니다. 반환된 숫자는
      배열이 존재하고 길이 변경 연산이 적용되지 않는 한 유효합니다.

      참고:

        C나 C++로 작성된 코드(이 정보를 효율적으로 사용하는 유일한 방
        법)에서 배열 객체를 사용할 때, 배열 객체가 지원하는 버퍼 인터
        페이스를 사용하는 것이 좋습니다. 이 메서드는 이전 버전과의 호
        환성을 위해 유지되며 새 코드에서는 사용하지 않아야 합니다. 버
        퍼 인터페이스는 버퍼 프로토콜에 설명되어 있습니다.

   byteswap()

      배열의 모든 항목을 "바이트 스와프(byteswap)" 합니다. 1, 2, 4 또
      는 8바이트 크기의 값에 대해서만 지원됩니다; 다른 형의 값이면
      "RuntimeError"가 발생합니다. 바이트 순서가 다른 컴퓨터에서 작성
      된 파일에서 데이터를 읽을 때 유용합니다.

   count(x)

      배열 내에서 *x*가 등장하는 횟수를 반환합니다.

   extend(iterable)

      *iterable*의 항목을 배열의 끝에 추가합니다. *iterable*이 다른 배
      열이면, *정확히* 같은 형 코드를 가져야 합니다; 그렇지 않으면,
      "TypeError"가 발생합니다. *iterable*이 배열이 아니면, 이터러블이
      어야 하며 요소는 배열에 추가할 올바른 형이어야 합니다.

   frombytes(s)

      Appends items from the string, interpreting the string as an
      array of machine values (as if it had been read from a file
      using the "fromfile()" method).

      버전 3.2에 추가: "fromstring()"은 명확하게 하려고 "frombytes()"
      로 이름을 바꿨습니다.

   fromfile(f, n)

      *파일 객체* *f*에서 (기곗값으로) *n* 항목을 읽고 배열의 끝에 추
      가합니다. *n* 미만의 항목만 사용할 수 있으면 "EOFError"가 발생하
      지만, 사용 가능한 항목은 여전히 배열에 삽입됩니다.

   fromlist(list)

      리스트에서 항목을 추가합니다. 이것은 형 에러가 있으면 배열이 변
      경되지 않는다는 점만 제외하면 "for x in list: a.append(x)"와 동
      등합니다.

   fromunicode(s)

      Extends this array with data from the given unicode string.  The
      array must be a type "'u'" array; otherwise a "ValueError" is
      raised.  Use "array.frombytes(unicodestring.encode(enc))" to
      append Unicode data to an array of some other type.

   index(x[, start[, stop]])

      Return the smallest *i* such that *i* is the index of the first
      occurrence of *x* in the array.  The optional arguments *start*
      and *stop* can be specified to search for *x* within a
      subsection of the array.  Raise "ValueError" if *x* is not
      found.

      버전 3.10에서 변경: Added optional *start* and *stop*
      parameters.

   insert(i, x)

      *i* 위치 앞에 값이 *x*인 새 항목을 배열에 삽입합니다. 음수 값은
      배열 끝에 상대적인 값으로 처리됩니다.

   pop([i])

      배열에서 인덱스 *i*에 있는 항목을 제거하고 이를 반환합니다. 선택
      적 인자의 기본값은 "-1"이므로, 기본적으로 마지막 항목이 제거되고
      반환됩니다.

   remove(x)

      배열에서 첫 번째 *x*를 제거합니다.

   reverse()

      배열의 항목 순서를 뒤집습니다.

   tobytes()

      배열을 기곗값 배열로 변환하고 바이트열 표현("tofile()" 메서드로
      파일에 기록될 바이트 시퀀스와 같습니다)을 반환합니다.

      버전 3.2에 추가: "tostring()"은 명확하게 하려고 "tobytes()"로 이
      름을 바꿨습니다.

   tofile(f)

      모든 항목을 (기곗값으로) *파일 객체* *f*에 씁니다.

   tolist()

      배열을 같은 항목이 있는 일반 리스트로 변환합니다.

   tounicode()

      Convert the array to a unicode string.  The array must be a type
      "'u'" array; otherwise a "ValueError" is raised. Use
      "array.tobytes().decode(enc)" to obtain a unicode string from an
      array of some other type.

When an array object is printed or converted to a string, it is
represented as "array(typecode, initializer)".  The *initializer* is
omitted if the array is empty, otherwise it is a string if the
*typecode* is "'u'", otherwise it is a list of numbers.  The string is
guaranteed to be able to be converted back to an array with the same
type and value using "eval()", so long as the "array" class has been
imported using "from array import array". Examples:

   array('l')
   array('u', 'hello \u2641')
   array('l', [1, 2, 3, 4, 5])
   array('d', [1.0, 2.0, 3.14])

더 보기:

  모듈 "struct"
     이질적인(heterogeneous) 바이너리 데이터의 패킹과 언 패킹.

  Module "xdrlib"
     Packing and unpacking of External Data Representation (XDR) data
     as used in some remote procedure call systems.

  NumPy
     NumPy 패키지는 다른 배열형을 정의합니다.
